<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Source</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Source</h1><br/>/*<br /> Findjmp.c<br /> written by Ryan Permeh - ryan at eeye - Summarily modified by I2S-LaB.com<br /> http://www.eeye.com<br />   <br /> Findjmp2.c (pop/pop/ret scanner, logging to file)<br /> version by A.D - class101 at hat-squad<br /> http://class101.org, http://www.hat-squad.com<br /><br /><br /> This finds useful jump points in a dll. Once you overflow a buffer, by<br /> looking in the various registers, it is likely that you will find a<br /> reference to your code. This program will find addresses suitible to<br /> overwrite eip that will return to your code.<br /><br /> It should be easy to modify this to search for other good jump points,<br /> or specific code patterns within a dll.<br /><br /> It currently supports looking for:<br />   1. jmp reg<br /><br />   2. call reg<br /><br />   3. push reg<br />      ret<br /> All three options result in the same thing, EIP being set to reg.<br /><br /> It also supports the following registers:<br />  EAX<br />  EBX<br />  ECX<br />  EDX<br />  ESI<br />  EDI<br />  ESP<br />  EBP<br />*/<br /><br />#include &lt;iostream.h&gt;<br />#include &lt;fstream.h&gt;<br />#include &lt;Windows.h&gt;<br />#include &lt;stdio.h&gt;<br /><br />FILE *fplog;<br /><br />void usage();<br />void sep();<br />void iok(BYTE *curpos, char *reg);<br />void iok2(BYTE *curpos, char *reg);<br />void ook(BYTE *curpos, char *reg);<br />void ook2(BYTE *curpos, char *reg);<br /><br />DWORD GetRegNum( char *reg );<br />void findjmp( char *dll, char *reg );<br /><br /> //This finds useful jump points in a dll. Once you overflow a buffer, by<br /> //looking in the various registers, it is likely that you will find a<br /> //reference to your code. This program will find addresses of suitible<br /> //addresses of eip that will return to your code.<br /><br />int main( int argc, char **argv )<br />{<br /> if( argc &lt;= 2 )<br />  usage();<br />  <br /> else<br /> {<br />  char dll[512], //holder for the dll to look in<br />  reg[512]; // holder for the register<br /><br />  if ((fplog =fopen("findjmp.txt","r"))==NULL){<br />   fplog =fopen("findjmp.txt","w");}<br />  else fplog =fopen("findjmp.txt","a");<br />  strncpy( dll, argv[1], 512 );<br />  strncpy( reg, argv[2], 512 );<br />  findjmp( dll, reg );<br /> }<br /> return 0;<br />}<br /><br /> //This prints the usage information.<br /><br />void usage()<br />{<br /> printf("\nFindjmp, Eeye, I2S-LaB\nFindjmp2, Hat-Squad\nFindJmp DLL registre\nEx: findjmp KERNEL32.DLL esp"\<br />     "\nCurrently supported registre are: EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP\n" );<br />}<br /><br /> //findjmp is the workhorse. it loads the requested dll, and searches for<br /> //the specific patterns for jmp reg, push reg ret, and call reg<br /><br />void findjmp( char *dll,char *reg )<br />{<br />    char reg1[]="eax";char reg2[]="ebx";<br />    char reg3[]="ecx";char reg4[]="edx";<br /> char reg5[]="esi";char reg6[]="edi";<br />    char reg7[]="esp";char reg8[]="ebp";<br /><br /> BYTE jmppat[8][2]={ { 0xFF, 0xE0 }, { 0xFF, 0xE3 }, { 0xFF, 0xE1 }, { 0xFF, 0xE2 },<br />       { 0xFF, 0xE6 }, { 0xFF, 0xE7 }, { 0xFF, 0xE4 }, { 0xFF, 0xE5 } }; // patterns for jmp ops<br /> <br /> BYTE callpat[8][2]={ { 0xFF, 0xD0 }, { 0xFF, 0xD3 }, { 0xFF, 0xD1 }, { 0xFF, 0xD2},<br />       { 0xFF, 0xD6 }, { 0xFF, 0xD7 }, { 0xFF, 0xD4 }, { 0xFF, 0xD5 } }; // patterns for call ops<br /> <br /> BYTE pushretpat[8][2]={ { 0x50, 0xC3 }, { 0x53, 0xC3 }, { 0x51, 0xC3 }, { 0x52, 0xC3 },<br />       { 0x56, 0xC3 }, { 0x57, 0xC3 }, { 0x54, 0xC3 }, { 0x55, 0xC3 } }; // patterns for pushret ops<br /><br /> BYTE poppat[8][1]={ { 0x58 }, { 0x5B }, { 0x59 }, { 0x5A }, // patterns for pop,pop,ret<br />     { 0x5E }, { 0x5F }, { 0x5C }, { 0x5D },};<br /> <br /> BYTE retn[1][1]={ 0xC3 }; // pattern for pop,pop,ret<br /><br /> BYTE retnbis[1][1]={ 0xC2 }; // pattern for pop,pop,ret<br /><br /><br /> HMODULE loadedDLL; //base pointer for the loaded DLL<br /><br /> BYTE *curpos; //current position within the DLL<br /> BYTE *curpos2; //subposition pop,pop,ret<br /><br /> DWORD regnum=GetRegNum(reg); // decimal representation of passed register<br /> DWORD regnum1=GetRegNum(reg1);DWORD regnum2=GetRegNum(reg2);<br /> DWORD regnum3=GetRegNum(reg3);DWORD regnum4=GetRegNum(reg4);<br /> DWORD regnum5=GetRegNum(reg5);DWORD regnum6=GetRegNum(reg6);<br /> DWORD regnum7=GetRegNum(reg7);DWORD regnum8=GetRegNum(reg8);<br /><br /> DWORD numaddr=0; //accumulator for addresses<br /><br /> if( regnum == -1 ) //check if register is useable<br /> { //it didn't load, time to bail<br />  printf( "There was a problem understanding the register.\n"\<br />   "Please check that it isa correct IA32 register name\n"\<br />   "Currently supported are:\n "\<br />   "EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP\n"\<br />   );<br /><br />  exit(-1);<br /> }<br /><br /> if( (loadedDLL=LoadLibraryA(dll)) == NULL) // check if DLL loaded correctly<br /> { //it didn't load, time to bail<br />  printf( "There was a problem Loading the requested DLL.\n"\<br />    "Please check that it is in your path and readable\n" );<br />  exit(-1);<br /> }<br /> else<br /> {<br />  sep();<br />  fprintf(fplog,"Findjmp, Eeye, I2S-LaB\nFindjmp2, Hat-Squad\n");<br />  printf("\nFindjmp, Eeye, I2S-LaB\nFindjmp2, Hat-Squad\n");<br />  printf( "Scanning %s for code useable with the %s register\n", dll, reg ); //we loaded the dll correctly, time to scan it<br />  fprintf(fplog,"Scanning %s for code useable with the %s register\n", dll, reg ); //we loaded the dll correctly, time to scan it<br />  sep();<br />  curpos=(BYTE*)loadedDLL; //set curpos at start of DLL<br />  curpos2=(BYTE*)loadedDLL; //pop,pop,ret subscan.<br /><br />  __try<br />  {<br />   while(1)<br />   {<br />    Sleep(1/10);<br />    if( !memcmp( curpos, jmppat[regnum], 2) ) //check for jmp match<br />    {<br />     printf( "0x%X\tjmp %s\n", curpos, reg ); // we have a jmp match<br />     fprintf(fplog,"0x%X\tjmp %s\n", curpos, reg ); // we have a jmp match<br />     numaddr++;<br />    }<br />    else if( !memcmp( curpos, callpat[regnum],2) ) //check for call match<br /><br />    {<br />     printf( "0x%X\tcall %s\n", curpos, reg ); // we have a call match<br />     fprintf(fplog,"0x%X\tcall %s\n", curpos, reg );<br />     numaddr++;<br />    }<br />    else if( !memcmp(curpos,pushretpat[regnum], 2) ) //check for push/ret match<br />    {<br />     printf( "0x%X\tpush %s - ret\n", curpos, reg ); // we have a pushret match<br />     fprintf(fplog,"0x%X\tpush %s - ret\n", curpos, reg ); // we have a jmp match<br />     numaddr++;<br />    }<br />    else if( !memcmp(curpos,poppat[regnum], 1) ) //check for pop/pop/ret match<br />    {<br />     curpos2++;<br />     if( !memcmp(curpos2,poppat[regnum1], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum2], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum3], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum4], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum5], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum6], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum7], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     if( !memcmp(curpos2,poppat[regnum8], 1) )<br />     {<br />      curpos2++;<br />      if( !memcmp(curpos2,retn, 1) )<br />      {<br />       iok(curpos, reg); // we have a popopret match<br />       ook(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      if( !memcmp(curpos2,retnbis, 1) )<br />      {<br />       iok2(curpos, reg); // we have a popopret match<br />       ook2(curpos, reg); // we have a popopret match<br />       numaddr++;<br />      }<br />      curpos2--;curpos2--;goto loop;<br />     }<br />     curpos2--;<br />    }<br />loop:<br />    curpos++;<br />    curpos2++;<br />   }<br />  }<br />  __except(1)<br />  {<br />   sep();<br />   fprintf( fplog,"Finished Scanning %s for code useable with the %s register\n", dll, reg );<br />   printf( "Finished Scanning %s for code useable with the %s register\n", dll, reg );<br />   printf( "Found %d usable addresses\n", numaddr );<br />   fprintf( fplog,"Found %d usable addresses\n", numaddr );sep();fprintf( fplog,"\n\n\n");<br />  }<br /> }<br /><br />}<br /><br /><br />DWORD GetRegNum( char *reg )<br />{<br /> DWORD ret=-1;<br /> if( !stricmp( reg, "eax") )<br /> {<br />  ret=0;<br /> }<br /> else if( !stricmp( reg, "ebx") )<br /> {<br />  ret=1;<br /> }<br /> else if( !stricmp( reg, "ecx") )<br /> {<br />  ret=2;<br /> }<br /> else if( !stricmp( reg, "edx") )<br /> {<br />  ret=3;<br /> }<br /> else if( !stricmp( reg, "esi") )<br /> {<br />  ret=4;<br /> }<br /> else if( !stricmp( reg, "edi") )<br /> {<br />  ret=5;<br /> }<br /> else if( !stricmp( reg, "esp") )<br /> {<br />  ret=6;<br /> }<br /> else if( !stricmp( reg, "ebp") )<br /> {<br />  ret=7;<br /> }<br /><br /> return ret; //return our decimal register number<br />}<br /><br />void sep()<br />{<br /> fprintf(fplog,"----------------------------------------------------------------------------\n");<br />}<br /><br />void iok(BYTE *curpos, char *reg)<br />{<br /> printf( "0x%X\tpop %s - pop - ret\n", curpos, reg ); // we have a popopret match<br />}<br /><br />void iok2(BYTE *curpos, char *reg)<br />{<br /> printf( "0x%X\tpop %s - pop - retbis\n", curpos, reg ); // we have a popopret match<br />}<br /><br />void ook(BYTE *curpos, char *reg)<br />{<br /> fprintf(fplog,"0x%X\tpop %s - pop - ret\n", curpos, reg ); // we have a jmp match<br />}<br /><br />void ook2(BYTE *curpos, char *reg)<br />{<br /> fprintf(fplog,"0x%X\tpop %s - pop - retbis\n", curpos, reg ); // we have a jmp match<br />}</div></body></html>