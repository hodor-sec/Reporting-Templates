<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>x86</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">x86</h1><br/><h2> General Purpose Registers</h2><br /> <br /><table class="table"><col/><col/><col/><col/><col/><tr><th> 32 bit</th><th> 16 bit</th><th> 8 high bit</th><th> 8 low bit</th><th> description</th></tr><tr><td> eax</td><td> ax</td><td> ah</td><td> al</td><td> accumulator</td></tr><tr><td> ebx</td><td> bx</td><td> bh</td><td> bl</td><td> base</td></tr><tr><td> ecx</td><td> cx</td><td> ch</td><td> cl</td><td> counter</td></tr><tr><td> edx</td><td> dx</td><td> dh</td><td> dl</td><td> data</td></tr><tr><td> esi</td><td> si</td><td> N/A</td><td> N/A</td><td> source index</td></tr><tr><td> edi</td><td> di</td><td> N/A</td><td> N/A</td><td> destination index</td></tr><tr><td> ebp</td><td> bp</td><td> N/A</td><td> N/A</td><td> base pointer</td></tr><tr><td> esp</td><td> sp</td><td> N/A</td><td> N/A</td><td> stack pointer</td></tr></table><br /><br /><h2> Pointer Registers</h2><br /><table class="table"><col/><col/><col/><tr><th> 32 bit</th><th> 16 bit</th><th> description</th></tr><tr><td> eip</td><td> ip</td><td> instruction pointer</td></tr></table><br /><br /><h2> Segment Registers</h2><br /><table class="table"><col/><col/><tr><th> 16 bit</th><th> description</th></tr><tr><td> cs</td><td> code segment</td></tr><tr><td> ds</td><td> data segment</td></tr><tr><td> es</td><td> extra segment</td></tr><tr><td> ss</td><td> stack segment</td></tr><tr><td> fs</td><td> general purpose f segment</td></tr><tr><td> gs</td><td> general purpose g segment</td></tr></table><br /><br /><h2> EFLAGS Register</h2><br /><table class="table"><col/><col/><col/><tr><th> bit</th><th> label</th><th> description</th></tr><tr><td> 0</td><td> cf</td><td> carry flag</td></tr><tr><td> 2</td><td> pf</td><td> parity flag</td></tr><tr><td> 4</td><td> af</td><td> auxiliary flag</td></tr><tr><td> 6</td><td> zf</td><td> zero flag</td></tr><tr><td> 7</td><td> sf</td><td> sign flag</td></tr><tr><td> 8</td><td> tf</td><td> trap flag</td></tr><tr><td> 9</td><td> if</td><td> interrupt flag</td></tr><tr><td> 10</td><td> df</td><td> direction flag</td></tr><tr><td> 11</td><td> of</td><td> overflow flag</td></tr><tr><td> 12-13</td><td> iopl</td><td> i/o privilege level</td></tr><tr><td> 14</td><td> nt</td><td> nested task flag</td></tr><tr><td> 16</td><td> rf</td><td> resume flag</td></tr><tr><td> 17</td><td> vm</td><td> virtual 8086 mode flag</td></tr><tr><td> 18</td><td> ac</td><td> alignment check flag</td></tr><tr><td> 19</td><td> vif</td><td> virtual interrupt flag</td></tr><tr><td> 20</td><td> vip</td><td> virtual interrupt pending</td></tr><tr><td> 21</td><td> id</td><td> id flag</td></tr></table><br /><br /><h2> Control Registers</h2><br /><br /><h3> CR0</h3><br /><table class="table"><col/><col/><col/><tr><th> bit</th><th> label</th><th> description</th></tr><tr><td> 0</td><td> pe</td><td> protected mode enable</td></tr><tr><td> 1</td><td> mp</td><td> monitor co-processor</td></tr><tr><td> 2</td><td> em</td><td> emulation</td></tr><tr><td> 3</td><td> ts</td><td> task switched</td></tr><tr><td> 4</td><td> et</td><td> extension type</td></tr><tr><td> 5</td><td> ne</td><td> numeric error</td></tr><tr><td> 16</td><td> wp</td><td> write protect</td></tr><tr><td> 18</td><td> am</td><td> alignment mask</td></tr><tr><td> 29</td><td> nw</td><td> not-write through</td></tr><tr><td> 30</td><td> cd</td><td> cache disable</td></tr><tr><td> 31</td><td> pg</td><td> paging</td></tr></table><br />NOTE that this register is the only control register that can be  written and read via 2 ways unlike the other that can be accessed only  via the MOV instruction <br />;way 1:<br />;write:<br />mov cr0,reg<br />;read:<br />mov reg,cr0 <br />;----------------------<br />;way 2:<br />;write:<br />lmsw reg<br />Â <br />;read:<br />smsw reg<br /><h3> CR1</h3><br />Reserved, the cpu will throw a #ud exeption when trying to access them. <br /><br /><h3> CR2</h3><br /><table class="table"><col/><col/><col/><tr><th> bit</th><th> label</th><th> description</th></tr><tr><td> 0-31</td><td> pfla</td><td> page fault linear address</td></tr></table><br /><br /><h3> CR3</h3><br /><table class="table"><col/><col/><col/><col/><tr><th> bit</th><th> description</th><th> PAE mode</th><th> long mode</th></tr><tr><td> 0-31</td><td> physical base address of page directory</td><td> base of PDPT</td><td> base of PML4T</td></tr></table><br />Note that this must be page aligned <br /><br /><h3> CR4</h3><br /><table class="table"><col/><col/><col/><tr><th> bit</th><th> label</th><th> description</th></tr><tr><td> 0</td><td> vme</td><td> virtual 8086 mode extensions</td></tr><tr><td> 1</td><td> pvi</td><td> protected mode virtual interrupts</td></tr><tr><td> 2</td><td> tsd</td><td> time stamp disable</td></tr><tr><td> 3</td><td> de</td><td> debugging extensions</td></tr><tr><td> 4</td><td> pse</td><td> page size extension</td></tr><tr><td> 5</td><td> pae</td><td> physical address extension</td></tr><tr><td> 6</td><td> mce</td><td> machine check exception</td></tr><tr><td> 7</td><td> pge</td><td> page global enable</td></tr><tr><td> 8</td><td> pce</td><td> performance monitoring counter enable</td></tr><tr><td> 9</td><td> osfxsr</td><td> os support for fxsave and fxrstor instructions</td></tr><tr><td> 10</td><td> osxmmexcpt</td><td> os support for unmasked simd floating point exceptions</td></tr><tr><td> 11</td><td> umip</td><td> user mode instruction prevention (#GP on SGDT, SIDT, SLDT, SMSW, and STR instructions when CPL &gt; 0)</td></tr><tr><td> 13</td><td> vmxe</td><td> virtual machine extensions enable</td></tr><tr><td> 14</td><td> smxe</td><td> safer mode extensions enable</td></tr><tr><td> 17</td><td> pcide</td><td> pcid enable</td></tr><tr><td> 18</td><td> osxsave</td><td> xsave and processor extended states enable</td></tr><tr><td> 20</td><td> smep</td><td> supervisor mode executions protection enable</td></tr><tr><td> 21</td><td> smap</td><td> supervisor mode access protection enable</td></tr></table><br /><br /><h3> CR5 - CR7</h3><br />Reserved, same case as CR1. <br /><br /><h2> Debug Registers</h2><br /><br /><h3> DR0 - DR3</h3><br />Contain linear addresses of up to 4 breakpoints. If paging is enabled, they are translated to physical addresses. <br /><br /><h3> DR6</h3><br />It permits the debugger to determine which debug conditions have occurred.<br /> Bits 0 through 3 indicates, when set, that it's associated breakpoint condition was met when a debug exception was generated.<br /> Bit 13 indicates that the next instruction in the instruction stream accesses one of the debug registers.<br /> Bit 14 indicates (when set) that the debug exception was triggered by  the single-step execution mode (enabled with TF bit in EFLAGS).<br /> Bit 15 indicates (when set) that the debug instruction resulted from a  task switch where T flag in the TSS of target task was set.<br /> Bit 16 indicates (when clear) that the debug exception or breakpoint exception occured inside an RTM region.<br /> <br /><br /><h3> DR7</h3><br /><table class="table"><col/><col/><tr><th> bit</th><th> description</th></tr><tr><td> 0</td><td> local DR0 breakpoint</td></tr><tr><td> 1</td><td> global DR0 breakpoint</td></tr><tr><td> 2</td><td> local DR1 breakpoint</td></tr><tr><td> 3</td><td> global DR1 breakpoint</td></tr><tr><td> 4</td><td> local DR2 breakpoint</td></tr><tr><td> 5</td><td> global DR2 breakpoint</td></tr><tr><td> 6</td><td> local DR3 breakpoint</td></tr><tr><td> 7</td><td> global DR3 breakpoint</td></tr><tr><td> 16-17</td><td> conditions for DR0</td></tr><tr><td> 18-19</td><td> size of DR0 breakpoint</td></tr><tr><td> 20-21</td><td> conditions for DR1</td></tr><tr><td> 22-23</td><td> size of DR1 breakpoint</td></tr><tr><td> 24-25</td><td> conditions for DR2</td></tr><tr><td> 26-27</td><td> size of DR2 breakpoint</td></tr><tr><td> 28-29</td><td> conditions for DR3</td></tr><tr><td> 30-31</td><td> size of DR3 breakpoint</td></tr></table><br />A local breakpoint bit deactivates on hardware task switches, while a global does not.<br /> 00b condition means execution break, 01b means a write watchpoint, and  11b means an R/W watchpoint. 10b is reserved for I/O R/W (unsupported). <br /><br /><h2> Test Registers</h2><br /><table class="table"><col/><col/><tr><th> name</th><th> description</th></tr><tr><td> TR3 - TR5</td><td> undocumented</td></tr><tr><td> TR6</td><td> test command register</td></tr><tr><td> TR7</td><td> test data register</td></tr></table><br /><br /><h2> Protected Mode Registers</h2><br /><br /><h3> GDTR</h3><br /><table class="table"><col/><col/><col/><tr><th> bits</th><th> label</th><th> description</th></tr><tr><td> 0-15</td><td> limit</td><td> (size of GDT) - 1</td></tr><tr><td> 16-47</td><td> base</td><td> starting address of GDT</td></tr></table><br />Stores the segment selector of the <a href="https://wiki.osdev.org/GDT">GDT</a>. <br /><br /><h3> LDTR</h3><br /><table class="table"><col/><col/><col/><tr><th> bits</th><th> label</th><th> description</th></tr><tr><td> 0-15</td><td> limit</td><td> (size of LDT) - 1</td></tr><tr><td> 16-47</td><td> base</td><td> starting address of LDT</td></tr></table><br />Stores the segment selector of the <a href="https://wiki.osdev.org/LDT">LDT</a>. <br /><br /><h3> IDTR</h3><br /><table class="table"><col/><col/><col/><tr><th> bits</th><th> label</th><th> description</th></tr><tr><td> 0-15</td><td> limit</td><td> (size of IDT) - 1</td></tr><tr><td> 16-47</td><td> base</td><td> starting address of IDT</td></tr></table><br /></div></body></html>