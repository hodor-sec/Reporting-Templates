<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Quick reference</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Quick reference</h1><br/><br /><h1>nasm x86 Assembly Quick Reference ("Cheat Sheet")</h1><br /><table class="table"><col/><col/><col/><col/><tr><th>click me</th><th>click me</th><th>click me</th><th>click me</th></tr><tr><td>Mnemonic
      </td><td>Purpose
      </td><td>Examples
      </td><td>        </td></tr><tr><td>mov dest,src
      </td><td>Move data between registers, load immediate data into registers, move data between registers and memory.
      </td><td>mov eax,4  ; Load constant into eax
mov ebx,eax  ; Copy eax into ebx
mov [123],ebx ;  Copy ebx to memory address 123
      </td><td>                            </td></tr><tr><td>call func
            </td><td>Pushthe address of the next instruction and start executing func.  Forlocal functions, you don't have to say anything special.  Forfunctions defined in C/C++, say "extern func" first.
            </td><td>call print_int
            </td><td>                    </td></tr><tr><td>ret
            </td><td>Pop the return program counter, and jump there.  Ends a subroutine.
            </td><td>ret
            </td><td>          </td></tr><tr><td>add dest,src
      </td><td>dest=dest+src
      </td><td>add eax,ebx ; Add ebx to eax
      </td><td>        </td></tr><tr><td>mul src
      </td><td>Multiply eax and src as unsigned integers, and put the result in eax.  High 32 bits of product go into edx.
      </td><td>mul ebx ; Multiply eax by ebx
      </td><td>        </td></tr><tr><td>imul dest,src
            </td><td>dest=dest*src
            </td><td>imul ecx,3
            </td><td>                    </td></tr><tr><td>idiv bot
            </td><td>Divide eax by bot.  Treats edx as high bits above eax, so set them to zero first!
  top = eax+(edx&lt;&lt;32)
  eax = top/bot
  edx = top%bot
            </td><td>mov eax,73; top
mov ecx,10; bot
mov edx,0
idiv ecx
            </td><td>          </td></tr><tr><td>jmp label</td><td>Goto the instruction label:.  Skips anything else in the way.</td><td>jmp post_mem
 ...
post_mem:
</td><td>        </td></tr><tr><td>cmp a,b
      
      </td><td>Compare two values.  Setsflags that are used by the conditional jumps (below).  
 </td><td>cmp eax,10   
      </td><td>        </td></tr><tr><td>jl label</td><td>Goto labelif previous comparison came out as less-than.  Other conditionalsavailable are: jle (&lt;=), je (==), jge (&gt;=), jg (&gt;), jne (!=),and many others.  Declare your label with a semicolon beforehand, just like in C/C++: "label:".
</td><td>jl loop_start  ; Jump if eax&lt;10
      </td><td>    </td></tr><tr><td>push src</td><td>Insert a value onto the stack.  Useful for passing arguments, saving registers, etc.</td><td>push ebp</td><td>                    </td></tr><tr><td>pop dest</td><td>Remove topmost value from the stack.  Equivalent to "mov dest,[esp]     add esp,4"</td><td>pop ebp</td><td></td></tr></table><br />      <br />                  <br /><h2>Stack Frame </h2><br />(example without ebp or local variables)<br />      <table class="table"><col/><col/><col/><tr><th>click me</th><th>click me</th><th>click me</th></tr><tr><td>Contents
            </td><td>off esp
            </td><td>                    </td></tr><tr><td>caller's variables
            </td><td>[esp+12]
            </td><td>                    </td></tr><tr><td>Argument 2
            </td><td>[esp+8]
            </td><td>                    </td></tr><tr><td>Argument 1
            </td><td>[esp+4]
            </td><td>                    </td></tr><tr><td>Caller Return Address
            </td><td>[esp]
            </td><td></td></tr></table><br />      <br />my_sub: # Returns first argument<br />  mov eax,[esp+4]<br />  ret<br /><br />(example when using ebp and two local variables)      <table class="table"><col/><col/><col/><col/><tr><th>click me</th><th>click me</th><th>click me</th><th>click me</th></tr><tr><td>Contents
            </td><td>off ebp
            </td><td>off esp
            </td><td>                    </td></tr><tr><td>caller's variables
            </td><td>[ebp+16]
            </td><td>[esp+24]
            </td><td>                    </td></tr><tr><td>Argument 2
            </td><td>[ebp+12]
            </td><td>[esp+20]
            </td><td>                    </td></tr><tr><td>Argument 1
            </td><td>[ebp+8]
            </td><td>[esp+16]
            </td><td>                    </td></tr><tr><td>Caller Return Address
            </td><td>[ebp+4]
            </td><td>[esp+12]
            </td><td>                    </td></tr><tr><td>Saved ebp
            </td><td>[ebp]
            </td><td>[esp+8]
            </td><td>                    </td></tr><tr><td>Local variable 1
            </td><td>[ebp-4]
            </td><td>[esp+4]
            </td><td>                    </td></tr><tr><td>Local variable 2
            </td><td>[ebp-8]</td><td>[esp]
            </td><td></td></tr></table><br />      <br />my_sub2: # Returns first argument<br />  push ebp  # Prologue<br />  mov ebp, esp<br />  mov eax, [ebp+8]<br />  mov esp, ebp  # Epilogue<br />  pop ebp<br />  ret                          <br /><h2>Constants, Registers, Memory</h2><br />"12" means decimal 12;"0xF0" is hex.  "some_function" is the address of the firstinstruction of a label.<br />Memory access (use register as pointer): "[esp]".  Same as C "*esp".<br />Memory access with offset (use register + offset as pointer): "[esp+4]".  Same as C "*(esp+4)".<br />Memory access with scaled index (register + another register * scale): "[eax + 4*ebx]".  Same as C "*(eax+ebx*4)".<br />      <br />Subroutines are basically just labels.  Here's how you declare labels for the linker:<br />      • "extern some_function;" declares some_function as being outsidethe current file.  You'll get a "symbol undefined" compile errorif you call or jump to a label you never declare.  In C++, be sureto declare the corresponding function as being'extern "C"'!<br />• "global my_function;" exposes the label my_function so it can becalled from outside.  (In MASM, it's "PUBLIC my_function").  Again, your C++prototype better be 'extern "C"'!<br />  <br />      Differences with C:<br />              • "010" means decimal ten in NASM, but *octal* eight in C/C++!   Write octal by ending with letter 'o', like "10o".<br /> <br />        • In NASM, you can write binary constants by ending with the letter 'b', like "mov eax,00101111b;".<br />        • "1+(7&lt;&lt;13)/15" is evaluated at compile time, and it'sa constant.  "3+eax" can't be evaluated in NASM--it's not aconstant.<br />        <br />                        <br /><h2>Registers</h2><br />esp is the stack pointer<br />ebp is the stack frame pointer<br />Return value in eax<br />Arguments are on the stack<br />Free for use (no save needed):<br />   eax, ecx, edx<br />Must be saved:<br />   ebp, esp, esi, edi<br />ebx must be saved in a shared library, but is otherwise free for use.<br />8 bit: ah (high 8 bits) and al (low 8 bits)<br />16 bit: ax<br />32 bit: eax<br />64 bit: rax</div></body></html>