<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Headers</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Headers</h1><br/><strong><h2>DOS Stub </h2></strong><br /><br />The PE format begins with a MS-DOS stub (a header plus executable  code) which makes it a valid MS-DOS executable. The MS-DOS header begins  with the magic code 0x5A4D and is 64 bytes long, followed by real-mode  executable code. The standard stub used almost universally is 128-bytes  long (including header and executable code) and simply outputs "This  program cannot be run in DOS mode." Despite many utilities that with PE  files are hard coded to expect the PE header to start at exactly 128  bytes in, this is incorrect since in some linkers, including Microsoft's  own <a href="https://wiki.osdev.org/Link">Link</a>, it is  possible to replace the MS-DOS stub with one of your own choosing, and  many older programs did this to allow the developer to bundle a MS-DOS  and Windows version into a single file. The correct way is to read a  formerly reserved 4-byte address inside the MS-DOS header located at  0x3C (field commonly known as e_lfanew) which contains the address at  which PE file signature is found, and PE file header follows  immediately. Usually this is a pretty standard value (most of the time  this field is set to 0xE8 by the default link.exe stub). Microsoft  seemingly recommends aligning the PE header on an 8 byte boundary (<a href="http://msdn.microsoft.com/en-us/gg463119.aspx">http://msdn.microsoft.com/en-us/gg463119.aspx</a>, page 10, figure 1). <br /><br /><strong><h2>PE header </h2></strong><br />The PE header contains information that concerns the entire file  rather than individual pieces that will be coming up later. The bare  minimum header contains a 4-byte signature (0x00004550), the machine  type/architecture of the executable code inside, a time stamp, a pointer  to symbols, as well as various flags (is the file an executable, DLL,  can the application handle addresses above 2GB, does the file needed be  copy to the swap file if ran from a removable device, etc). Unless  you're using a really stripped down statically linked PE file to save  memory with a hard coded entry point and no resources, then the PE  header alone isn't enough. <br /><br /><code>// 1 byte aligned<br />struct PeHeader {<br />	uint32_t mMagic; // PE\0\0 or 0x00004550<br />	uint16_t mMachine;<br />	uint16_t mNumberOfSections;<br />	uint32_t mTimeDateStamp;<br />	uint32_t mPointerToSymbolTable;<br />	uint32_t mNumberOfSymbols;<br />	uint16_t mSizeOfOptionalHeader;<br />	uint16_t mCharacteristics;<br />};</code><br /><br /><strong><h3>Optional header </h3></strong><br />The optional PE header follows directly after the standard PE header.  It's size is specified in the PE header which you can also use to tell  if the optional header exists. The optional PE header begins with a  2-byte magic code representing the architecture (0x010B for PE32, 0x020B  for PE64, 0x0107 ROM). This can be used in conjunction with the machine  type to see in the PE header to detect if the PE file is running on a  compatible system. There are a few other useful memory-related variables  including the size and virtual base of the code and data, as well as  the application's version number  (completely user specified, some  update utilities use this to detect if a newer version is available),  entry point, and how many directories there are (see below). <br />Part of the optional header is NT-specific. This include the  subsystem (console, driver, or GUI application), how much stack and heap  space to reserve, and the minimum required Operating System, subsystem  and Windows version. You can use your own values for all of these  depending on the needs of your OS. <br /><br /><code>// 1 byte aligned<br />struct Pe32OptionalHeader {<br />	uint16_t mMagic; // 0x010b - PE32, 0x020b - PE32+ (64 bit)<br />	uint8_t  mMajorLinkerVersion;<br />	uint8_t  mMinorLinkerVersion;<br />	uint32_t mSizeOfCode;<br />	uint32_t mSizeOfInitializedData;<br />	uint32_t mSizeOfUninitializedData;<br />	uint32_t mAddressOfEntryPoint;<br />	uint32_t mBaseOfCode;<br />	uint32_t mBaseOfData;<br />	uint32_t mImageBase;<br />	uint32_t mSectionAlignment;<br />	uint32_t mFileAlignment;<br />	uint16_t mMajorOperatingSystemVersion;<br />	uint16_t mMinorOperatingSystemVersion;<br />	uint16_t mMajorImageVersion;<br />	uint16_t mMinorImageVersion;<br />	uint16_t mMajorSubsystemVersion;<br />	uint16_t mMinorSubsystemVersion;<br />	uint32_t mWin32VersionValue;<br />	uint32_t mSizeOfImage;<br />	uint32_t mSizeOfHeaders;<br />	uint32_t mCheckSum;<br />	uint16_t mSubsystem;<br />	uint16_t mDllCharacteristics;<br />	uint32_t mSizeOfStackReserve;<br />	uint32_t mSizeOfStackCommit;<br />	uint32_t mSizeOfHeapReserve;<br />	uint32_t mSizeOfHeapCommit;<br />	uint32_t mLoaderFlags;<br />	uint32_t mNumberOfRvaAndSizes;<br />};<br /></code><br /><strong><h3>Data Directories </h3></strong><br />While technically part of the optional header and follows directly  after it is a list of entries pointing to data directories. Because the  optional header can vary in size, you only need to pay attention to the  directories that exist and you expect, since it is likely that new data  directories will be added to the PE specification in the future (.Net is  an example of one that was recently added). Each data directory is  referenced as an 8-byte entry in the optional header. The first 4 bytes  is the Relative Virtual Address, or RVA (see Sections below), of the  directory, and the last 4 bytes is the size of the directory. <br />Each data directory that the entries point to have their own  format. Data directories are used to describe import tables for dynamic  linking, a table of resources that are embedded inside of the PE file,  debug information (line numbers and break points), the CLI .Net header. <br /><br /><strong><h2>Sections </h2></strong><br />A PE file is made up of sections which consist of a name, offset  within the file, virtual address to copy to, as well as the size of the  section in the file and in virtual memory (which may differ, in which  case the difference should be cleared 0s), and associated flags. The  sections usually follow universal naming (".text", ".rsrc", etc), but  this can also vary between linker and in some cases can be user-defined,  so it is better to depend on the flags to tell if a section is  executable or writable. However in saying that, if you have custom data  that you wish to embed inside of the executable, then placing it inside  of a section and identifying it by the section's name can be a good idea  since you won't be changing the PE format and your executable will  remain compatible with PE tools. <br />The Relative Virtual Base is a phrase that comes up a lot in PE  documentation. The RVA is the address at where something exists once  it's loaded into memory, rather than an offset into the file. To  calculate the file's address from an RVA without actually loading the  sections into memory, you can use the table of section entries. By using  the virtual address and size of each section you can find which section  the RVA belongs to, then subtract the difference between the section's  virtual address and file offset. <br /><br /><strong><h3>Section header </h3></strong><br /><code>Each section has an entry in section header table. <br />struct IMAGE_SECTION_HEADER { // size 40 bytes<br />	char[8]  mName;<br />	uint32_t mVirtualSize;<br />	uint32_t mVirtualAddress;<br />	uint32_t mSizeOfRawData;<br />	uint32_t mPointerToRawData;<br />	uint32_t mPointerToRealocations;<br />	uint32_t mPointerToLinenumbers;<br />	uint16_t mNumberOfRealocations;<br />	uint16_t mNumberOfLinenumbers;<br />	uint32_t mCharacteristics;<br />};</code><br /><br /><strong><h3>In asm linkage</h3></strong><br />if in nasm you declare a block of code like this: <br /><br /><code>segment .code<br />aAsmFunction:<br />;Do whatever<br />mov BYTE[aData], 0<br />ret<br />segment .data<br />aData: db 0xFF</code><br /><br />The <em>segments</em> will apear as <em>sections</em>. Using this it is possible to keep C and Asm seperate, as a linker will not automatically merge <em>.code</em> and <em>.text</em>, which is the normal output by C compilers. <br /><br /><h3>  Position Independent Code </h3><br />If each section specifies which virtual address to load it in to, you  may be wondering how multiple DLLs can exist in one virtual address  space without conflict. It is true that most code you'll find in a PE  file (DLL or otherwise) is position dependent and linked to a specific  address. However to resolve this issue there exist a structure called a  Relocation Table that is attached to each section entry. The table is  basically a HUGE long list of every address stored in that section so  you can offset it to the location where you loaded the section. <br />Because addresses can point across section borders, relocations  should be done after each section is loaded into memory. Then reiterate  over each section, iterate through each address in the Relocation Table,  find out what section that RVA exists in and add/subtract the offset  between that section's linked virtual address and the section's virtual  address you loaded it into. <br /><br /><h2>  CLI / .Net </h2><br />CLI works alongside the PE format. Rather than being an extension to  the format, it really exists as its own format inside of a format with a  completely different way of storing tables and values. All the .Net  data and headers exist inside of sections that are loaded into memory  (they are loaded into memory since CLI involves heavy language  reflection requiring the metadata without thrashing the disk). The  second reason that the .Net metadata exists inside of the sections  rather than the PE headers is because the PE loader actually has no  concept of .Net at all. (Exception: There is a data directory entry  pointing to the RVA of the CLI header so tools can easily access the  .Net data without loading it into virtual memory.) In fact, I highly  doubt the Windows kernel has any sort of concept of .Net at all. The way  .Net works is by dynamically linking against the .Net runtime  (mscoree.dll), and setting the entry point to a symbol (_CorExeMain)  that resolves to a location inside of mscoree.dll instead of the local  executable. This means that Windows CE, WINE, and ReactOS can all load  .Net assemblies once the .Net framework can be installed without any  specific code. <br /></div></body></html>