<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Modes of operation</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Modes of operation</h1><br/>In cryptography, a block cipher mode of operation is an algorithm that uses a block cipher to provide an information service such as confidentiality or authenticity.[1] A block cipher by itself is only suitable for the secure cryptographic transformation (encryption or decryption) of one fixed-length group of bits called a block.[2] A mode of operation describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.[3][4][5]<br /><br />Most modes require a unique binary sequence, often called an initialization vector (IV), for each encryption operation. The IV has to be non-repeating and, for some modes, random as well. The initialization vector is used to ensure distinct ciphertexts are produced even when the same plaintext is encrypted multiple times independently with the same key.[6] Block ciphers may be capable of operating on more than one block size, but during transformation the block size is always fixed. Block cipher modes operate on whole blocks and require that the last part of the data be padded to a full block if it is smaller than the current block size.[2] There are, however, modes that do not require padding because they effectively use a block cipher as a stream cipher.<br /><br />Historically, encryption modes have been studied extensively in regard to their error propagation properties under various scenarios of data modification. Later development regarded integrity protection as an entirely separate cryptographic goal. Some modern modes of operation combine confidentiality and authenticity in an efficient way, and are known as authenticated encryption modes.[7]<br /><br /><br /><h2>History and standardization</h2><br />The earliest modes of operation, ECB, CBC, OFB, and CFB (see below for all), date back to 1981 and were specified in <a href="http://csrc.nist.gov/publications/fips/fips81/fips81.htm">FIPS 81</a>, <em>DES Modes of Operation</em>. In 2001, the US <a href="https://en.wikipedia.org/wiki/National_Institute_of_Standards_and_Technology">National Institute of Standards and Technology</a> (NIST) revised its list of approved modes of operation by including <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> as a block cipher and adding CTR mode in <a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38a.pdf">SP800-38A</a>, <em>Recommendation for Block Cipher Modes of Operation</em>. Finally, in January, 2010, NIST added <a href="https://en.wikipedia.org/w/index.php?title=XTS-AES&action=edit&redlink=1">XTS-AES</a> in <a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38e.pdf">SP800-38E</a>, <em>Recommendation for Block Cipher Modes of Operation: The XTS-AES Mode for Confidentiality on Storage Devices</em>. Other confidentiality modes exist which have not been approved by NIST. For example, CTS is <a href="https://en.wikipedia.org/wiki/Ciphertext_stealing">ciphertext stealing</a> mode and available in many popular cryptographic libraries.<br />The block cipher modes ECB, CBC, OFB, CFB, CTR, and <a href="https://en.wikipedia.org/wiki/XTS_mode">XTS</a>  provide confidentiality, but they do not protect against accidental  modification or malicious tampering. Modification or tampering can be  detected with a separate <a href="https://en.wikipedia.org/wiki/Message_authentication_code">message authentication code</a> such as <a href="https://en.wikipedia.org/wiki/CBC-MAC">CBC-MAC</a>, or a <a href="https://en.wikipedia.org/wiki/Digital_signature">digital signature</a>.  The cryptographic community recognized the need for dedicated integrity  assurances and NIST responded with HMAC, CMAC, and GMAC. <a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a> was approved in 2002 as <a href="http://csrc.nist.gov/publications/fips/fips198/fips-198a.pdf">FIPS 198</a>, <em>The Keyed-Hash Message Authentication Code (HMAC)</em>, <a href="https://en.wikipedia.org/wiki/CMAC">CMAC</a> was released in 2005 under <a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38b.pdf">SP800-38B</a>, <em>Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication</em>, and <a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">GMAC</a> was formalized in 2007 under <a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf">SP800-38D</a>, <em>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</em>.<br />The cryptographic community observed that compositing (combining) a  confidentiality mode with an authenticity mode could be difficult and  error prone. They therefore began to supply modes which combined  confidentiality and data integrity into a single cryptographic primitive  (an encryption algorithm). These combined modes are referred to as <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated encryption</a>, AE or "authenc". Examples of AE modes are <a href="https://en.wikipedia.org/wiki/CCM_mode">CCM</a> (<a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38c.pdf">SP800-38C</a>), <a href="https://en.wikipedia.org/wiki/GCM_mode">GCM</a> (<a href="http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf">SP800-38D</a>), <a href="https://en.wikipedia.org/wiki/CWC_mode">CWC</a>, <a href="https://en.wikipedia.org/wiki/EAX_mode">EAX</a>, <a href="https://en.wikipedia.org/wiki/IAPM_mode">IAPM</a>, and <a href="https://en.wikipedia.org/wiki/OCB_mode">OCB</a>.<br />Modes of operation are nowadays[<a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items">when?</a>] defined by a number of national and internationally recognized standards bodies. Notable standards organizations include <a href="https://en.wikipedia.org/wiki/NIST">NIST</a>, <a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">ISO</a> (with ISO/IEC 10116<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-ISO-10116-5">[5]</a>), the <a href="https://en.wikipedia.org/wiki/International_Electrotechnical_Commission">IEC</a>, the <a href="https://en.wikipedia.org/wiki/IEEE">IEEE</a>, the national <a href="https://en.wikipedia.org/wiki/ANSI">ANSI</a>, and the <a href="https://en.wikipedia.org/wiki/IETF">IETF</a>.<br /><br /><h2>Initialization vector (IV)</h2><br />Main article: <a href="https://en.wikipedia.org/wiki/Initialization_vector">Initialization vector</a>An initialization vector (IV) or starting variable (SV)<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-ISO-10116-5">[5]</a>  is a block of bits that is used by several modes to randomize the  encryption and hence to produce distinct ciphertexts even if the same  plaintext is encrypted multiple times, without the need for a slower  re-keying process.<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-HUANG-6">[6]</a><br />An initialization vector has different security requirements than a  key, so the IV usually does not need to be secret. However, in most  cases, it is important that an initialization vector is never reused  under the same key. For CBC and CFB, reusing an IV leaks some  information about the first block of plaintext, and about any common  prefix shared by the two messages. For OFB and CTR, reusing an IV  completely destroys security.<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-HUANG-6">[6]</a>  This can be seen because both modes effectively create a bitstream that  is XORed with the plaintext, and this bitstream is dependent on the  password and IV only. Reusing a bitstream destroys security.<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-8">[8]</a>  In CBC mode, the IV must, in addition, be unpredictable at encryption  time; in particular, the (previously) common practice of re-using the  last ciphertext block of a message as the IV for the next message is  insecure (for example, this method was used by SSL 2.0). If an attacker  knows the IV (or the previous block of ciphertext) before he specifies  the next plaintext, he can check his guess about plaintext of some block  that was encrypted with the same key before (this is known as the TLS  CBC IV attack).<a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#cite_note-9">[9]</a><br /><br /><h2>Padding</h2><br />Main article: <a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29">Padding (cryptography)</a>A <a href="https://en.wikipedia.org/wiki/Block_cipher">block cipher</a> works on units of a fixed <a href="https://en.wikipedia.org/wiki/Block_size_%28cryptography%29">size</a> (known as a <em>block size</em>), but messages come in a variety of lengths. So some modes (namely <a href="https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#ECB">ECB</a> and <a href="https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#CBC">CBC</a>) require that the final block be padded before encryption. Several <a href="https://en.wikipedia.org/wiki/Padding_%28cryptography%29">padding</a> schemes exist. The simplest is to add <a href="https://en.wikipedia.org/wiki/Null_character">null bytes</a> to the <a href="https://en.wikipedia.org/wiki/Plaintext">plaintext</a>  to bring its length up to a multiple of the block size, but care must  be taken that the original length of the plaintext can be recovered;  this is trivial, for example, if the plaintext is a <a href="https://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> style <a href="https://en.wikipedia.org/wiki/Literal_string">string</a> which contains no null bytes except at the end. Slightly more complex is the original <a href="https://en.wikipedia.org/wiki/Data_Encryption_Standard">DES</a> method, which is to add a single one <a href="https://en.wikipedia.org/wiki/Bit">bit</a>, followed by enough zero <a href="https://en.wikipedia.org/wiki/Bit">bits</a>  to fill out the block; if the message ends on a block boundary, a whole  padding block will be added. Most sophisticated are CBC-specific  schemes such as <a href="https://en.wikipedia.org/wiki/Ciphertext_stealing">ciphertext stealing</a> or <a href="https://en.wikipedia.org/wiki/Residual_block_termination">residual block termination</a>, which do not cause any extra ciphertext, at the expense of some additional complexity. <a href="https://en.wikipedia.org/wiki/Bruce_Schneier">Schneier</a> and <a href="https://en.wikipedia.org/wiki/Niels_Ferguson">Ferguson</a>  suggest two possibilities, both simple: append a byte with value 128  (hex 80), followed by as many zero bytes as needed to fill the last  block, or pad the last block with <em>n</em> bytes all with value <em>n</em>.<br />CFB, OFB and CTR modes do not require any special measures to handle  messages whose lengths are not multiples of the block size, since the  modes work by <a href="https://en.wikipedia.org/wiki/Exclusive_or">XORing</a>  the plaintext with the output of the block cipher. The last partial  block of plaintext is XORed with the first few bytes of the last <a href="https://en.wikipedia.org/wiki/Keystream">keystream</a>  block, producing a final ciphertext block that is the same size as the  final partial plaintext block. This characteristic of stream ciphers  makes them suitable for applications that require the encrypted  ciphertext data to be the same size as the original plaintext data, and  for applications that transmit data in streaming form where it is  inconvenient to add padding bytes.<br /><br /><h2>Common modes</h2><br />Many  modes of operation have been defined. Some of these are described  below. The purpose of cipher modes is to mask patterns which exist in  encrypted data, as illustrated in the description of the <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB-weakness">weakness of ECB</a>.<br />Different cipher modes mask patterns by cascading outputs from the  cipher block or other globally deterministic variables into the  subsequent cipher block. The inputs of the listed modes are summarized  in the following table:<br /><table class="table"><col/><col/><col/><tr><th>Mode</th><th>Formulas</th><th>Ciphertext</th></tr><tr><td>Electronic Codebook (ECB)</td><td>Yi=F(PlainTexti,Key)</td><td>Yi</td></tr><tr><td>Cipher Block Chaining (CBC)</td><td>Yi=PlainTexti XOR Ciphertexti-1</td><td>F(Y,key); Ciphertext0=IV</td></tr><tr><td>Propagating CBC (PCBC)</td><td>Yi=PlainTexti XOR (Ciphertexti-1 XOR PlainTexti-1)</td><td>F(Y,key);Ciphertext0=IV</td></tr><tr><td>Cipher Feedback (CFB)</td><td>Yi=Ciphertexti-1</td><td>Plaintext XOR F(Y,key);Ciphertext0=IV</td></tr><tr><td>Output Feedback (OFB)</td><td>Yi=F(Key,Ii-1);Y0=IV</td><td>Plaintext XOR Yi</td></tr><tr><td>Counter (CTR)</td><td>Yi=F(Key,IV + g(i) );IV=token();</td><td>Plaintext XOR Yi

</td></tr></table><br />Note: g(i) is any deterministic function, often the <a href="https://en.wikipedia.org/wiki/Identity_function">identity function</a>.<br /><br /><br /><br /><br /></div></body></html>