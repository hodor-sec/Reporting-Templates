<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Overwrite techniques</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Overwrite techniques</h1><br/><strong><h1>SEH overwrites</h1></strong><br /><br />SEH overwrites tend to follow the pattern of having an input field  overwrite its target buffer and overflow beyond the return address  through to the <code>SEH</code> pointers. The <code>SEH</code> pointer is overwritten with an address that contains a <code>POP # POP # RET</code> instruction sequence, and this results in <code>EIP</code> being redirected to the <code>NSEH</code> pointer address. The <code>NSEH</code> pointer address is contained in the <code>4</code> bytes immediately preceding the <code>SEH</code> pointer.<br />In order to exploit an SEH overwrite, the attacker need to execute  shellcode which will perform some kind of operation on the target  machine. It could be a reverse shell, a bind shell or something like a  command execution. Regardless of the payload, it’s almost certain that <code>4</code> bytes is not going to be enough to fit the entire instruction sequence in.<br />So once control has been gained and <code>EIP</code> is pointing to those <code>4</code>  bytes, the first thing that needs to be done is execution needs to move  to an area of memory that is controlled by the attacker via a jump.  Depending on the exploit, the attacker may need to jump forwards or  backwards.<br /><br /><strong>The basic JMP</strong><br /><br />Jumps tend to only require <code>2</code> bytes, and so in the case of SEH overwrites it is common to see the <code>NSEH</code> entry overwritten with a <code>2</code> byte jump followed by <code>NOP</code> instructions to fill the gap. See the image below for a synthetic example:<br /><img src="images/61-1.png" alt="images/61-1.png" /><br />For the sake of discussion we’ll assume that the address at <code>0x77F7F594</code> is the <code>NSEH</code> pointer location and that <code>0x77F7F598</code> is the <code>SEH</code> pointer location. The example shows that <code>NSEH</code> contains a <code>JMP SHORT</code> instruction which moves control forward to the address at <code>0x77F7FC9C</code><br />Once the SEH has been overwritten and the <code>POP # POP # RET</code> sequence has been executed, the <code>JMP</code> instruction is hit and <code>EIP</code> then gets set to the value immediately following the <code>SEH</code>  address. We can assume at this point that the attacker has been able to  control the area of memory immediately following and hence from there  they can perform arbitrary execution.<br /><br /><strong><h3>Bad characters</h3></strong><br />It is easy to see that flaws that allow for SEH overwrites can appear  in any application, and they do! However, some applications only allow a  restricted set of characters to be used for input. As an example, a web  server might be vulnerable to a stack buffer overflow when handling the  URI of a given request. The problem for the attacker is that characters  that are allowed in the URI are very limited. More often than not,  non-printable or extended characters are not allowed in the target  buffer and hence using them will result in behaviour that avoids or  changes the process of exploitation.<br />In the above example we can see that the <code>JMP</code> instruction maps to the bytes <code>EB 06</code>, and <code>EB</code> is a byte that tends not to make web servers very happy. As a result, using this instruction in the <code>NSEH</code>  block isn’t possible. Instead we need to find other jumps which are  bad-character friendly. As a generalisation, if we can stick to  instructions made up of bytes that are lower than <code>7E</code> we can usually get by. This does come with some caveats, such as spaces, newlines or <code>/</code> characters when dealing with web server URIs.<br />So with this constraint in place, how does the attacker perform the simple jump?<br />There are a number of conditional jumps available in the x86  instruction set which could be used, but the problem we have with  conditional jumps is that we have to make sure that the condition is  true before we hit the jump instruction.<br />A well known example is the <code>JA</code> instruction, otherwise known as Jump if above, which has the byte code of <code>77</code>. This instruction will result in a jump if both the <code>CF</code> and <code>ZF</code> flags are <code>0</code>. To prepare for this the attacker can use the extra two bytes to operate on registers and modify flags.<br />In our example we will assume that the carry flag is already zero at  the time of our jump, but the zero flag is unknown. We can force the  zero flag to be <code>0</code> by using the <code>DEC ESP</code> instruction. Here is what it might look like before execution:<br /><img src="images/61-2.png" alt="images/61-2.png" /><br />And after running over the two <code>DEC ESP</code> instructions we see this:<br /><img src="images/61-3.png" alt="images/61-3.png" /><br />As a result the jump is taken and our code continues to execute as we would expect.<br />There are many other ways that this kind of approach can be used with  a mixture of other types of jumps. What I’d like to show now is the way  that I like to do it, which is a little different to the common  examples around the web.<br /><br /><strong><h3>What could go wrong?</h3></strong><br />The approach used above works fine, but isn’t necessarily the best. Why is this?<br />When using <code>JA</code> we have made an assumption that <code>CF</code> will be <code>0</code> all the time when in fact it might not be. If <code>CF</code> is ever <code>1</code>,  then the jump would not be taken. This kind of assumption might apply  regardless of which kind of conditional jump we choose to use.  Guaranteeing the correct combination of flags in a given scenario might not be possible (though admittedly, it usually is).<br />For me personally I also have the problem of being stupid. I don’t  remember all of the combinations of flags required to make a jump work.  While I know I can fall back on reference material I would much prefer  to have an approach that:<br />• Doesn’t rely on forcing a condition prior to taking the jump.<br />• Doesn’t rely on me having to remember or research combinations of flags.<br />• Still fits within the often-required <code>4</code>-byte block.<br />As a result, I use something that I like to call the Jump Net.<br /><br /><strong><h3>The Jump Net</h3></strong><br />The Jump Net isn’t anything revolutionary. It’s not mind-expanding.  It’s not something that I have come up with that hasn’t been thought of  before. However, I feel compelled to write about it because I’m yet to  see anyone talk about it. I haven’t even seen it in any of the exploits  that I’ve read or researched.<br />There’s no doubt that it’s out there and being used by everyone all  the time. But here it is, bloggified in all its simplistic glory.<br />The theory is really simple. We have an unknown state <code>s</code>, this could be a flag for example, and a predicate <code>P</code> which will test <code>s</code> to determine whether or not a jump is made. Those who are savvy with the basics of predicate logic will know that <code>P(s) || ~P(s) == true</code>. That is, any boolean value <code>b</code> logically <code>OR</code>ed with <code>~b</code> will result in a value of <code>true</code>. In our case <code>s</code> is not known (ie. the content of the flag at a given time might not be known), but <code>P</code> is known (ie. we are using <code>JA</code>, or <code>JO</code> for our jump). To determine <code>~P</code>, we can just look for the logical opposite of the jump instruction that we have chosen. For example, the “opposite” of <code>JA</code> is <code>JNA</code> (which is a synonym for <code>JBE</code>, or Jump if below or equal).<br />To make use of this knowledge, we just need to pair up two logically opposing jump conditions and have <code>EIP</code> pass over them. If the first condition succeeds our jump is taken and we win. If not, the second condition must succeed (it’s the inverse of the first after all), and so we still win.<br />Each conditional short jump just happens to have a very similar instruction byte value to its logical opposite. For example, <code>JNA</code> is <code>76</code> and <code>JA</code> is <code>77</code>. So this means that the chances of the characters being bad are slim (but admittedly non-zero).<br />Armed with this knowledge, we can pair up two jumps which when  combined form a “net” of conditions which will always “catch” a  positive/true case and perform the jump. Here’s an example that uses <code>JO</code> and <code>JNO</code>:<br /><img src="images/61-4.png" alt="images/61-4.png" /><br />When <code>EIP</code> is at <code>0x77F7F594</code> a test is performed to see if <code>OF</code> (the overflow flag) is set to <code>0</code>. If it is, then a jump is performed and <code>EIP</code> moves to <code>0x77F7F59C</code> .<br />If the jump is not performed then <code>EIP</code> moves to <code>0x77F7F596</code>, at which point a test is performed to see if <code>OF</code> is set to <code>1</code>. We can conclude that this jump must always happen because we already know that <code>OF</code> wasn’t set to <code>1</code> which caused the previous jump to fail. As a result <code>EIP</code> will move to <code>0x77F7F59C</code>, just as the first jump does.<br />Note how similar the instructions are. If <code>70</code> is a valid byte, there’s a good chance that <code>71</code>  is as well. Admittedly this isn’t always the case, but we do have quite  a few conditional jump pairs to play with, so there’s a good chance  that at least one of them would work.<br /></div></body></html>