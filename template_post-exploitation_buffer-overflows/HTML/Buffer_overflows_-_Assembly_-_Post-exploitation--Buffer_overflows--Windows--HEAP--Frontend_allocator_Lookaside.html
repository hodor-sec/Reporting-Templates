<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Frontend allocator Lookaside</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Frontend allocator Lookaside</h1><br/><strong><h2>The frontend allocator - Lookaside</h2></strong><br /><br />The lookaside list is a singly linked list used to store heap chunks  that are under 1016 bytes (max: 1016+8). The idea behind the lookaside  list is to enable speed and rapid lookup time. This is because  applications execute multiple HeapAlloc()'s and HeapFree()'s during the  processes run-time. Because it was designed for speed and efficiency, it  allows no more than 3 free chunks per list entry. If HeapFree() is  called on a chunk and there are already 3 entries for that particular  chunk size, then it is freed to the Freelist[n].<br /><br /> The heap chunk size is always calculated to the actual size of the  allocation + an additional 8 bytes due to its header. So if the  allocation is made for 16 bytes, then the lookaside list would be  scanned for chunk sizes of 24 bytes (16 + chunk header). In the case of  the below diagram, the windows heap manager would succeed and find an  available chunk at index 2 of the lookaside list.<br /><br /> The lookaside list contains only an flink pointing to the next available chunk (user data).<br /> <br /><table class="table"><col/><col/><col/><col/><col/><col/><col/><tr><th>click me</th><th>click me</th><th>click me</th><th>click me</th><th>click me</th><th>click me</th><th>click me</th></tr><tr><td>Headers</td><td>Self Size (0x2)</td><td>Prev Size (0x2)</td><td>Cookie (0x1)</td><td>Flags (0x1)</td><td>Unused (0x1)</td><td>Segment index (0x1)</td></tr><tr><td>flink/blink</td><td>Flink (0x4)</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Data</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table><br /> <br /> <img src="images/599-1.png" alt="images/599-1.png" /><br /> <br /> <br /> <br />When the windows heap manager gets an allocation request, it looks  for a free chunks of heap memory that can fulfil the request. For  optimization and speed, the windows heap manager will first walk the  lookaside list to begin with (due to its singly linked list structure)  and try to find a free chunk. If the chunk is not found here, the  windows heap manager will try the back-end allocator. This is where the  heap manager will walk the freelist (between freelist[1]-freelist[127]).  If no chunk is found, then it will walk the freelist[0] entry for a  larger chunk and then split the chunk. A portion will be returned to the  heap manager and the rest will return to freelist[n] (n is the index  based on the remaining bytes in size). This brings us to the next  section, heap operations.<br /><br /><br /></div></body></html>