<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.2.9 Fingerprint Web Application (OTG-INFO-009)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.2.9 Fingerprint Web Application (OTG-INFO-009)  </h1><br/><br /><h2>Summary</h2><br />There is nothing new under the sun, and nearly every web application  that one may think of developing has already been developed. With the  vast number of free and open source software projects that are actively  developed and deployed around the world, it is very likely that an  application security test will face a target site that is entirely or  partly dependent on these well known applications (e.g. Wordpress,  phpBB, Mediawiki, etc). Knowing the web application components that are  being tested significantly helps in the testing process and will also  drastically reduce the effort required during the test. These well known  web applications have known HTML headers, cookies, and directory  structures that can be enumerated to identify the application.  <br /><br /> <br /><br /><h2>Test Objectives</h2><br />Identify the web application and version to determine known vulnerabilities and the appropriate exploits to use during testing. <br /><br /> <br /><br /><h2>How to Test</h2><br /><br /><h3>Cookies</h3><br />A relatively reliable way to identify a web application is by the application-specific cookies. <br />Consider the following HTTP-request: <br />GET / HTTP/1.1<br />User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:31.0) Gecko/20100101 Firefox/31.0<br />Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br />Accept-Language: en-US,en;q=0.5<br />'''Cookie: wp-settings-time-1=1406093286; wp-settings-time-2=1405988284'''<br />DNT: 1<br />Connection: keep-alive<br />Host: blog.owasp.org<br />The cookie <em>CAKEPHP</em> has automatically been set, which gives  information about the framework being used. List of common cookies names  is presented in Cpmmon Application Identifiers section. However, it is  possible to change the name of the cookie.  <br /><br /> <br /><br /><h3>HTML source code</h3><br />This technique is based on finding certain patterns in the HTML page  source code. Often one can find a lot of information which helps a  tester to recognize a specific web application. One of the common  markers are HTML comments that directly lead to application disclosure.  More often certain application-specific paths can be found, i.e. links  to application-specific css and/or js folders. Finally, specific script  variables might also point to a certain application. <br />From the meta tag below, one can easily learn the application  used by a website and its version. The comment, specific paths and  script variables can all help an attacker to quickly determine an  instance of an application. <br />&lt;meta name="generator" content="WordPress 3.9.2" /&gt;<br />More frequently such information is placed between  &lt;head&gt;&lt;/head&gt; tags, in &lt;meta&gt; tags or at the end of  the page. Nevertheless, it is recommended to check the whole document  since it can be useful for other purposes such as inspection of other  useful comments and hidden fields.  <br /><br /><h3>Specific files and folders</h3><br />Apart from information gathered from HTML sources, there is another  approach which greatly helps an attacker to determine the application  with high accuracy. Every application has its own specific file and  folder structure on the server. It has been pointed out that one can see  the specific path from the HTML page source but sometimes they are not  explicitly presented there and still reside on the server. <br />In order to uncover them a technique known as dirbusting is used.  Dirbusting is brute forcing a target with predictable folder and file  names and monitoring HTTP-responses to emumerate server contents. This  information can be used both for finding default files and attacking  them, and for fingerprinting the web application. Dirbusting can be done  in several ways, the example below shows a successful dirbusting attack  against a WordPress-powered target with the help of defined list and  intruder functionality of Burp Suite. <br /><img src="images/184-1.png" alt="images/184-1.png" /> <br />We can see that for some WordPress-specific folders (for  instance, /wp-includes/, /wp-admin/ and /wp-content/) HTTP-reponses are  403 (Forbidden), 302 (Found, redirection to wp-login.php) and 200 (OK)  respectively. This is a good indicator that the target is  WordPress-powered. The same way it is possible to dirbust different  application plugin folders and their versions. On the screenshot below  one can see a typical CHANGELOG file of a Drupal plugin, which provides  information on the application being used and discloses a vulnerable  plugin version. <br /><img src="images/184-2.png" alt="images/184-2.png" /> <br />Tip: before starting dirbusting, it is recommended to check the  robots.txt file first. Sometimes application specific folders and other  sensitive information can be found there as well. An example of such a  robots.txt file is presented on a screenshot below. <br /><img src="images/184-3.png" alt="images/184-3.png" /> <br />Specific files and folders are different for each specific  application. It is recommended to install the corresponding application  during penetration tests in order to have better understanding of what  infrastructure is presented and what files might be left on the server.  However, several good file lists already exist and one good example is  FuzzDB wordlists of predictable files/folders (<a href="http://code.google.com/p/fuzzdb/">http://code.google.com/p/fuzzdb/</a>). <br /><br /><h2>Common Application Identifiers</h2><br /><br /><h3>Cookies</h3><br /><table class="table"><col/><col/><tr><th>click me</th><th>click me</th></tr><tr><td> phpBB </td><td> phpbb3_</td></tr><tr><td> Wordpress </td><td> wp-settings</td></tr><tr><td> 1C-Bitrix </td><td> BITRIX_</td></tr><tr><td> AMPcms </td><td> AMP</td></tr><tr><td> Django CMS </td><td> django</td></tr><tr><td> DotNetNuke </td><td> DotNetNukeAnonymous</td></tr><tr><td> e107 </td><td> e107_tz</td></tr><tr><td> EPiServer </td><td> EPiTrace, EPiServer</td></tr><tr><td> Graffiti CMS </td><td> graffitibot</td></tr><tr><td> Hotaru CMS </td><td> hotaru_mobile</td></tr><tr><td> ImpressCMS </td><td> ICMSession</td></tr><tr><td> Indico </td><td> MAKACSESSION</td></tr><tr><td> InstantCMS </td><td> InstantCMS[logdate]</td></tr><tr><td> Kentico CMS </td><td> CMSPreferredCulture</td></tr><tr><td> MODx </td><td> SN4[12symb]</td></tr><tr><td> TYPO3 </td><td> fe_typo_user</td></tr><tr><td> Dynamicweb </td><td> Dynamicweb</td></tr><tr><td> LEPTON </td><td> lep[some_numeric_value]+sessionid</td></tr><tr><td> Wix </td><td> Domain=.wix.com</td></tr><tr><td> VIVVO </td><td> VivvoSessionId</td></tr></table><br /><br /> <br /><br /><h3>HTML source code</h3><br /><table class="table"><col/><col/><tr><th> Application </th><th> Keyword</th></tr><tr><td> Wordpress </td><td> &lt;meta name="generator" content="WordPress 3.9.2" /&gt;</td></tr><tr><td> phpBB </td><td> &lt;body id="phpbb"</td></tr><tr><td> Mediawiki </td><td> &lt;meta name="generator" content="MediaWiki 1.21.9" /&gt;</td></tr><tr><td> Joomla </td><td> &lt;meta name="generator" content="Joomla! - Open Source Content Management" /&gt;</td></tr><tr><td> Drupal </td><td> &lt;meta name="Generator" content="Drupal 7 (http://drupal.org)" /&gt;</td></tr><tr><td> DotNetNuke </td><td> DNN Platform - http://www.dnnsoftware.com</td></tr></table><br />More info <a href="https://www.owasp.org/index.php/Web-metadata">https://www.owasp.org/index.php/Web-metadata</a> <br /><br /><h2>Tools</h2><br />A list of general and well-known tools is presented below. There are  also a lot of other utilities, as well as framework-based fingerprinting  tools. <br /><br /> <br /><br /><h3>WhatWeb</h3><br />Website:  <a href="http://www.morningstarsecurity.com/research/whatweb">http://www.morningstarsecurity.com/research/whatweb</a> <br /> Currently one of the best fingerprinting tools on the market. Included in a default <a href="https://www.owasp.org/index.php?title=Kali_Linux&action=edit&redlink=1">Kali Linux</a> build. Language: Ruby Matches for fingerprinting are made with: <br />•  Text strings (case sensitive)<br />•  Regular expressions<br />•  Google Hack Database queries (limited set of keywords)<br />•  MD5 hashes<br />•  URL recognition<br />•  HTML tag patterns<br />•  Custom ruby code for passive and aggressive operations<br /><br /> Sample output is presented on a screenshot below: <br /><img src="images/184-4.png" alt="images/184-4.png" /> <br /><br /> <br /><br /><h3>BlindElephant</h3><br />Website: <a href="https://community.qualys.com/community/blindelephant">https://community.qualys.com/community/blindelephant</a> <br /> This great tool works on the principle of static file checksum based  version difference thus providing a very high quality of fingerprinting. Language: Python <br />Sample output of a successful fingerprint: <br />pentester$ python BlindElephant.py http://my_target drupal<br />Loaded /Library/Python/2.7/site-packages/blindelephant/dbs/drupal.pkl with 145 versions, 478 differentiating paths, and 434 version groups.<br />Starting BlindElephant fingerprint for version of drupal at http://my_target <br /><br />Hit http://my_target/CHANGELOG.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 527b085a3717bd691d47713dff74acf4 <br /><br />Hit http://my_target/INSTALL.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 14dfc133e4101be6f0ef5c64566da4a4 <br /><br />Hit http://my_target/misc/drupal.js<br />Possible versions based on result: 7.12, 7.13, 7.14<br /><br />Hit http://my_target/MAINTAINERS.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 36b740941a19912f3fdbfcca7caa08ca <br /><br />Hit http://my_target/themes/garland/style.css<br />Possible versions based on result: 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 7.10, 7.11, 7.12, 7.13, 7.14<br /><br />...<br /><br />Fingerprinting resulted in:<br />7.14<br /><br /><br />Best Guess: 7.14<br /><br /> <br /><br /><h3>Wappalyzer</h3><br />Website: <a href="http://wappalyzer.com">http://wappalyzer.com</a> <br /> Wapplyzer is a Firefox Chrome plug-in. It works only on regular  expression matching and doesn't need anything other than the page to be  loaded on browser. It works completely at the browser level and gives  results in the form of icons. Although sometimes it has false positives,  this is very handy to have notion of what technologies were used to  construct a target website immediately after browsing a page. <br /><br /> Sample output of a plug-in is presented on a screenshot below. <br /><img src="images/184-5.png" alt="images/184-5.png" /> <br /><br /> <br /><br /><h2>References</h2><br /><strong>Whitepapers</strong><br /> <br />•  Saumil Shah: "An Introduction to HTTP fingerprinting" - <a href="http://www.net-square.com/httprint_paper.html">http://www.net-square.com/httprint_paper.html</a><br />•  Anant Shrivastava : "Web Application Finger Printing" - <a href="http://anantshri.info/articles/web_app_finger_printing.html">http://anantshri.info/articles/web_app_finger_printing.html</a><br /><br /> <br /><br /><h2>Remediation</h2><br />The general advice is to use several of the tools described above and  check logs to better understand what exactly helps an attacker to  disclose the web framework. By performing multiple scans after changes  have been made to hide framework tracks, it's possible to achieve a  better level of security and to make sure of the framework can not be  detected by automatic scans. Below are some specific recommendations by  framework marker location and some additional interesting approaches. <br /><br /> <br /><br /><h3>HTTP headers</h3><br />Check the configuration and disable or obfuscate all HTTP-headers  that disclose information the technologies used. Here is an interesting  article about HTTP-headers obfuscation using Netscaler: <a href="http://grahamhosking.blogspot.ru/2013/07/obfuscating-http-header-using-netscaler.html">http://grahamhosking.blogspot.ru/2013/07/obfuscating-http-header-using-netscaler.html</a> <br /><br /> <br /><br /><h3>Cookies</h3><br />It is recommended to change cookie names by making changes in the corresponding configuration files. <br /><br /> <br /><br /><h3>HTML source code</h3><br />Manually check the contents of the HTML code and remove everything that explicitly points to the framework. <br />General guidelines: <br />• Make sure there are no visual markers disclosing the framework<br />• Remove any unnecessary comments (copyrights, bug information, specific framework comments)<br />• Remove META and generator tags<br />• Use the companies own css or js files and do not store those in a framework-specific folders<br />• Do not use default scripts on the page or obfuscate them if they must be used. <br /><br /> <br /><br /><h3>Specific files and folders</h3><br />General guidelines: <br />• Remove any unnecessary or unused files on the server. This implies text files disclosing information about versions and installation too.<br />• Restrict access to other files in order to achieve 404-response when accessing them from outside. This can be done, for example, by modifying htaccess file and adding RewriteCond or RewriteRule there. An example of such restriction for two common WordPress folders is presented below.<br />RewriteCond %{REQUEST_URI} /wp-login\.php$ [OR]<br />RewriteCond %{REQUEST_URI} /wp-admin/$<br />RewriteRule $ /http://your_website [R=404,L]<br /><br /> However, these are not the only ways to restrict access. In order to  automate this process, certain framework-specific plugins exist. One  example for WordPress is StealthLogin (<a href="http://wordpress.org/plugins/stealth-login-page">http://wordpress.org/plugins/stealth-login-page</a>). <br /><br /> <br /><br /><h3>Additional approaches</h3><br />General guidelines: <br />• Checksum management The purpose of this approach is to beat checksum-based scanners and not let them disclose files by their hashes. Generally, there are two approaches in checksum management:• Change the location of where those files are placed (i.e. move them to another folder, or rename the existing folder)<br />• Modify the contents - even slight modification results in a completely different hash sum, so adding a single byte in the end of the file should not be a big problem.<br /><br />• Controlled chaosA funny and effective method that involves adding bogus files and folders from other frameworks in order to fool scanners and confuse an attacker. But be careful not to overwrite existing files and folders and to break the current framework!<br /></div></body></html>