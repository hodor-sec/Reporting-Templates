<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.12.11 Test Web Messaging (OTG-CLIENT-011)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.12.11 Test Web Messaging (OTG-CLIENT-011)  </h1><br/><br /><h2>Summary</h2><br />Web Messaging (also known as Cross Document Messaging) allows  applications running on different domains to communicate in a secure  manner. Before the introduction of web messaging the communication of  different origins (between iframes, tabs and windows) was restricted by  the same origin policy and enforced by the browser, however developers  used multiple hacks in order to accomplish these tasks, most of them  were mainly insecure. <br /><br /> This restriction within the browser is in place to restrict a malicious  website to read confidential data from other iframes, tabs, etc, however  there are some legitimate cases where two trusted websites need to  exchange data between each other. To meet this need, Cross Document  Messaging was introduced within the WHATWG HTML5 draft specification and  was implemented in all major browsers. It enables secure communications  between multiple origins across iframes, tabs and windows. <br /><br /> The Messaging API introduced the postMessage() method, with which  plain-text messages can be sent cross-origin. It consists of two  parameters, message and domain. <br /><br /> There are some security concerns when using '*' as the domain that we  discuss below. Then, in order to receive messages the receiving website  needs to add a new event handler, and has the following attributes: <br />• data: The content of the incoming message<br /><br />• origin: The origin of the sender document<br /><br />• source: source window<br /><br /><br /> An example: <br />Send message:<br /><br />iframe1.contentWindow.postMessage(“Hello world”,”http://www.example.com”);<br /><br />Receive message:<br /><br />window.addEventListener(“message”, handler, true);<br />function handler(event) {<br />if(event.origin === 'chat.example.com') {<br />     /* process message (event.data) */<br />} else {<br />    /* ignore messages from untrusted domains */<br />}<br />}<br /><br /> <br /><br /><h3>Origin Security Concept</h3><br />The origin is made up of a scheme, host name and port and identifies  uniquely the domain sending or receiving the message, it does not  include the path or the fragment part of the url. For instance, <a href="https://example.com/">https://example.com/</a> will be considered different from <a href="http://example.com">http://example.com</a>  because the schema in the first case is https and in the second http,  same applies to web servers running in the same domain but different  port. <br /><br /> From a security perspective we should check whether the code is  filtering and processing messages from trusted domains only, normally  the best way to accomplish this is using a whitelist. Also within the  sending domain, we also want to make sure they are explicitly stating  the receiving domain and not '*' as the second argument of postMessage()  as this practice could introduce security concerns too, and could lead  to, in the case of a redirection or if the origin changes by other  means, the website sending data to unknown hosts, and therefore, leaking  confidential data to malicious servers. <br /><br /> In the case the website fails to add security controls to restrict the  domains or origins that are allowed to send messages to a website, it is  most likely that a security risk will be introduced. This makes it a  very interesting part of the code from a penetration testing point of  view. We should scan the code for message event listeners and get the  callback function from the addEventListener method to further analyse,  as domains must always be verified prior to data manipulation. <br /><br /><h3>event.data Input Validation</h3><br />Input validation is also important, even though the website is accepting messages from trusted domains only, it needs to treat the data as external untrusted data and apply  the same level of security controls to it. We should analyze the code and look for insecure methods, in particular if data is being evaluated via eval() or inserted into the DOM via the innerHTML property as that would create a DOM-based XSS vulnerability.<br /><h2>How to Test</h2><br /><br /><h3>Black Box testing</h3><br />Black box testing for vulnerabilities on Web Messaging is not usually  performed since access to the source code is always available as it  needs to be sent to the client to be executed.<br /> <br /><br /> <br /><br /><h3>Gray Box testing</h3><br />Manual testing needs to be conducted and the JavaScript code analyzed  looking for how Web Messaging is implemented. In particular we should  be interested in how the website is restricting messages from untrusted  domain and how the data is handled even for trusted domains. Below are  some examples: <br /><br /> Vulnerable code example: <br />In this example, access is needed for every subdomain (www, chat,  forums, ...) within the owasp.org domain. The code is trying to accept  any domain ending on .owasp.org: <br />window.addEventListener(“message”, callback, true);<br /><br />function callback(e) {<br />     &lt;/b&gt;if(e.origin.indexOf(".owasp.org")!=-1) {&lt;b&gt;<br />          /* process message (e.data) */<br />     }<br />}<br />The intention is to allow subdomains in this form: <br />www.owasp.org<br />chat.owasp.org<br />forums.owasp.org<br />...<br /><br /> Insecure code. An attacker can easily bypass the filter as www.owasp.org.attacker.com will match. <br /><br /> Example of lack of origin check, very insecure as will accept input from any domain: <br />window.addEventListener(“message”, callback, true);<br /><br />function callback(e) {<br />     /* process message (e.data) */<br />}<br /><br /> Input validation example: Lack of security controls lead to Cross-Site Scripting (XSS) <br />window.addEventListener(“message”, callback, true);<br /><br />function callback(e) {<br />     if(e.origin === "trusted.domain.com") {<br />          element.innerHTML= e.data;<br />     }<br />}<br /><br /> This code will lead to Cross-Site Scripting (XSS) vulnerabilities as  data is not being treated properly, a more secure approach would be to  use the property textContent instead of innerHTML. <br /><br /><h2>Tools</h2><br />•  <strong>OWASP Zed Attack Proxy (ZAP)</strong> - <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project</a><br />ZAP is an easy to use integrated penetration testing tool for finding  vulnerabilities in web applications. It is designed to be used by  people with a wide range of security experience and as such is ideal for  developers and functional testers who are new to penetration testing.  ZAP provides automated scanners as well as a set of tools that allow you  to find security vulnerabilities manually. <br /><br /><h2>References</h2><br /><strong>OWASP Resources</strong> <br />• <strong>OWASP HTML5 Security Cheat Sheet</strong>: <a href="https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet">https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet</a><br /><br /> <strong>Whitepapers</strong> <br />• <strong>Web Messaging Specification</strong>: <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html">http://www.whatwg.org/specs/web-apps/current-work/multipage/web-messaging.html</a><br /></div></body></html>