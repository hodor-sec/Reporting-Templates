<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.7.1 Testing for Bypassing Session Management Schema (OTG-SESS-001)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.7.1 Testing for Bypassing Session Management Schema (OTG-SESS-001)  </h1><br/><br /><h2>Summary</h2><br />In order to avoid continuous authentication for each page of a  website or service, web applications implement various mechanisms to  store and validate credentials for a pre-determined timespan. These  mechanisms are known as Session Management and while they are important  in order to increase the ease of use and user-friendliness of the  application, they can be exploited by a penetration tester to gain  access to a user account, without the need to provide correct  credentials.  <br /><br /> In this test, the tester wants to check that cookies and other session  tokens are created in a secure and unpredictable way. An attacker who is  able to predict and forge a weak cookie can easily hijack the sessions  of legitimate users. <br /><br /> Cookies are used to implement session management and are described in detail in <a href="https://tools.ietf.org/html/rfc2965">RFC 2965</a>.  In a nutshell, when a user accesses an application which needs to keep  track of the actions and identity of that user across multiple requests,  a cookie (or cookies) is generated by the server and sent to the  client. The client will then send the cookie back to the server in all  following connections until the cookie expires or is destroyed.  The  data stored in the cookie can provide to the server a large spectrum of  information about who the user is, what actions he has performed so far,  what his preferences are,  etc. therefore providing a state to a  stateless protocol like HTTP. <br /><br /> A typical example is provided by an online shopping cart. Throughout the  session of a user, the application must keep track of his identity, his  profile, the products that he has chosen to buy, the quantity, the  individual prices, the discounts, etc. Cookies are an efficient way to  store and pass this information back and forth (other methods are URL  parameters and hidden fields). <br /><br /> Due to the importance of the data that they store, cookies are therefore  vital in the overall security of the application. Being able to tamper  with cookies may result in hijacking the sessions of legitimate users,  gaining higher privileges in an active session, and in general  influencing the operations of the application in an unauthorized way.  <br />In this test the tester has to check whether the cookies issued  to clients can resist a wide range of attacks aimed to interfere with  the sessions of legitimate users and with the application itself. The  overall goal is to be able to forge a cookie that will be considered  valid by the application and that will provide some kind of unauthorized  access (session hijacking, privilege escalation, ...).  <br /><br /> Usually the main steps of the attack pattern are the following: <br />•  <strong>cookie collection</strong>: collection of a sufficient number of cookie samples;<br />•  <strong>cookie reverse engineering</strong>: analysis of the cookie generation algorithm;<br />•  <strong>cookie manipulation</strong>: forging of a valid cookie in order to perform the attack. This last step might require a large number of attempts, depending on how the cookie is created (cookie brute-force attack).<br /><br /> Another pattern of attack consists of overflowing a cookie. Strictly  speaking, this attack has a different nature, since here testers are not  trying to recreate a perfectly valid cookie. Instead, the goal is to  overflow a memory area, thereby interfering with the correct behavior of  the application and possibly injecting (and remotely executing)  malicious code. <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box Testing and Examples</h3><br />All interaction between the client and application should be tested at least against the following criteria: <br />•  Are all Set-Cookie directives tagged as Secure? <br />•  Do any Cookie operations take place over unencrypted transport? <br />•  Can the Cookie be forced over unencrypted transport?   <br />•  If so, how does the application maintain security? <br />•  Are any Cookies persistent? <br />•  What Expires= times are used on persistent cookies, and are they reasonable? <br />•  Are cookies that are expected to be transient configured as such? <br />•  What HTTP/1.1 Cache-Control settings are used to protect Cookies? <br />•  What HTTP/1.0 Cache-Control settings are used to protect Cookies?<br /><br /> <br /><br /><h3>Cookie collection</h3><br />The first step required to manipulate the cookie is to understand how  the application creates and manages cookies. For this task, testers  have to try to answer the following questions: <br />•  How many cookies are used by the application?<br />Surf the application. Note when cookies are created. Make a list of  received cookies, the page that sets them (with the set-cookie  directive), the domain for which they are valid, their value, and their  characteristics. <br />•  Which parts of the the application generate and/or modify the cookie?<br />Surfing the application, find which cookies remain constant and which get modified. What events modify the cookie? <br />•  Which parts of the application require this cookie in order to be accessed and utilized?<br />Find out which parts of the application need a cookie. Access a page,  then try again without the cookie, or with a modified value of it. Try  to map which cookies are used where. <br /><br /> A spreadsheet mapping each cookie to the corresponding application parts  and the related information can be a valuable output of this phase. <br /><br /> <br /><br /><h3>Session Analysis</h3><br />The session tokens (Cookie, SessionID or Hidden Field) themselves  should be examined to ensure their quality from a security perspective.   They should be tested against criteria such as their randomness,  uniqueness, resistance to statistical and cryptographic analysis and  information leakage.<br /> <br /><br /> <br />•  Token Structure &amp; Information Leakage<br />The first stage is to examine the structure and content of a Session  ID provided by the application.  A common mistake is to include specific  data in the Token instead of issuing a generic value and referencing  real data at the server side. <br /><br /> If the Session ID is clear-text, the structure and pertinent data may be immediately obvious as the following: <br />192.168.100.1:owaspuser:password:15:58<br /><br /> If part or the entire token appears to be encoded or hashed, it should  be compared to various techniques to check for obvious obfuscation. For  example the string “192.168.100.1:owaspuser:password:15:58” is  represented in Hex, Base64 and as an MD5 hash: <br />Hex	3139322E3136382E3130302E313A6F77617370757365723A70617373776F72643A31353A3538<br />Base64	MTkyLjE2OC4xMDAuMTpvd2FzcHVzZXI6cGFzc3dvcmQ6MTU6NTg=<br />MD5	01c2fc4f0a817afd8366689bd29dd40a<br /><br /> Having identified the type of obfuscation, it may be possible to decode  back to the original data.  In most cases, however, this is unlikely.   Even so, it may be useful to enumerate the encoding in place from the  format of the message.  Furthermore, if both the format and obfuscation  technique can be deduced, automated brute-force attacks could be  devised. <br /><br /> Hybrid tokens may include information such as IP address or User ID together with an encoded portion, as the following: <br />owaspuser:192.168.100.1: a7656fafe94dae72b1e1487670148412<br /><br /> Having analyzed a single session token, the representative sample should  be examined. A simple analysis of the tokens should immediately reveal  any obvious patterns.  For example, a 32 bit token may include 16 bits  of static data and 16 bits of variable data.  This may indicate that the  first 16 bits represent a fixed attribute of the user – e.g. the  username or IP address. If the second 16 bit chunk is incrementing at a  regular rate, it may indicate a sequential or even time-based element to  the token generation.  See examples. <br /><br /> If static elements to the Tokens are identified, further samples should  be gathered, varying one potential input element at a time.  For  example, log in attempts through a different user account or from a  different IP address may yield a variance in the previously static  portion of the session token. <br /><br /> The following areas should be addressed during the single and multiple Session ID structure testing: <br />•  What parts of the Session ID are static? <br />•  What clear-text confidential information is stored in the Session ID? E.g. usernames/UID, IP addresses <br />•  What easily decoded confidential information is stored? <br />•  What information can be deduced from the structure of the Session ID? <br />•  What portions of the Session ID are static for the same log in conditions? <br />•  What obvious patterns are present in the Session ID as a whole, or individual portions?<br /><br /> <br /><br /><h3>Session ID Predictability and Randomness</h3><br />Analysis of the variable areas (if any) of the Session ID should be  undertaken to establish the existence of any recognizable or predictable  patterns. These analyses may be performed manually and with bespoke or  OTS statistical or cryptanalytic tools to deduce any patterns in the  Session ID content. Manual checks should include comparisons of Session  IDs issued for the same login conditions – e.g., the same username,  password, and IP address.   <br /><br /> Time is an important factor which must also be controlled.  High numbers  of simultaneous connections should be made in order to gather samples  in the same time window and keep that variable constant.  Even a  quantization of 50ms or less may be too coarse and a sample taken in  this way may reveal time-based components that would otherwise be  missed. <br /><br /> Variable elements should be analyzed over time to determine whether they  are incremental in nature.  Where they are incremental, patterns  relating to absolute or elapsed time should be investigated.  Many  systems use time as a seed for their pseudo-random elements. Where the  patterns are seemingly random, one-way hashes of time or other  environmental variations should be considered as a possibility.   Typically, the result of a cryptographic hash is a decimal or  hexadecimal number so should be identifiable. <br /><br /> In analyzing Session ID sequences, patterns or cycles, static elements  and client dependencies should all be considered as possible  contributing elements to the structure and function of the application. <br />•  Are the Session IDs provably random in nature? Can the resulting values be reproduced?  <br />•  Do the same input conditions produce the same ID on a subsequent run? <br />•  Are the Session IDs provably resistant to statistical or cryptanalysis? <br />•  What elements of the Session IDs are time-linked? <br />•  What portions of the Session IDs are predictable?   <br />•  Can the next ID be deduced, given full knowledge of the generation algorithm and previous IDs?<br /><br /> <br /><br /><h3>Cookie reverse engineering</h3><br />Now that the tester has enumerated the cookies and has a general idea  of their use, it is time to have a deeper look at cookies that seem  interesting. Which cookies is the tester interested in? A cookie, in  order to provide a secure method of session management, must combine  several characteristics, each of which is aimed at protecting the cookie  from a different class of attacks.  <br />These characteristics are summarized below: <br />1. Unpredictability: a cookie must contain some amount of hard-to-guess data. The harder it is to forge a valid cookie, the harder is to break into legitimate user's session. If an attacker can guess the cookie used in an active session of a legitimate user, they will be able to fully impersonate that user (session hijacking). In order to make a cookie unpredictable, random values and/or cryptography can be used.<br />2. Tamper resistance: a cookie must resist malicious attempts of modification. If the tester receives a cookie like  IsAdmin=No, it is trivial to modify it to get administrative rights, unless the application performs a double check (for instance, appending to the cookie an encrypted hash of its value)<br />3. Expiration: a critical cookie must be valid only for an appropriate period of time and must be deleted from the disk or memory afterwards to avoid the risk of being replayed. This does not apply to cookies that store non-critical data that needs to be remembered across sessions (e.g., site look-and-feel).<br />4. “Secure” flag: a cookie whose value is critical for the integrity of the session should have this flag enabled in order to allow its transmission only in an encrypted channel to deter eavesdropping.<br /><br /> The approach here is to collect a sufficient number of instances of a  cookie and start looking for patterns in their value. The exact meaning  of “sufficient” can vary from a handful of samples, if the cookie  generation method is very easy to break, to several thousands, if the  tester needs to proceed with some mathematical analysis (e.g.,  chi-squares, attractors. See later for more information). <br /><br /> It is important to pay particular attention to the workflow of the  application, as the state of a session can have a heavy impact on  collected cookies. A cookie collected before being authenticated can be  very different from a cookie obtained after the authentication. <br /><br /> Another aspect to keep into consideration is time. Always record the  exact time when a cookie has been obtained, when there is the  possibility that time plays a role in the value of the cookie (the  server could use a time stamp as part of the cookie value). The time  recorded could be the local time or the server's time stamp included in  the HTTP response (or both). <br /><br /> When analyzing the collected values, the tester should try to figure out  all variables that could have influenced the cookie value and try to  vary them one at the time. Passing to the server modified versions of  the same cookie can be very helpful in understanding how the application  reads and processes the cookie. <br /><br /> Examples of checks to be performed at this stage include: <br />•  What character set is used in the cookie? Has the cookie a numeric value? alphanumeric? hexadecimal? What happens if the tester inserts in a cookie characters that do not belong to the expected charset?<br />•  Is the cookie composed of different sub-parts carrying different pieces of information? How are the different parts separated? With which delimiters? Some parts of the cookie could have a higher variance, others might be constant, others could assume only a limited set of values. Breaking down the cookie to its base components is the first and fundamental step. <br /><br /> An example of an easy-to-spot structured cookie is the following: <br />ID=5a0acfc7ffeb919:CR=1:TM=1120514521:LM=1120514521:S=j3am5KzC4v01ba3q<br /><br /> This example shows 5 different fields, carrying different types of data: <br />ID – hexadecimal<br />CR – small integer<br />TM and LM – large integer. (And curiously they hold the same value. Worth to see what happens modifying one of them)<br />S – alphanumeric<br /><br /> Even when no delimiters are used, having enough samples can help. As an example, let's look at the following series: <br />0123456789abcdef<br /><br /> <br /><br /><h3>Brute Force Attacks</h3><br />Brute force attacks inevitably lead on from questions relating to  predictability and randomness. The variance within the Session IDs must  be considered together with application session duration and timeouts.   If the variation within the Session IDs is relatively small, and Session  ID validity is long, the likelihood of a successful brute-force attack  is much higher. <br /><br /> A long Session ID (or rather one with a great deal of variance) and a  shorter validity period would make it far harder to succeed in a brute  force attack. <br />•  How long would a brute-force attack on all possible Session IDs take? <br />•  Is the Session ID space large enough to prevent brute forcing? For example, is the length of the key sufficient when compared to the valid life-span?<br />•  Do delays between connection attempts with different Session IDs mitigate the risk of this attack?<br /><br /> <br /><br /><h3>Gray Box testing and example</h3><br />If the tester has access to the session management schema implementation, they can check for the following: <br />•  Random Session Token<br />The Session ID or Cookie issued to the client should not be easily  predictable (don't use linear algorithms based on predictable variables  such as the  client IP address). The use of cryptographic algorithms  with key length of 256 bits is encouraged (like AES). <br />•  Token length<br />Session ID will be at least 50 characters length. <br />•  Session Time-out<br />Session token should have a defined time-out (it depends on the criticality of the application managed data) <br />•  Cookie configuration:•  non-persistent: only RAM memory<br />•  secure (set only on HTTPS channel):  Set Cookie: cookie=data; path=/; domain=.aaa.it; secure<br />•  <a href="https://www.owasp.org/index.php/HTTPOnly">HTTPOnly</a> (not readable by a script):  Set Cookie: cookie=data; path=/; domain=.aaa.it; <a href="https://www.owasp.org/index.php/HTTPOnly">HTTPOnly</a><br /><br /><br /> More information here: <a href="https://www.owasp.org/index.php/Testing_for_cookies_attributes_(OWASP-SM-002)">Testing for cookies attributes</a> <br /><br /> <br /><br /><h2>Tools</h2><br />•  OWASP Zed Attack Proxy Project (ZAP) - <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project</a> - features a session token analysis mechanism.<br />•  Burp Sequencer - <a href="http://www.portswigger.net/suite/sequencer.html">http://www.portswigger.net/suite/sequencer.html</a><br />•  Foundstone CookieDigger - <a href="http://www.mcafee.com/us/downloads/free-tools/cookiedigger.aspx">http://www.mcafee.com/us/downloads/free-tools/cookiedigger.aspx</a><br />•  YEHG's JHijack - <a href="https://www.owasp.org/index.php/JHijack">https://www.owasp.org/index.php/JHijack</a><br /><br /><h2>References</h2><br /><strong>Whitepapers</strong><br /> <br />•  <a href="https://tools.ietf.org/html/rfc2965">RFC 2965</a> “HTTP State Management Mechanism”<br />•  <a href="https://tools.ietf.org/html/rfc1750">RFC 1750</a> “Randomness Recommendations for Security”<br />•  Michal Zalewski: "Strange Attractors and TCP/IP Sequence Number Analysis" (2001): <a href="http://lcamtuf.coredump.cx/oldtcp/tcpseq.html">http://lcamtuf.coredump.cx/oldtcp/tcpseq.html</a><br />•  Michal Zalewski: "Strange Attractors and TCP/IP Sequence Number Analysis - One Year Later" (2002): <a href="http://lcamtuf.coredump.cx/newtcp/">http://lcamtuf.coredump.cx/newtcp/</a><br />•  Correlation Coefficient: <a href="http://mathworld.wolfram.com/CorrelationCoefficient.html">http://mathworld.wolfram.com/CorrelationCoefficient.html</a><br />•  Darrin Barrall: "Automated Cookie Analysis" –  <a href="http://www.spidynamics.com/assets/documents/SPIcookies.pdf">http://www.spidynamics.com/assets/documents/SPIcookies.pdf</a><br />•  ENT: <a href="http://fourmilab.ch/random/">http://fourmilab.ch/random/</a><br />•  <a href="http://seclists.org/lists/fulldisclosure/2005/Jun/0188.html">http://seclists.org/lists/fulldisclosure/2005/Jun/0188.html</a><br />•  Gunter Ollmann: "Web Based Session Management" - <a href="http://www.technicalinfo.net">http://www.technicalinfo.net</a><br />•  Matteo Meucci:"MMS Spoofing" - <a href="http://www.owasp.org/images/7/72/MMS_Spoofing.ppt">http://www.owasp.org/images/7/72/MMS_Spoofing.ppt</a> <br /><br /> <strong>Videos</strong><br /> <br />•  Session Hijacking in Webgoat Lesson - <a href="http://yehg.net/lab/pr0js/training/view/owasp/webgoat/WebGoat_SessionMan_SessionHijackingWithJHijack/">http://yehg.net/lab/pr0js/training/view/owasp/webgoat/WebGoat_SessionMan_SessionHijackingWithJHijack/</a><br /><br /> <br /><br /><h2>Related Security Activities</h2><br /><br /><h3>Description of Session Management Vulnerabilities</h3><br />See the OWASP articles on <a href="https://www.owasp.org/index.php/Category:Session_Management_Vulnerability">Session Management Vulnerabilities</a>. <br /><br /> <br /><br /><h3>Description of Session Management Countermeasures</h3><br />See the OWASP articles on <a href="https://www.owasp.org/index.php/Category:Session_Management">Session Management Countermeasures</a>. <br /><br /> <br /><br /><h3>How to Avoid Session Management Vulnerabilities</h3><br />See the <a href="https://www.owasp.org/index.php/Category:OWASP_Guide_Project">OWASP Development Guide</a> article on how to <a href="https://www.owasp.org/index.php?title=Session_Management&action=edit&redlink=1">Avoid Session Management</a> Vulnerabilities. <br /><br /> <br /><br /><h3>How to Review Code for Session Management| Vulnerabilities</h3><br />See the <a href="https://www.owasp.org/index.php/Category:OWASP_Code_Review_Project">OWASP Code Review Guide</a> article on how to <a href="https://www.owasp.org/index.php/Codereview-Session-Management">Review Code for Session Management</a> Vulnerabilities. <br /></div></body></html>