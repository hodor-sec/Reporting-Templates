<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.10.1 Testing for Weak SSL/TLS Ciphers, Insufficient Transport Layer Protection (OTG-CRYPST-001)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.10.1 Testing for Weak SSL/TLS Ciphers, Insufficient Transport Layer Protection (OTG-CRYPST-001)  </h1><br/><br /><h2>Summary</h2><br />Sensitive data must be protected when it is transmitted through the  network. Such data can include user credentials and credit cards. As a  rule of thumb, if data must be protected when it is stored, it must be  protected also during transmission.  <br /><br /> HTTP is a clear-text protocol and it is normally secured via an SSL/TLS  tunnel, resulting in HTTPS traffic [1]. The use of this protocol ensures  not only confidentiality, but also authentication. Servers are  authenticated using digital certificates and it is also possible to use  client certificate for mutual authentication.  <br /><br /> Even if high grade ciphers are today supported and normally used, some  misconfiguration in the server can be used to force the use of a weak  cipher - or at worst no encryption - permitting to an attacker to gain  access to the supposed secure communication channel. Other  misconfiguration can be used for a Denial of Service attack. <br /><br /> <br /><br /><h2>Common Issues</h2><br />A vulnerability occurs if the HTTP protocol is used to transmit  sensitive information [2] (e.g. credentials transmitted over HTTP [3]). <br />When the SSL/TLS service is present it is good but it increments the attack surface and the following vulnerabilities exist: <br />•  SSL/TLS protocols, ciphers, keys and renegotiation must be properly configured.<br />•  Certificate validity must be ensured.<br />Other vulnerabilities linked to this are: <br />•  Software exposed must be updated due to possibility of known vulnerabilities [4].<br />•  Usage of Secure flag for Session Cookies [5].<br />•  Usage of HTTP Strict Transport Security (HSTS) [6].<br />•  The presence of HTTP and HTTPS both, which can be used to intercept traffic [7], [8].<br />•  The presence of mixed HTTPS and HTTP content in the same page, which can be used to Leak information.<br /><br /> <br /><br /><h3>Sensitive data transmitted in clear-text</h3><br />The application should not transmit sensitive information via  unencrypted channels. Typically it is possible to find basic  authentication over HTTP, input password or session cookie sent via HTTP  and, in general, other information considered by regulations, laws or  organization policy. <br /><br /> <br /><br /><h3>Weak SSL/TLS Ciphers/Protocols/Keys</h3><br />Historically, there have been limitations set in place by the U.S.  government to allow cryptosystems to be exported only for key sizes of  at most 40 bits, a key length which could be broken and would allow the  decryption of communications. Since then cryptographic export  regulations have been relaxed the maximum key size is 128 bits. <br /><br /> It is important to check the SSL configuration being used to avoid  putting in place cryptographic support which could be easily defeated.  To reach this goal SSL-based services should not offer the possibility  to choose weak cipher suite. A cipher suite is specified by an  encryption protocol (e.g. DES, RC4, AES), the encryption key length  (e.g. 40, 56, or 128 bits), and a hash algorithm (e.g. SHA, MD5) used  for integrity checking. <br /><br /> Briefly, the key points for the cipher suite determination are the following:  <br />1.  The client sends to the server a ClientHello message specifying, among other information, the protocol and the cipher suites that it is able to handle. Note that a client is usually a web browser (most popular SSL client nowadays), but not necessarily, since it can be any SSL-enabled application; the same holds for the server, which needs not to be a web server, though this is the most common case [9].<br />2. The server responds with a ServerHello message, containing the chosen protocol and cipher suite that will be used for that session (in general the server selects the strongest protocol and cipher suite supported by both the client and server). <br /><br /> It is possible (for example, by means of configuration directives) to  specify which cipher suites the server will honor. In this way you may  control whether or not conversations with clients will support 40-bit  encryption only. <br />1. The server sends its Certificate message and, if client authentication is required, also sends a CertificateRequest message to the client.<br />2. The server sends a ServerHelloDone message and waits for a client response.<br />3. Upon receipt of the ServerHelloDone message, the client verifies the validity of the server's digital certificate.<br /><br /> <br /><br /><h3>SSL certificate validity – client and server</h3><br />When accessing a web application via the HTTPS protocol, a secure  channel is established between the client and the server. The identity  of one (the server) or both parties (client and server) is then  established by means of digital certificates. So, once the cipher suite  is determined, the “SSL Handshake” continues with the exchange of the  certificates: <br />1.  The server sends its Certificate message and, if client authentication is required, also sends a CertificateRequest message to the client.<br />2.  The server sends a ServerHelloDone message and waits for a client response.<br />3.  Upon receipt of the ServerHelloDone message, the client verifies the validity of the server's digital certificate.<br /><br /> In order for the communication to be set up, a number of checks on the  certificates must be passed. While discussing SSL and certificate based  authentication is beyond the scope of this guide, this section will  focus on the main criteria involved in ascertaining certificate  validity:  <br />•  Checking if the Certificate Authority (CA) is a known one (meaning one considered trusted);<br />•  Checking that the certificate is currently valid;<br />•  Checking that the name of the site and the name reported in the certificate match.<br /><br /> Let's examine each check more in detail.  <br />•  Each browser comes with a pre-loaded list of trusted CAs, against which the certificate signing CA is compared (this list can be customized and expanded at will). During the initial negotiations with an HTTPS server, if the server certificate relates to a CA unknown to the browser, a warning is usually raised. This happens most often because a web application relies on a certificate signed by a self-established CA. Whether this is to be considered a concern depends on several factors. For example, this may be fine for an Intranet environment (think of corporate web email being provided via HTTPS; here, obviously all users recognize the internal CA as a trusted CA). When a service is provided to the general public via the Internet, however (i.e. when it is important to positively verify the identity of the server we are talking to), it is usually imperative to rely on a trusted CA, one which is recognized by all the user base (and here we stop with our considerations; we won’t delve deeper in the implications of the trust model being used by digital certificates). <br /><br /> <br />•  Certificates have an associated period of validity, therefore they may expire. Again, we are warned by the browser about this. A public service needs a temporally valid certificate; otherwise, it means we are talking with a server whose certificate was issued by someone we trust, but has expired without being renewed. <br /><br /> <br />•  What if the name on the certificate and the name of the server do not match? If this happens, it might sound suspicious. For a number of reasons, this is not so rare to see. A system may host a number of name-based virtual hosts, which share the same IP address and are identified by means of the HTTP 1.1 Host: header information. In this case, since the SSL handshake checks the server certificate before the HTTP request is processed, it is not possible to assign different certificates to each virtual server. Therefore, if the name of the site and the name reported in the certificate do not match, we have a condition which is typically signaled by the browser. To avoid this, IP-based virtual servers must be used. [33] and [34] describe techniques to deal with this problem and allow name-based virtual hosts to be correctly referenced. <br /><br /> <br /><br /><h3>Other vulnerabilities</h3><br />The presence of a new service, listening in a separate tcp port may  introduce vulnerabilities such as infrastructure vulnerabilities if the  software is not up to date [4]. Furthermore,  for the correct protection  of data during transmission the Session Cookie must use the Secure flag  [5] and some directives should be sent to the browser to accept only  secure traffic (e.g. HSTS [6], CSP).  <br /><br /> Also there are some attacks that can be used to intercept traffic if the  web server exposes the application on both HTTP and HTTPS [6], [7] or  in case of mixed HTTP and HTTPS resources in the same page. <br /><br /> <br /><br /><h2>How to Test</h2><br /><br /><h3>Testing for sensitive data transmitted in clear-text</h3><br />Various types of information which must be protected can be also  transmitted in clear text. It is possible to check if this information  is transmitted over HTTP instead of HTTPS. Please refer to specific  tests for full details, for credentials [3] and other kind of data [2].    <br /><br /> <br /><br /><h3>Example 1. Basic Authentication over HTTP</h3><br />A typical example is the usage of Basic Authentication over HTTP  because with Basic Authentication, after log in, credentials are encoded  - and not encrypted - into HTTP Headers. <br />$ curl -kis http://example.com/restricted/<br />HTTP/1.1 401 Authorization Required<br />Date: Fri, 01 Aug 2013 00:00:00 GMT<br />WWW-Authenticate: Basic realm="Restricted Area"<br />Accept-Ranges: bytes<br />Vary: Accept-Encoding<br />Content-Length: 162<br />Content-Type: text/html<br /><br />&lt;html&gt;&lt;head&gt;&lt;title&gt;401 Authorization Required&lt;/title&gt;&lt;/head&gt;<br />&lt;body bgcolor=white&gt;<br />&lt;h1&gt;401 Authorization Required&lt;/h1&gt;<br /><br />Invalid login credentials!<br /><br />&lt;/body&gt;&lt;/html&gt;<br /><br /> <br /><br /><h3>Testing for Weak SSL/TLS Ciphers/Protocols/Keys vulnerabilities</h3><br />The large number of available cipher suites and quick progress in cryptanalysis makes testing an SSL server a non-trivial task.  <br />At the time of writing these criteria are widely recognized as minimum checklist: <br />•  Weak ciphers must not be used (e.g. less than 128 bits [10]; no NULL ciphers suite, due to no encryption used; no Anonymous Diffie-Hellmann, due to not provides authentication).<br />•  Weak protocols must be disabled (e.g. SSLv2 must be disabled, due to known weaknesses in protocol design [11]).<br />•  Renegotiation must be properly configured (e.g. Insecure Renegotiation must be disabled, due to MiTM attacks [12] and Client-initiated Renegotiation must be disabled, due to Denial of Service vulnerability [13]).<br />•  No Export (EXP) level cipher suites, due to can be easly broken [10].<br />•  X.509 certificates key length must be strong (e.g. if RSA or DSA is used the key must be at least 1024 bits).<br />•  X.509 certificates must be signed only with secure hashing algoritms (e.g. not signed using MD5 hash, due to known collision attacks on this hash).<br />•  Keys must be generated with proper entropy (e.g, Weak Key Generated with Debian) [14].<br />A more complete checklist includes: <br />•  Secure Renegotiation should be enabled.<br />•  MD5 should not be used, due to known collision attacks. [35]<br />•  RC4 should not be used, due to crypto-analytical attacks [15].<br />•  Server should be protected from BEAST Attack [16].<br />•  Server should be protected from CRIME attack, TLS compression must be disabled [17].<br />•  Server should support Forward Secrecy [18].<br /><br /> The following standards can be used as reference while assessing SSL servers: <br />•  PCI-DSS v2.0 in point 4.1 requires compliant parties to use "strong cryptography" without precisely defining key lengths and algorithms. Common interpretation, partially based on previous versions of the standard, is that at least 128 bit key cipher, no export strength algorithms and no SSLv2 should be used [19].<br />•  Qualsys SSL Labs Server Rating Guide [14], Deployment best practice [10] and SSL Threat Model [20] has been proposed to standardize SSL server assessment and configuration. But is less updated than the SSL Server tool [21].<br />•  OWASP has a lot of resources about SSL/TLS Security [22], [23], [24], [25]. [26].<br /><br /> Some tools and scanners both free (e.g. SSLAudit [28] or SSLScan [29])  and commercial (e.g. Tenable Nessus [27]),  can be used to assess  SSL/TLS vulnerabilities. But due to evolution of these vulnerabilities a  good way to test is to check them manually with openssl [30] or use the  tool’s output as an input for manual evaluation using the references. <br /><br /> Sometimes the SSL/TLS enabled service is not directly accessible and the  tester can access it only via a HTTP proxy using CONNECT method [36].  Most of the tools will try to connect to desired tcp port to start  SSL/TLS handshake. This will not work since desired port is accessible  only via HTTP proxy. The tester can easily circumvent this by using  relaying software such as socat [37]. <br /><br /> <br /><br /><h3>Example 2. SSL service recognition via nmap</h3><br />The first step is to identify ports which have SSL/TLS wrapped  services. Typically tcp ports with SSL for web and mail services are -   but not limited to - 443 (https), 465 (ssmtp), 585 (imap4-ssl), 993  (imaps), 995 (ssl-pop). <br />In this example we search for SSL services using nmap with “-sV”  option, used to identify services and it is also able to identify SSL  services [31]. Other options are for this particular example and must be  customized. Often in a Web Application Penetration Test scope is  limited to port 80 and 443. <br />$ nmap -sV --reason -PN -n --top-ports 100 www.example.com<br />Starting Nmap 6.25 ( http://nmap.org ) at 2013-01-01 00:00 CEST<br />Nmap scan report for www.example.com (127.0.0.1)<br />Host is up, received user-set (0.20s latency).<br />Not shown: 89 filtered ports<br />Reason: 89 no-responses<br />PORT    STATE SERVICE  REASON  VERSION<br />21/tcp  open  ftp      syn-ack Pure-FTPd<br />22/tcp  open  ssh      syn-ack OpenSSH 5.3 (protocol 2.0)<br />25/tcp  open  smtp     syn-ack Exim smtpd 4.80<br />26/tcp  open  smtp     syn-ack Exim smtpd 4.80<br />80/tcp  open  http     syn-ack<br />110/tcp open  pop3     syn-ack Dovecot pop3d<br />143/tcp open  imap     syn-ack Dovecot imapd<br />443/tcp open  ssl/http syn-ack Apache<br />465/tcp open  ssl/smtp syn-ack Exim smtpd 4.80<br />993/tcp open  ssl/imap syn-ack Dovecot imapd<br />995/tcp open  ssl/pop3 syn-ack Dovecot pop3d<br />Service Info: Hosts: example.com<br />Service detection performed. Please report any incorrect results at http://nmap.org/submit/ .<br />Nmap done: 1 IP address (1 host up) scanned in 131.38 seconds<br /><br /> <br /><br /><h3>Example 3. Checking for Certificate information, Weak Ciphers and SSLv2 via nmap</h3><br />Nmap has two scripts for checking Certificate information, Weak Ciphers and SSLv2 [31]. <br />$ nmap --script ssl-cert,ssl-enum-ciphers -p 443,465,993,995 www.example.com<br />Starting Nmap 6.25 ( http://nmap.org ) at 2013-01-01 00:00 CEST<br />Nmap scan report for www.example.com (127.0.0.1)<br />Host is up (0.090s latency).<br />rDNS record for 127.0.0.1: www.example.com<br />PORT    STATE SERVICE<br />443/tcp open  https<br />| ssl-cert: Subject: commonName=www.example.org<br />| Issuer: commonName=*******<br />| Public Key type: rsa<br />| Public Key bits: 1024<br />| Not valid before: 2010-01-23T00:00:00+00:00<br />| Not valid after:  2020-02-28T23:59:59+00:00<br />| MD5:   *******<br />|_SHA-1: *******<br />| ssl-enum-ciphers: <br />|   SSLv3: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|   TLSv1.0: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|_  least strength: strong<br />465/tcp open  smtps<br />| ssl-cert: Subject: commonName=*.exapmple.com<br />| Issuer: commonName=*******<br />| Public Key type: rsa<br />| Public Key bits: 2048<br />| Not valid before: 2010-01-23T00:00:00+00:00<br />| Not valid after:  2020-02-28T23:59:59+00:00<br />| MD5:   *******<br />|_SHA-1: *******<br />| ssl-enum-ciphers: <br />|   SSLv3: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|   TLSv1.0: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|_  least strength: strong<br />993/tcp open  imaps<br />| ssl-cert: Subject: commonName=*.exapmple.com<br />| Issuer: commonName=*******<br />| Public Key type: rsa<br />| Public Key bits: 2048<br />| Not valid before: 2010-01-23T00:00:00+00:00<br />| Not valid after:  2020-02-28T23:59:59+00:00<br />| MD5:   *******<br />|_SHA-1: *******<br />| ssl-enum-ciphers: <br />|   SSLv3: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|   TLSv1.0: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|_  least strength: strong<br />995/tcp open  pop3s<br />| ssl-cert: Subject: commonName=*.exapmple.com<br />| Issuer: commonName=*******<br />| Public Key type: rsa<br />| Public Key bits: 2048<br />| Not valid before: 2010-01-23T00:00:00+00:00<br />| Not valid after:  2020-02-28T23:59:59+00:00<br />| MD5:   *******<br />|_SHA-1: *******<br />| ssl-enum-ciphers: <br />|   SSLv3: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|   TLSv1.0: <br />|     ciphers: <br />|       TLS_RSA_WITH_CAMELLIA_128_CBC_SHA - strong<br />|       TLS_RSA_WITH_CAMELLIA_256_CBC_SHA - strong<br />|       TLS_RSA_WITH_RC4_128_SHA - strong<br />|     compressors: <br />|       NULL<br />|_  least strength: strong<br />Nmap done: 1 IP address (1 host up) scanned in 8.64 seconds<br /><br /> <br /><br /><h3>Example 4 Checking for Client-initiated Renegotiation and Secure Renegotiation via openssl (manually)</h3><br />Openssl [30] can be used for testing manually SSL/TLS. In this  example the tester tries to initiate a renegotiation by client [m]  connecting to server with openssl. The tester then writes the fist line  of an HTTP request and types “R” in a new line. He then waits for  renegotiaion and completion of the HTTP request and checks if secure  renegotiaion is supported by looking at the  server output. Using manual  requests it is also possible to see if Compression is enabled for TLS  and to check for CRIME [13], for ciphers and for other vulnerabilities.  <br />$ openssl s_client -connect www2.example.com:443<br />CONNECTED(00000003)<br />depth=2 ******<br />verify error:num=20:unable to get local issuer certificate<br />verify return:0<br />---<br />Certificate chain<br /> 0 s:******<br />   i:******<br /> 1 s:******<br />   i:******<br /> 2 s:******<br />   i:******<br />---<br />Server certificate<br />-----BEGIN CERTIFICATE-----<br />******<br />-----END CERTIFICATE-----<br />subject=******<br />issuer=******<br />---<br />No client certificate CA names sent<br />---<br />SSL handshake has read 3558 bytes and written 640 bytes<br />---<br />New, TLSv1/SSLv3, Cipher is DES-CBC3-SHA<br />Server public key is 2048 bit<br />Secure Renegotiation IS NOT supported<br />Compression: NONE<br />Expansion: NONE<br />SSL-Session:<br />    Protocol  : TLSv1<br />    Cipher    : DES-CBC3-SHA<br />    Session-ID: ******<br />    Session-ID-ctx: <br />    Master-Key: ******<br />    Key-Arg   : None<br />    PSK identity: None<br />    PSK identity hint: None<br />    SRP username: None<br />    Start Time: ******<br />    Timeout   : 300 (sec)<br />    Verify return code: 20 (unable to get local issuer certificate)<br />---<br /><br /> Now the tester can write the first line of an HTTP request and then R in a new line. <br />HEAD / HTTP/1.1<br />R<br />Server is renegotiating <br />RENEGOTIATING<br />depth=2 C******<br />verify error:num=20:unable to get local issuer certificate<br />verify return:0<br />And the tester can complete our request, checking for response. <br />HEAD / HTTP/1.1<br /><br />HTTP/1.1 403 Forbidden ( The server denies the specified Uniform Resource Locator (URL). Contact the server administrator.  )<br />Connection: close<br />Pragma: no-cache<br />Cache-Control: no-cache<br />Content-Type: text/html<br />Content-Length: 1792  <br /><br />read:errno=0<br />Even if the HEAD is not permitted, Client-intiated renegotiaion is permitted. <br /><br /> <br /><br /><h3>Example 5. Testing supported Cipher Suites, BEAST and CRIME attacks via TestSSLServer</h3><br />TestSSLServer [32] is a script which permits the tester to check the  cipher suite and also for BEAST and CRIME attacks. BEAST (Browser  Exploit Against SSL/TLS)  exploits a vulnerability of CBC in TLS 1.0.  CRIME (Compression Ratio Info-leak Made Easy) exploits a vulnerability  of TLS Compression, that should be disabled. What is interesting is that  the first fix for BEAST was the use of RC4, but this is now discouraged  due to a crypto-analytical attack to RC4 [15]. <br /><br /> An online tool to check for these attacks is SSL Labs, but can be used  only for internet facing servers. Also consider that target data will be  stored on SSL Labs server and also will result some connection from SSL  Labs server [21]. <br />$ java -jar TestSSLServer.jar www3.example.com 443<br />Supported versions: SSLv3 TLSv1.0 TLSv1.1 TLSv1.2<br />Deflate compression: no<br />Supported cipher suites (ORDER IS NOT SIGNIFICANT):<br />  SSLv3<br />     RSA_WITH_RC4_128_SHA<br />     RSA_WITH_3DES_EDE_CBC_SHA<br />     DHE_RSA_WITH_3DES_EDE_CBC_SHA<br />     RSA_WITH_AES_128_CBC_SHA<br />     DHE_RSA_WITH_AES_128_CBC_SHA<br />     RSA_WITH_AES_256_CBC_SHA<br />     DHE_RSA_WITH_AES_256_CBC_SHA<br />     RSA_WITH_CAMELLIA_128_CBC_SHA<br />     DHE_RSA_WITH_CAMELLIA_128_CBC_SHA<br />     RSA_WITH_CAMELLIA_256_CBC_SHA<br />     DHE_RSA_WITH_CAMELLIA_256_CBC_SHA<br />     TLS_RSA_WITH_SEED_CBC_SHA<br />     TLS_DHE_RSA_WITH_SEED_CBC_SHA<br />  (TLSv1.0: idem)<br />  (TLSv1.1: idem)<br />  TLSv1.2<br />     RSA_WITH_RC4_128_SHA<br />     RSA_WITH_3DES_EDE_CBC_SHA<br />     DHE_RSA_WITH_3DES_EDE_CBC_SHA<br />     RSA_WITH_AES_128_CBC_SHA<br />     DHE_RSA_WITH_AES_128_CBC_SHA<br />     RSA_WITH_AES_256_CBC_SHA<br />     DHE_RSA_WITH_AES_256_CBC_SHA<br />     RSA_WITH_AES_128_CBC_SHA256<br />     RSA_WITH_AES_256_CBC_SHA256<br />     RSA_WITH_CAMELLIA_128_CBC_SHA<br />     DHE_RSA_WITH_CAMELLIA_128_CBC_SHA<br />     DHE_RSA_WITH_AES_128_CBC_SHA256<br />     DHE_RSA_WITH_AES_256_CBC_SHA256<br />     RSA_WITH_CAMELLIA_256_CBC_SHA<br />     DHE_RSA_WITH_CAMELLIA_256_CBC_SHA<br />     TLS_RSA_WITH_SEED_CBC_SHA<br />     TLS_DHE_RSA_WITH_SEED_CBC_SHA<br />     TLS_RSA_WITH_AES_128_GCM_SHA256<br />     TLS_RSA_WITH_AES_256_GCM_SHA384<br />     TLS_DHE_RSA_WITH_AES_128_GCM_SHA256<br />     TLS_DHE_RSA_WITH_AES_256_GCM_SHA384<br />----------------------<br />Server certificate(s):<br />  ******<br />----------------------<br />Minimal encryption strength:     strong encryption (96-bit or more)<br />Achievable encryption strength:  strong encryption (96-bit or more)<br />BEAST status: vulnerable<br />CRIME status: protected<br /><br /><br /> <br /><br /><h3>Example 6.  Testing SSL/TLS vulnerabilities with sslyze</h3><br />Sslyze [33] is a python script which permits mass scanning and XML  output. The following is an example of a regular scan. It is one of the  most complete and versatile tools for SSL/TLS testing. <br />./sslyze.py --regular example.com:443<br /><br /> REGISTERING AVAILABLE PLUGINS<br /> -----------------------------<br /><br />  PluginHSTS<br />  PluginSessionRenegotiation<br />  PluginCertInfo<br />  PluginSessionResumption<br />  PluginOpenSSLCipherSuites<br />  PluginCompression<br /><br /><br /><br /> CHECKING HOST(S) AVAILABILITY<br /> -----------------------------<br /><br />  example.com:443                      =&gt; 127.0.0.1:443<br /><br /><br /><br /> SCAN RESULTS FOR EXAMPLE.COM:443 - 127.0.0.1:443<br /> ---------------------------------------------------<br /><br />  * Compression :<br />        Compression Support:      Disabled<br /><br />  * Session Renegotiation :<br />      Client-initiated Renegotiations:    Rejected<br />      Secure Renegotiation:               Supported<br /><br />  * Certificate :<br />      Validation w/ Mozilla's CA Store:  Certificate is NOT Trusted: unable to get local issuer certificate<br />      Hostname Validation:               MISMATCH                           <br />      SHA1 Fingerprint:                  ******<br /><br />      Common Name:                       www.example.com                     <br />      Issuer:                            ******<br />      Serial Number:                     ****                               <br />      Not Before:                        Sep 26 00:00:00 2010 GMT           <br />      Not After:                         Sep 26 23:59:59 2020 GMT   <br />       <br />      Signature Algorithm:               sha1WithRSAEncryption              <br />      Key Size:                          1024 bit                           <br />      X509v3 Subject Alternative Name:   {'othername': ['&lt;unsupported&gt;'], 'DNS': ['www.example.com']}<br /><br />  * OCSP Stapling :<br />      Server did not send back an OCSP response.                                   <br /><br />  * Session Resumption :<br />      With Session IDs:           Supported (5 successful, 0 failed, 0 errors, 5 total attempts).<br />      With TLS Session Tickets:   Supported<br /><br />  * SSLV2 Cipher Suites :<br /><br />      Rejected Cipher Suite(s): Hidden <br /><br />      Preferred Cipher Suite: None     <br /><br />      Accepted Cipher Suite(s): None   <br /><br />      Undefined - An unexpected error happened: None <br /><br />  * SSLV3 Cipher Suites :<br /><br />      Rejected Cipher Suite(s): Hidden <br /><br />      Preferred Cipher Suite:          <br />        RC4-SHA                       128 bits      HTTP 200 OK                        <br /><br />      Accepted Cipher Suite(s):        <br />        CAMELLIA256-SHA               256 bits      HTTP 200 OK                        <br />        RC4-SHA                       128 bits      HTTP 200 OK                        <br />        CAMELLIA128-SHA               128 bits      HTTP 200 OK                        <br /><br />      Undefined - An unexpected error happened: None <br /><br />  * TLSV1_1 Cipher Suites :<br /><br />      Rejected Cipher Suite(s): Hidden <br /><br />      Preferred Cipher Suite: None     <br /><br />      Accepted Cipher Suite(s): None   <br /><br />      Undefined - An unexpected error happened: <br />        ECDH-RSA-AES256-SHA             socket.timeout - timed out         <br />        ECDH-ECDSA-AES256-SHA           socket.timeout - timed out         <br /><br />  * TLSV1_2 Cipher Suites :<br /><br />      Rejected Cipher Suite(s): Hidden <br /><br />      Preferred Cipher Suite: None     <br /><br />      Accepted Cipher Suite(s): None   <br /><br />      Undefined - An unexpected error happened: <br />        ECDH-RSA-AES256-GCM-SHA384      socket.timeout - timed out         <br />        ECDH-ECDSA-AES256-GCM-SHA384    socket.timeout - timed out         <br /><br />  * TLSV1 Cipher Suites :<br /><br />      Rejected Cipher Suite(s): Hidden <br /><br />      Preferred Cipher Suite:          <br />        RC4-SHA                       128 bits      Timeout on HTTP GET                <br /><br />      Accepted Cipher Suite(s):        <br />        CAMELLIA256-SHA               256 bits      HTTP 200 OK                        <br />        RC4-SHA                       128 bits      HTTP 200 OK                        <br />        CAMELLIA128-SHA               128 bits      HTTP 200 OK                        <br /><br />      Undefined - An unexpected error happened: <br />        ADH-CAMELLIA256-SHA             socket.timeout - timed out         <br /><br /><br /><br /> SCAN COMPLETED IN 9.68 S<br /> ------------------------<br /><br /> <br /><br /><h3>Example 7.  Testing SSL/TLS with testssl.sh</h3><br />Testssl.sh [38] is a Linux shell script which provides clear output  to facilitate good decision making. It can not only check web servers  but also services on other ports, supports STARTTLS, SNI, SPDY and does a  few check on the HTTP header as well.  <br /><br /> It's a very easy to use tool. Here's some sample output (without colors): <br />user@myhost: % testssl.sh owasp.org      <br /><br />########################################################<br />testssl.sh v2.0rc3  (https://testssl.sh)<br />($Id: testssl.sh,v 1.97 2014/04/15 21:54:29 dirkw Exp $)<br /><br />   This program is free software. Redistribution + <br />   modification under GPLv2 is permitted. <br />   USAGE w/o ANY WARRANTY. USE IT AT YOUR OWN RISK!<br /><br /> Note you can only check the server against what is<br /> available (ciphers/protocols) locally on your machine<br />########################################################<br /><br />Using "OpenSSL 1.0.2-beta1 24 Feb 2014" on<br />      "myhost:/&lt;mypath&gt;/bin/openssl64"<br /><br /><br />Testing now (2014-04-17 15:06) ---&gt; owasp.org:443 &lt;---<br />("owasp.org" resolves to "192.237.166.62 / 2001:4801:7821:77:cd2c:d9de:ff10:170e") <br /><br /><br />--&gt; Testing Protocols<br /> <br /> SSLv2     NOT offered (ok) <br /> SSLv3     offered <br /> TLSv1     offered (ok) <br /> TLSv1.1   offered (ok) <br /> TLSv1.2   offered (ok) <br /><br /> SPDY/NPN  not offered<br /><br />--&gt; Testing standard cipher lists<br /> <br /> Null Cipher              NOT offered (ok) <br /> Anonymous NULL Cipher    NOT offered (ok) <br /> Anonymous DH Cipher      NOT offered (ok) <br /> 40 Bit encryption        NOT offered (ok) <br /> 56 Bit encryption        NOT offered (ok) <br /> Export Cipher (general)  NOT offered (ok) <br /> Low (&lt;=64 Bit)           NOT offered (ok) <br /> DES Cipher               NOT offered (ok) <br /> Triple DES Cipher        offered<br /> Medium grade encryption  offered<br /> High grade encryption    offered (ok) <br /><br />--&gt; Testing server defaults (Server Hello)<br /> <br /> Negotiated protocol       TLSv1.2 <br /> Negotiated cipher         AES128-GCM-SHA256 <br /> <br /> Server key size           2048 bit<br /> TLS server extensions:    server name, renegotiation info, session ticket, heartbeat<br /> Session Tickets RFC 5077  300 seconds<br /><br />--&gt; Testing specific vulnerabilities<br /> <br /> Heartbleed (CVE-2014-0160), experimental  NOT vulnerable (ok) <br /> Renegotiation (CVE 2009-3555)             NOT vulnerable (ok) <br /> CRIME, TLS (CVE-2012-4929)                NOT vulnerable (ok)  <br /><br />--&gt; Checking RC4 Ciphers <br /><br />RC4 seems generally available. Now testing specific ciphers...<br /> <br /> Hexcode    Cipher Name                   KeyExch.  Encryption Bits<br />--------------------------------------------------------------------<br /> [0x05]     RC4-SHA                       RSA         RC4      128<br /><br />RC4 is kind of broken, for e.g. IE6 consider 0x13 or 0x0a<br /><br />--&gt; Testing HTTP Header response <br /> <br /> HSTS        no <br /> Server      Apache<br /> Application (None)<br /> <br />--&gt; Testing (Perfect) Forward Secrecy  (P)FS) <br /><br />no PFS available <br /><br />Done now (2014-04-17 15:07) ---&gt; owasp.org:443 &lt;---<br /><br />user@myhost: %    <br /><br /><br /><br /> STARTTLS would be tested via <code>testssl.sh -t smtp.gmail.com:587  smtp</code>, each ciphers with <code>testssl -e &lt;target&gt;</code>, each ciphers per protocol with <code>testssl -E &lt;target&gt;</code>. To just display what local ciphers that are installed for openssl see <code>testssl -V</code>. For a thorough check it is best to dump the supplied OpenSSL binaries in the path or the one of testssl.sh. <br /><br /> The interesting thing is if a tester looks at the sources they learn how  features are tested, see e.g. Example 4. What is even better is that it  does the whole handshake for heartbleed in pure /bin/bash with /dev/tcp  sockets -- no piggyback perl/python/you name it.  <br /><br /> Additionally it provides a prototype (via "testssl.sh -V") of mapping to  RFC cipher suite names to OpenSSL ones. The tester needs the file  mapping-rfc.txt in same directory. <br /><br /> <br /><br /><h3>Example 8.  Testing O-Saft - OWASP SSL advanced forensic tool</h3><br />This tool [39] is most comprehensive SSL tests. It supports the following checks: <br />1. BEAST  <br />2. BREACH<br />3. CRIME<br />4. FREAK<br />5. HeartBleed<br />6. TIME<br />7. PFS: Forward Secrecy support<br />8. HSTS: Check for implementation of HSTS header<br />9. SNI support<br />10. Certificate: Host-name mismatch<br />11. Certificate expiration<br />12. Certificate extension<br />13. Weak/Insecure Hashing Algorithm (MD2, MD4, MD5, SHA1)<br />14. SSLv2, SSLv3 support<br />15. Weak ciphers check (Low, Anon, Null, Export)<br />16. RC4 support<br />17. Checks any cipher independent of SSL libriray<br />18. supports proxy connections<br />19. supported protokols: HTTPS, SMTP, POP3, IMAP, LDAP, RDP, XMPP, IRC<br /><br /><h3>Testing SSL certificate validity – client and server</h3><br />Firstly upgrade the browser because CA certs expire and in every  release of the browser these are renewed. Examine the validity of the  certificates used by the application. Browsers will issue a warning when  encountering expired certificates, certificates issued by untrusted  CAs, and certificates which do not match name wise with the site to  which they should refer.  <br /><br /> By clicking on the padlock that appears in the browser window when  visiting an HTTPS site, testers can look at information related to the  certificate – including the issuer, period of validity, encryption  characteristics, etc. If the application requires a client certificate,  that tester has probably installed one to access it. Certificate  information is available in the browser by inspecting the relevant  certificate(s) in the list of the installed certificates.  <br /><br /> These checks must be applied to all visible SSL-wrapped communication  channels used by the application. Though this is the usual https service  running on port 443, there may be additional services involved  depending on the web application architecture and on deployment issues  (an HTTPS administrative port left open, HTTPS services on non-standard  ports, etc.). Therefore, apply these checks to all SSL-wrapped ports  which have been discovered. For example, the nmap scanner features a  scanning mode (enabled by the –sV command line switch) which identifies  SSL-wrapped services. The Nessus vulnerability scanner has the  capability of performing SSL checks on all SSL/TLS-wrapped services.  <br /><br /> <br /><br /><h3>Example 1. Testing for certificate validity (manually)</h3><br />Rather than providing a fictitious example, this guide includes an  anonymized real-life example to stress how frequently one stumbles on  https sites whose certificates are inaccurate with respect to naming.  The following screenshots refer to a regional site of a high-profile IT  company.  <br />We are visiting a .it site and the certificate was issued to a  .com site. Internet Explorer warns that the name on the certificate does  not match the name of the site.  <br /><img src="images/62-1.png" alt="images/62-1.png" /> <br /><em>Warning issued by Microsoft Internet Explorer</em> <br />The message issued by Firefox is different. Firefox complains  because it cannot ascertain the identity of the .com site the  certificate refers to because it does not know the CA which signed the  certificate. In fact, Internet Explorer and Firefox do not come  pre-loaded with the same list of CAs. Therefore, the behavior  experienced with various browsers may differ. <br /><img src="images/62-2.png" alt="images/62-2.png" /> <br /><em>Warning issued by Mozilla Firefox</em> <br /><br /><h3>Testing for other vulnerabilities</h3><br />As mentioned previously, there are other types of vulnerabilities  that are not related with the SSL/TLS protocol used, the cipher suites  or Certificates. Apart from other vulnerabilities discussed in other  parts of this guide, a vulnerability exists  when the server provides  the website both with the HTTP and HTTPS protocols, and permits an  attacker to force a victim into using a non-secure channel instead of a  secure one. <br /><br /> <br /><br /><h3>Surf Jacking</h3><br />The Surf Jacking attack [7] was first presented by Sandro Gauci and  permits to an attacker to hijack an HTTP session even when the victim’s  connection is encrypted using SSL or TLS. <br /><br /> The following is a scenario of how the attack can take place: <br />•  Victim logs into the secure website at <a href="https://somesecuresite/">https://somesecuresite/</a>.<br />•  The secure site issues a session cookie as the client logs in.<br />•  While logged in, the victim opens a new browser window and goes to http:// examplesite/<br />•  An attacker sitting on the same network is able to see the clear text traffic to <a href="http://examplesite">http://examplesite</a>.<br />•  The attacker sends back a "301 Moved Permanently" in response to the clear text traffic to <a href="http://examplesite">http://examplesite</a>. The response contains the header “Location: <a href="http://somesecuresite">http://somesecuresite</a> /”, which makes it appear that examplesite is sending the web browser to somesecuresite. Notice that the URL scheme is HTTP not HTTPS.<br />•  The victim's browser starts a new clear text connection to <a href="http://somesecuresite/">http://somesecuresite/</a> and sends an HTTP request containing the cookie in the HTTP header in clear text<br />•  The attacker sees this traffic and logs the cookie for later use.<br /><br /> To test if a website is vulnerable carry out the following tests: <br />1.  Check if website supports both HTTP and HTTPS protocols<br />2.  Check if cookies do not have the “Secure” flag<br /><br /> <br /><br /><h3>SSL Strip</h3><br />Some applications supports both HTTP and HTTPS, either for usability  or so users can type both addresses and get to the site. Often users go  into an HTTPS website from link or a redirect. Typically personal  banking sites have a similar configuration with an iframed log in or a  form with action attribute over HTTPS but the page under HTTP. <br /><br /> An attacker in a privileged position - as described in SSL strip [8] -  can intercept traffic when the user is in the http site and manipulate  it to get a Man-In-The-Middle attack under HTTPS. An application is  vulnerable if it supports both HTTP and HTTPS. <br /><br /> <br /><br /><h3>Testing via HTTP proxy</h3><br />Inside corporate environments testers can see services that are not  directly accessible and they can access them only via HTTP proxy using  the CONNECT method [36]. Most of the tools will not work in this  scenario because they try to connect to the desired tcp port to start  the SSL/TLS handshake. With the help of relaying software such as socat  [37] testers can enable those tools for use with services behind an HTTP  proxy. <br /><br /> <br /><br /><h3>Example 8. Testing via HTTP proxy</h3><br />To connect to destined.application.lan:443 via proxy 10.13.37.100:3128 run socat as follows: <br />$ socat TCP-LISTEN:9999,reuseaddr,fork PROXY:10.13.37.100:destined.application.lan:443,proxyport=3128<br /><br /> Then the tester can target all other tools to localhost:9999: <br />$ openssl s_client -connect localhost:9999<br /><br /> All connections to localhost:9999 will be effectively relayed by socat via proxy to destined.application.lan:443. <br /><br /> <br /><br /><h2>Configuration Review</h2><br /><br /><h3>Testing for Weak SSL/TLS Cipher Suites</h3><br />Check the configuration of the web servers that provide https  services. If the web application provides other SSL/TLS wrapped  services, these should be checked as well.  <br /><br /> <br /><br /><h3>Example 9. Windows Server</h3><br />Check the configuration on a Microsoft Windows Server (2000, 2003 and 2008) using the registry key: <br />HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\that has some sub-keys including Ciphers, Protocols and KeyExchangeAlgorithms. <br /><br /> <br /><br /><h3>Example 10: Apache</h3><br />To check the cipher suites and protocols supported by the Apache2 web  server, open the ssl.conf file and search for the SSLCipherSuite,  SSLProtocol, SSLHonorCipherOrder,SSLInsecureRenegotiation and  SSLCompression directives. <br /><br /> <br /><br /><h3>Testing SSL certificate validity – client and server</h3><br />Examine the validity of the certificates used by the application at  both server and client levels. The usage of certificates is primarily at  the web server level, however, there may be additional communication  paths protected by SSL (for example, towards the DBMS). Testers should  check the application architecture to identify all SSL protected  channels. <br /><br /><h2>Tools</h2><br />• [21][Qualsys SSL Labs - SSL Server Test|<a href="https://www.ssllabs.com/ssltest/index.html">https://www.ssllabs.com/ssltest/index.html</a>]: internet-facing scanner<br />• [27] [Tenable - Nessus Vulnerability Scanner|<a href="http://www.tenable.com/products/nessus">http://www.tenable.com/products/nessus</a>]: includes some plugins to test different SSL related vulnerabilities, Certificates and the presence of HTTP Basic authentication without SSL.<br />• [32] [TestSSLServer|<a href="http://www.bolet.org/TestSSLServer/">http://www.bolet.org/TestSSLServer/</a>]: a java scanner - and also windows executable - includes tests for cipher suites, CRIME and BEAST<br />• [33] [sslyze|<a href="https://github.com/iSECPartners/sslyze">https://github.com/iSECPartners/sslyze</a>]: is a python script to check vulnerabilities in SSL/TLS.<br />• [28] [SSLAudit|<a href="https://code.google.com/p/sslaudit/">https://code.google.com/p/sslaudit/</a>]: a perl script/windows executable scanner which follows Qualys SSL Labs Rating Guide.<br />• [29] [SSLScan|<a href="http://sourceforge.net/projects/sslscan/">http://sourceforge.net/projects/sslscan/</a>] with [SSL Tests|<a href="http://www.pentesterscripting.com/discovery/ssl_tests">http://www.pentesterscripting.com/discovery/ssl_tests</a>]: a SSL Scanner and a wrapper in order to enumerate SSL vulnerabilities.<br />• [31] [nmap|<a href="http://nmap.org/">http://nmap.org/</a>]: can be used primary to identify SSL-based services and then to check Certificate and SSL/TLS vulnerabilities. In particular it has some scripts to check [Certificate and SSLv2|<a href="http://nmap.org/nsedoc/scripts/ssl-cert.html">http://nmap.org/nsedoc/scripts/ssl-cert.html</a>] and supported [SSL/TLS protocols/ciphers|<a href="http://nmap.org/nsedoc/scripts/ssl-enum-ciphers.html">http://nmap.org/nsedoc/scripts/ssl-enum-ciphers.html</a>] with an internal rating.<br />• [30] [curl|<a href="http://curl.haxx.se/">http://curl.haxx.se/</a>] and [openssl|<a href="http://www.openssl.org/">http://www.openssl.org/</a>]: can be used to manually query SSL/TLS services<br />• [9] [Stunnel|<a href="http://www.stunnel.org">http://www.stunnel.org</a>]: a noteworthy class of SSL clients is that of SSL proxies such as stunnel available at which can be used to allow non-SSL enabled tools to talk to SSL services)<br />• [37] [socat| <a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a>]: Multipurpose relay<br />• [38] [testssl.sh| <a href="https://testssl.sh/">https://testssl.sh/</a> ]<br />• [39] <a href="https://www.owasp.org/index.php/O-Saft">O-Saft - OWASP SSL advanced forensic tool</a><br /><br /><h2>References</h2><br /><strong>OWASP Resources</strong> <br />•  [5] [OWASP Testing Guide - Testing for cookie attributes (OTG-SESS-002)|<a href="https://www.owasp.org/index.php/Testing_for_cookies_attributes_(OTG-SESS-002)">https://www.owasp.org/index.php/Testing_for_cookies_attributes_(OTG-SESS-002)</a>]<br />•  [4][OWASP Testing Guide - Test Network/Infrastructure Configuration (OTG-CONFIG-001)|<a href="https://www.owasp.org/index.php/Test_Network/Infrastructure_Configuration_(OTG-CONFIG-001)">https://www.owasp.org/index.php/Test_Network/Infrastructure_Configuration_(OTG-CONFIG-001)</a>]<br />•  [6] [OWASP Testing Guide - Testing for HTTP_Strict_Transport_Security (OTG-CONFIG-007)|<a href="https://www.owasp.org/index.php/Test_HTTP_Strict_Transport_Security_(OTG-CONFIG-007)">https://www.owasp.org/index.php/Test_HTTP_Strict_Transport_Security_(OTG-CONFIG-007)</a>]<br />•  [2] [OWASP Testing Guide - Testing for Sensitive information sent via unencrypted channels (OTG-CRYPST-003)|<a href="https://www.owasp.org/index.php/Testing_for_Sensitive_information_sent_via_unencrypted_channels_(OTG-CRYPST-003)">https://www.owasp.org/index.php/Testing_for_Sensitive_information_sent_via_unencrypted_channels_(OTG-CRYPST-003)</a>]<br />•  [3] [OWASP Testing Guide - Testing for Credentials Transported over an Encrypted Channel (OTG-AUTHN-001)|<a href="https://www.owasp.org/index.php/Testing_for_Credentials_Transported_over_an_Encrypted_Channel_(OTG-AUTHN-001)">https://www.owasp.org/index.php/Testing_for_Credentials_Transported_over_an_Encrypted_Channel_(OTG-AUTHN-001)</a>]<br />•  [22] [OWASP Cheat sheet - Transport Layer Protection|<a href="https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet">https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet</a>]<br />•  [23] [OWASP TOP 10 2013 - A6 Sensitive Data Exposure|<a href="https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure">https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure</a>]<br />•  [24] [OWASP TOP 10 2010 - A9 Insufficient Transport Layer Protection|<a href="https://www.owasp.org/index.php/Top_10_2010-A9-Insufficient_Transport_Layer_Protection">https://www.owasp.org/index.php/Top_10_2010-A9-Insufficient_Transport_Layer_Protection</a>]<br />•  [25] [OWASP ASVS 2009 - Verification 10|<a href="https://code.google.com/p/owasp-asvs/wiki/Verification_V10">https://code.google.com/p/owasp-asvs/wiki/Verification_V10</a>]<br />•  [26] [OWASP Application Security FAQ - Cryptography/SSL|<a href="https://www.owasp.org/index.php/OWASP_Application_Security_FAQ#Cryptography.2FSSL">https://www.owasp.org/index.php/OWASP_Application_Security_FAQ#Cryptography.2FSSL</a>]<br /><br /> <strong>Whitepapers</strong> <br />•  [1] [RFC5246 - The Transport Layer Security (TLS) Protocol Version 1.2 (Updated by <a href="https://tools.ietf.org/html/rfc5746">RFC 5746</a>, <a href="https://tools.ietf.org/html/rfc5878">RFC 5878</a>, <a href="https://tools.ietf.org/html/rfc6176">RFC 6176</a>)|<a href="http://www.ietf.org/rfc/rfc5246.txt">http://www.ietf.org/rfc/rfc5246.txt</a>]<br />•  [36] [RFC2817 - Upgrading to TLS Within HTTP/1.1|]<br />•  [34] [RFC6066 - Transport Layer Security (TLS) Extensions: Extension Definitions|<a href="http://www.ietf.org/rfc/rfc6066.txt">http://www.ietf.org/rfc/rfc6066.txt</a>]<br />•  [11] [SSLv2 Protocol Multiple Weaknesses |<a href="http://osvdb.org/56387">http://osvdb.org/56387</a>]<br />•  [12] [Mitre - TLS Renegotiation MiTM|<a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555">http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555</a>]<br />•  [13] [Qualys SSL Labs - TLS Renegotiation DoS|<a href="https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks">https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks</a>]<br />•  [10] [Qualys SSL Labs - SSL/TLS Deployment Best Practices|<a href="https://www.ssllabs.com/projects/best-practices/index.html">https://www.ssllabs.com/projects/best-practices/index.html</a>]<br />•  [14] [Qualys SSL Labs - SSL Server Rating Guide|<a href="https://www.ssllabs.com/projects/rating-guide/index.html">https://www.ssllabs.com/projects/rating-guide/index.html</a>]<br />•  [20] [Qualys SSL Labs - SSL Threat Model|<a href="https://www.ssllabs.com/projects/ssl-threat-model/index.html">https://www.ssllabs.com/projects/ssl-threat-model/index.html</a>]<br />•  [18] [Qualys SSL Labs - Forward Secrecy|<a href="https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy">https://community.qualys.com/blogs/securitylabs/2013/06/25/ssl-labs-deploying-forward-secrecy</a>]<br />•  [15] [Qualys SSL Labs - RC4 Usage|<a href="https://community.qualys.com/blogs/securitylabs/2013/03/19/rc4-in-tls-is-broken-now-what">https://community.qualys.com/blogs/securitylabs/2013/03/19/rc4-in-tls-is-broken-now-what</a>]<br />•  [16] [Qualys SSL Labs - BEAST|<a href="https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls">https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls</a>]<br />•  [17] [Qualys SSL Labs - CRIME|<a href="https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls">https://community.qualys.com/blogs/securitylabs/2012/09/14/crime-information-leakage-attack-against-ssltls</a>]<br />•  [7] [SurfJacking attack|<a href="https://resources.enablesecurity.com/resources/Surf%20Jacking.pdf">https://resources.enablesecurity.com/resources/Surf%20Jacking.pdf</a>]<br />•  [8] [SSLStrip attack|<a href="http://www.thoughtcrime.org/software/sslstrip/">http://www.thoughtcrime.org/software/sslstrip/</a>]<br />•  [19] [PCI-DSS v2.0|<a href="https://www.pcisecuritystandards.org/security_standards/documents.php">https://www.pcisecuritystandards.org/security_standards/documents.php</a>]<br />•  [35] [Xiaoyun Wang, Hongbo Yu: How to Break MD5 and Other Hash Functions| <a href="http://link.springer.com/chapter/10.1007/11426639_2">http://link.springer.com/chapter/10.1007/11426639_2</a>]<br />•  <a href="https://github.com/ssllabs/research/wiki">https://github.com/ssllabs/research/wiki</a><br /></div></body></html>