<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.3.4 Review Old, Backup and Unreferenced Files for Sensitive Information (OTG-CONFIG-004)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.3.4 Review Old, Backup and Unreferenced Files for Sensitive Information (OTG-CONFIG-004)  </h1><br/><br /><h2>Summary</h2><br />While most of the files within a web server are directly handled by  the server itself, it isn't uncommon to find unreferenced or forgotten  files that can be used to obtain important information about the  infrastructure or the credentials. <br /><br /> Most common scenarios include the presence of renamed old versions of  modified files, inclusion files that are loaded into the language of  choice and can be downloaded as source, or even automatic or manual  backups in form of compressed archives. Backup files can also be  generated automatically by the underlying file system the application is  hosted on, a feature usually referred to as "snapshots". <br /><br /> All these files may grant the tester access to inner workings, back  doors, administrative interfaces, or even credentials to connect to the  administrative interface or the database server. <br />An important source of vulnerability lies in files which have  nothing to do with the application, but are created as a consequence of  editing application files, or after creating on-the-fly backup copies,  or by leaving in the web tree old files or unreferenced files.Performing  in-place editing or other administrative actions on production web  servers may inadvertently leave backup copies, either generated  automatically by the editor while editing files, or by the administrator  who is zipping a set of files to create a backup. <br /><br /> It is easy to forget such files and this may pose a serious security  threat to the application. That happens because backup copies may be  generated with file extensions differing from those of the original  files. A <em>.tar, .zip or .gz</em> archive that we generate (and  forget...) has obviously a different extension, and the same happens  with automatic copies created by many editors (for example, emacs  generates a backup copy named <em>file~ </em>when editing <em>file</em>). Making a copy by hand may produce the same effect (think of copying <em>file</em> to <em>file.old</em>).  The underlying file system the application is on could be making  "snapshots" of your application at different points in time without your  knowledge, which may also be accessible via the web, posing a similar  but different "backup file" style threat to your application. <br /><br /> As a result, these activities generate files that are not needed by the  application and may be handled differently than the original file by the  web server. For example, if we make a copy of <em>login.asp</em> named <em>login.asp.old</em>, we are allowing users to download the source code of <em>login.asp</em>. This is because <em>login.asp.old</em> will be typically served as text or plain, rather than being executed because of its extension. In other words, accessing <em>login.asp</em> causes the execution of the server-side code of <em>login.asp</em>, while accessing <em>login.asp.old</em> causes the content of <em>login.asp.old</em>  (which is, again, server-side code) to be plainly returned to the user  and displayed in the browser. This may pose security risks, since  sensitive information may be revealed.  <br /><br /> Generally, exposing server side code is a bad idea. Not only are you  unnecessarily exposing business logic, but you may be unknowingly  revealing application-related information which may help an attacker  (path names, data structures, etc.). Not to mention the fact that there  are too many scripts with embedded username and password in clear text  (which is a careless and very dangerous practice). <br /><br /> Other causes of unreferenced files are due to design or configuration  choices when they allow diverse kind of application-related files such  as data files, configuration files, log files, to be stored in file  system directories that can be accessed by the web server. These files  have normally no reason to be in a file system space that could be  accessed via web, since they should be accessed only at the application  level, by the application itself (and not by the casual user browsing  around). <br /><br /> <br /><br /><h3>Threats</h3><br />Old, backup and unreferenced files present various threats to the security of a web application:  <br />•  Unreferenced files may disclose sensitive information that can facilitate a focused attack against the application; for example include files containing database credentials, configuration files containing references to other hidden content, absolute file paths, etc. <br />•  Unreferenced pages may contain powerful functionality that can be used to attack the application; for example an administration page that is not linked from published content but can be accessed by any user who knows where to find it. <br />•  Old and backup files may contain vulnerabilities that have been fixed in more recent versions; for example <em>viewdoc.old.jsp</em> may contain a directory traversal vulnerability that has been fixed in <em>viewdoc.jsp</em> but can still be exploited by anyone who finds the old version. <br />•  Backup files may disclose the source code for pages designed to execute on the server; for example requesting <em>viewdoc.bak</em> may return the source code for <em>viewdoc.jsp</em>, which can be reviewed for vulnerabilities that may be difficult to find by making blind requests to the executable page. While this threat obviously applies to scripted languages, such as Perl, PHP, ASP, shell scripts, JSP, etc., it is not limited to them, as shown in the example provided in the next bullet.<br />•  Backup archives may contain copies of all files within (or even outside) the webroot. This allows an attacker to quickly enumerate the entire application, including unreferenced pages, source code, include files, etc. For example, if you forget a file named <em>myservlets.jar.old</em> file containing (a backup copy of) your servlet implementation classes, you are exposing a lot of sensitive information which is susceptible to decompilation and reverse engineering.<br />•  In some cases copying or editing a file does not modify the file extension, but modifies the file name. This happens for example in Windows environments, where file copying operations generate file names prefixed with “Copy of “ or localized versions of this string. Since the file extension is left unchanged, this is not a case where an executable file is returned as plain text by the web server, and therefore not a case of source code disclosure. However, these files too are dangerous because there is a chance that they include obsolete and incorrect logic that, when invoked, could trigger application errors, which might yield valuable information to an attacker, if diagnostic message display is enabled.<br />•  Log files may contain sensitive information about the activities of application users, for example sensitive data passed in URL parameters, session IDs, URLs visited (which may disclose additional unreferenced content), etc. Other log files (e.g. ftp logs) may contain sensitive information about the maintenance of the application by system administrators.<br />•  File system snapshots may contain copies of the code that contain vulnerabilities that have been fixed in more recent versions. For example <em>/.snapshot/monthly.1/view.php</em> may contain a directory traversal vulnerability that has been fixed in <em>/view.php</em> but can still be exploited by anyone who finds the old version.<br /><br /> <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box Testing</h3><br />Testing for unreferenced files uses both automated and manual  techniques, and typically involves a combination of the following:  <br /><br /><h3>Inference from the naming scheme used for published content</h3><br />Enumerate all of the application’s pages and functionality. This can  be done manually using a browser, or using an application spidering  tool. Most applications use a recognizable naming scheme, and organize  resources into pages and directories using words that describe their  function. From the naming scheme used for published content, it is often  possible to infer the name and location of unreferenced pages. For  example, if a page <em>viewuser.asp</em> is found, then look also for <em>edituser.asp</em>, <em>adduser.asp</em> and <em>deleteuser.asp</em>. If a directory <em>/app/user</em> is found, then look also for <em>/app/admin</em> and <em>/app/manager</em>.  <br /><br /> <br /><br /><h3>Other clues in published content</h3><br />Many web applications leave clues in published content that can lead  to the discovery of hidden pages and functionality. These clues often  appear in the source code of HTML and JavaScript files. The source code  for all published content should be manually reviewed to identify clues  about other pages and functionality. For example:  <br />Programmers’ comments and commented-out sections of source code may refer to hidden content:  <br />&lt;!-- &lt;A HREF="uploadfile.jsp"&gt;Upload a document to the server&lt;/A&gt; --&gt;<br />&lt;!-- Link removed while bugs in uploadfile.jsp are fixed          --&gt; <br /><br /> JavaScript may contain page links that are only rendered within the user’s GUI under certain circumstances:  <br />var adminUser=false;<br />:<br />if (adminUser) menu.add (new menuItem ("Maintain users", "/admin/useradmin.jsp")); <br /><br /> HTML pages may contain FORMs that have been hidden by disabling the SUBMIT element:  <br />&lt;FORM action="forgotPassword.jsp" method="post"&gt;<br />    &lt;INPUT type="hidden" name="userID" value="123"&gt;<br />    &lt;!-- &lt;INPUT type="submit" value="Forgot Password"&gt; --&gt;<br />&lt;/FORM&gt; <br /><br /> Another source of clues about unreferenced directories is the <em>/robots.txt</em> file used to provide instructions to web robots:  <br />User-agent: *<br />Disallow: /Admin<br />Disallow: /uploads<br />Disallow: /backup<br />Disallow: /~jbloggs<br />Disallow: /include <br /><br /> <br /><br /><h3>Blind guessing</h3><br />In its simplest form, this involves running a list of common file  names through a request engine in an attempt to guess files and  directories that exist on the server. The following netcat wrapper  script will read a wordlist from stdin and perform a basic guessing  attack:  <br />#!/bin/bash<br /><br />server=www.targetapp.com<br />port=80<br /><br />while read url<br />do<br />echo -ne "$url\t"<br />echo -e "GET /$url HTTP/1.0\nHost: $server\n" | netcat $server $port | head -1<br />done | tee outputfile <br /><br /><br /> Depending upon the server, GET may be replaced with HEAD for faster  results. The output file specified can be grepped for “interesting”  response codes. The response code 200 (OK) usually indicates that a  valid resource has been found (provided the server does not deliver a  custom “not found” page using the 200 code). But also look out for 301  (Moved), 302 (Found), 401 (Unauthorized), 403 (Forbidden) and 500  (Internal error), which may also indicate resources or directories that  are worthy of further investigation.  <br /><br /> The basic guessing attack should be run against the webroot, and also  against all directories that have been identified through other  enumeration techniques. More advanced/effective guessing attacks can be  performed as follows:  <br />•  Identify the file extensions in use within known areas of the application (e.g. jsp, aspx, html), and use a basic wordlist appended with each of these extensions (or use a longer list of common extensions if resources permit). <br />•  For each file identified through other enumeration techniques, create a custom wordlist derived from that filename. Get a list of common file extensions (including ~, bak, txt, src, dev, old, inc, orig, copy, tmp, etc.) and use each extension before, after, and instead of, the extension of the actual file name. <br /><br /> Note: Windows file copying operations generate file names prefixed with  “Copy of “ or localized versions of this string, hence they do not  change file extensions. While “Copy of ” files typically do not disclose  source code when accessed, they might yield valuable information in  case they cause errors when invoked. <br /><br /> <br /><br /><h3>Information obtained through server vulnerabilities and misconfiguration</h3><br />The most obvious way in which a misconfigured server may disclose  unreferenced pages is through directory listing. Request all enumerated  directories to identify any which provide a directory listing.  <br />Numerous vulnerabilities have been found in individual web  servers which allow an attacker to enumerate unreferenced content, for  example:  <br />•  Apache ?M=D directory listing vulnerability.<br />•  Various IIS script source disclosure vulnerabilities. <br />•  IIS WebDAV directory listing vulnerabilities. <br /><br /> <br /><br /><h3>Use of publicly available information</h3><br />Pages and functionality in Internet-facing web applications that are  not referenced from within the application itself may be referenced from  other public domain sources. There are various sources of these  references:  <br />•  Pages that used to be referenced may still appear in the archives of Internet search engines. For example, <em>1998results.asp</em> may no longer be linked from a company’s website, but may remain on the server and in search engine databases. This old script may contain vulnerabilities that could be used to compromise the entire site. The <em>site:</em> Google search operator may be used to run a query only against the domain of choice, such as in: <em>site:www.example.com</em>. Using search engines in this way has lead to a broad array of techniques which you may find useful and that are described in the <em>Google Hacking</em> section of this Guide. Check it to hone your testing skills via Google. Backup files are not likely to be referenced by any other files and therefore may have not been indexed by Google, but if they lie in browsable directories the search engine might know about them.<br />•  In addition, Google and Yahoo keep cached versions of pages found by their robots. Even if <em>1998results.asp</em> has been removed from the target server, a version of its output may still be stored by these search engines. The cached version may contain references to, or clues about, additional hidden content that still remains on the server. <br />•  Content that is not referenced from within a target application may be linked to by third-party websites. For example, an application which processes online payments on behalf of third-party traders may contain a variety of bespoke functionality which can (normally) only be found by following links within the web sites of its customers.<br /><br /> <br /><br /><h3>File name filter bypass</h3><br />Because blacklist filters are based on regular expressions, one can  sometimes take advantage of obscure OS file name expansion features in  which work in ways the developer didn't expect. The tester can sometimes  exploit differences in ways that file names are parsed by the  application, web server, and underlying  OS and it's file name  conventions. <br /><br /> Example: Windows 8.3 filename expansion "c:\program files" becomes "C:\PROGRA~1" <br />– Remove incompatible characters <br />– Convert spaces to underscores <br />- Take the first six characters of the basename <br />– Add “~&lt;digit&gt;” which is used to distinguish files with names using the same six initial characters <br />- This convention changes after the first 3 cname ollisions <br />– Truncate  file extension to three characters<br />- Make all the characters uppercase <br /><br /> <br /><br /><h3>Gray Box Testing</h3><br />Performing gray box testing against old and backup files requires  examining the files contained in the directories belonging to the set of  web directories served by the web server(s) of the web application  infrastructure. Theoretically the examination should be performed by  hand to be thorough. However, since in most cases copies of files or  backup files tend to be created by using the same naming conventions,  the search can be easily scripted. For example, editors leave behind  backup copies by naming them with a recognizable extension or ending and  humans tend to leave behind files with a “.old” or similar predictable  extensions. A good strategy is that of periodically scheduling a  background job checking for files with extensions likely to identify  them as copy or backup files, and performing manual checks as well on a  longer time basis. <br /><br /> <br /><br /><h2>Tools</h2><br />•  Vulnerability assessment tools tend to include checks to spot web directories having standard names (such as “admin”, “test”, “backup”, etc.), and to report any web directory which allows indexing. If you can’t get any directory listing, you should try to check for likely backup extensions. Check for example Nessus (<a href="http://www.nessus.org">http://www.nessus.org</a>), Nikto2(<a href="http://www.cirt.net/code/nikto.shtml">http://www.cirt.net/code/nikto.shtml</a>) or its new derivative Wikto (<a href="http://www.sensepost.com/research/wikto/">http://www.sensepost.com/research/wikto/</a>), which also supports Google hacking based strategies.<br />•  Web spider tools: wget (<a href="http://www.gnu.org/software/wget/">http://www.gnu.org/software/wget/</a>,   <a href="http://www.interlog.com/~tcharron/wgetwin.html">http://www.interlog.com/~tcharron/wgetwin.html</a>); Sam Spade (<a href="http://www.samspade.org">http://www.samspade.org</a>); Spike proxy includes a web site crawler function (<a href="http://www.immunitysec.com/spikeproxy.html">http://www.immunitysec.com/spikeproxy.html</a>); Xenu (<a href="http://home.snafu.de/tilman/xenulink.html">http://home.snafu.de/tilman/xenulink.html</a>); curl (<a href="http://curl.haxx.se">http://curl.haxx.se</a>). Some of them are also included in standard Linux distributions.<br />•  Web development tools usually include facilities to identify broken links and unreferenced files.<br /><br /> <br /><br /><h2>Remediation</h2><br />To guarantee an effective protection strategy, testing should be  compounded by a security policy which clearly forbids dangerous  practices, such as: <br /><br /> <br />•  Editing files in-place on the web server or application server file systems. This is a particular bad habit, since it is likely to unwillingly generate backup files by the editors. It is amazing to see how often this is done, even in large organizations. If you absolutely need to edit files on a production system, do ensure that you don’t leave behind anything which is not explicitly intended, and consider that you are doing it at your own risk.<br />•  Check carefully any other activity performed on file systems exposed by the web server, such as spot administration activities. For example, if you occasionally need to take a snapshot of a couple of directories (which you should not do on a production system), you may be tempted to zip them first. Be careful not to forget behind those archive files.<br />•  Appropriate configuration management policies should help not to leave around obsolete and unreferenced files.<br />•  Applications should be designed not to create (or rely on) files stored under the web directory trees served by the web server. Data files, log files, configuration files, etc. should be stored in directories not accessible by the web server, to counter the possibility of information disclosure (not to mention data modification if web directory permissions allow writing).<br />•  File system snapshots should not be accessible via the web if the document root is on a file system using this technology. Configure your web server to deny access to such directories, for example under apache a location directive such this should be used:<br />&lt;Location ~ ".snapshot"&gt;<br />    Order deny,allow<br />    Deny from all<br />&lt;/Location&gt;<br /></div></body></html>