<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.2.8 Fingerprint Web Application Framework (OTG-INFO-008)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.2.8 Fingerprint Web Application Framework (OTG-INFO-008)  </h1><br/><br /><h2>Summary</h2><br />Web framework[*] fingerprinting is an important subtask of the  information gathering process. Knowing the type of framework can  automatically give a great advantage if such a framework has already  been tested by the penetration tester. It is not only the known  vulnerabilities in unpatched versions but specific misconfigurations in  the framework and known file structure that makes the fingerprinting  process so important. <br /><br /> Several different vendors and versions of web frameworks are widely  used. Information about it significantly helps in the testing process,  and can also help in changing the course of the test. Such information  can be derived by careful analysis of certain common locations. Most of  the web frameworks have several markers in those locations which help an  attacker to spot them. This is basically what all automatic tools do,  they look for a marker from a predefined location and then compare it to  the database of known signatures. For better accuracy several markers  are usually used. <br /><br /> [*] Please note that this article makes no differentiation between Web  Application Frameworks (WAF) and Content Management Systems (CMS). This  has been done to make it convenient to fingerprint both of them in one  chapter. Furthermore, both categories are referenced as web frameworks. <br /><br /> <br /><br /><h2>Test Objectives</h2><br />To define type of used web framework so as to have a better understanding of the security testing methodology. <br /><br /> <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box testing</h3><br />There are several most common locations to look in in order to define the current framework: <br />• HTTP headers<br />• Cookies<br />• HTML source code<br />• Specific files and folders<br />• File Extensions<br />• Error Message<br /><br /><h3>HTTP headers</h3><br />The most basic form of identifying a web framework is to look at the <em>X-Powered-By</em> field in the HTTP response header. Many tools can be used to fingerprint a target. The simplest one is netcat utility.  <br />Consider the following HTTP Request-Response:  <br />$ nc 127.0.0.1 80<br />HEAD / HTTP/1.0<br /><br />HTTP/1.1 200 OK<br />Server: nginx/1.0.14<br />Date: Sat, 07 Sep 2013 08:19:15 GMT<br />Content-Type: text/html;charset=ISO-8859-1<br />Connection: close<br />Vary: Accept-Encoding<br />X-Powered-By: Mono<br />From the <em>X-Powered-By</em> field, we understand that the web  application framework is likely to be Mono. However, although this  approach is simple and quick, this methodology doesn't work in 100% of  cases. It is possible to easily disable <em>X-Powered-By</em> header by a  proper configuration. There are also several techniques that allow a web  site to obfuscate HTTP headers (see an example in <a href="https://www.owasp.org/index.php/Fingerprint_Web_Application_Framework_(OTG-INFO-008)#Remediation">#Remediation</a> chapter). <br /><br /> So in the same example the tester could either miss the <em>X-Powered-By</em> header or obtain an answer like the following: <br />HTTP/1.1 200 OK<br />Server: nginx/1.0.14<br />Date: Sat, 07 Sep 2013 08:19:15 GMT<br />Content-Type: text/html;charset=ISO-8859-1<br />Connection: close<br />Vary: Accept-Encoding<br />X-Powered-By: Blood, sweat and tears<br /><br /> Sometimes there are more HTTP-headers that point at a certain web  framework. In the following example, according to the information from  HTTP-request, one can see that <em>X-Powered-By</em> header contains PHP version. However, the <em>X-Generator</em>  header points out the used framework is actually Swiftlet, which helps a  penetration tester to expand his attack vectors. When performing  fingerprinting, always carefully inspect every HTTP-header for such  leaks. <br />HTTP/1.1 200 OK<br />Server: nginx/1.4.1<br />Date: Sat, 07 Sep 2013 09:22:52 GMT<br />Content-Type: text/html<br />Connection: keep-alive<br />Vary: Accept-Encoding<br />X-Powered-By: PHP/5.4.16-1~dotdeb.1<br />Expires: Thu, 19 Nov 1981 08:52:00 GMT<br />Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0<br />Pragma: no-cache<br />X-Generator: Swiftlet<br /><br /> <br /><br /><h3>Cookies</h3><br />Another similar and somehow more reliable way to determine the current web framework are framework-specific cookies. <br />Consider the following HTTP-request: <br /><img src="images/183-1.png" alt="images/183-1.png" /> <br /><br /> The cookie <em>CAKEPHP</em> has automatically been set, which gives  information about the framework being used. List of common cookies names  is presented in chapter <a href="https://www.owasp.org/index.php/Fingerprint_Web_Application_Framework_(OTG-INFO-008)#Cookies_2">#Cookies_2</a>. Limitations are the same - it is possible to change the name of the cookie. For example, for the selected <em>CakePHP</em> framework this could be done by the following configuration (excerpt from core.php): <br />/**<br />* The name of CakePHP's session cookie.<br />*<br />* Note the guidelines for Session names states: "The session name references<br />* the session id in cookies and URLs. It should contain only alphanumeric<br />* characters."<br />* @link http://php.net/session_name<br />*/<br />Configure::write('Session.cookie', 'CAKEPHP');<br /><br /> However, these changes are less likely to be made than changes to the <em>X-Powered-By</em> header, so this approach can be considered as more reliable. <br /><br /> <br /><br /><h3>HTML source code</h3><br />This technique is based on finding certain patterns in the HTML page  source code. Often one can find a lot of information which helps a  tester to recognize a specific web framework. One of the common markers  are HTML comments that directly lead to framework disclosure. More often  certain framework-specific paths can be found, i.e. links to  framework-specific css and/or js folders. Finally, specific script  variables might also point to a certain framework. <br /><br /> From the screenshot below one can easily learn the used framework and  its version by the mentioned markers. The comment, specific paths and  script variables can all help an attacker to quickly determine an  instance of ZK framework. <br /><img src="images/183-2.png" alt="images/183-2.png" /> <br /><br /> More frequently such information is placed between  &lt;head&gt;&lt;/head&gt; tags, in &lt;meta&gt; tags or at the end of  the page. Nevertheless, it is recommended to check the whole document  since it can be useful for other purposes such as inspection of other  useful comments and hidden fields. Sometimes, web developers do not care  much about hiding information about the framework used. It is still  possible to stumble upon something like this at the bottom of the page: <br /><img src="images/183-3.png" alt="images/183-3.png" /> <br /><br /><h3>File Extensions</h3><br />URL may include file extensions. The file extensions can also help to identify the web platform or technology. <br />For example, OWASP is using PHP <br />    https://www.owasp.org/index.php?title=Fingerprint_Web_Application_Framework_(OTG-INFO-008)&amp;action=edit&amp;section=4<br />Here are some common web extensions and technology <br />•  php -- PHP<br />•  aspx -- Microsoft ASP.NET<br />•  jsp -- Java Server pages<br /><br /><h3>Error Message</h3><br /><br /><h2>Common frameworks</h2><br /><br /><h3>Cookies</h3><br /><table class="table"><col/><col/><tr><th> Framework </th><th> Cookie name</th></tr><tr><td> Zope </td><td> zope3</td></tr><tr><td> CakePHP </td><td> cakephp</td></tr><tr><td> Kohana </td><td> kohanasession</td></tr><tr><td> Laravel </td><td> laravel_session</td></tr></table><br /><br /> <br /><br /><h3>HTML source code</h3><br /><br /><h3>General markers</h3><br /><table class="table"><col/><tr><th>click me</th></tr><tr><td> %framework_name%</td></tr><tr><td> powered by</td></tr><tr><td> built upon</td></tr><tr><td> running</td></tr></table><br /><br /> <br /><br /><h3>Specific markers</h3><br /><table class="table"><col/><col/><tr><th> Framework </th><th> Keyword</th></tr><tr><td> Adobe ColdFusion </td><td> &lt;!-- START headerTags.cfm</td></tr><tr><td> Microsoft ASP.NET </td><td> __VIEWSTATE</td></tr><tr><td> ZK </td><td> &lt;!-- ZK</td></tr><tr><td> Business Catalyst </td><td> &lt;!-- BC_OBNW --&gt;</td></tr><tr><td> Indexhibit </td><td> ndxz-studio</td></tr></table><br /><br /> <br /><br /><h3>Specific files and folders</h3><br />Specific files and folders are different for each specific framework.  It is recommended to install the corresponding framework during  penetration tests in order to have better understanding of what  infrastructure is presented and what files might be left on the server.  However, several good file lists already exist and one good example is  FuzzDB wordlists of predictable files/folders (<a href="http://code.google.com/p/fuzzdb/">http://code.google.com/p/fuzzdb/</a>). <br /><br /> <br /><br /><h2>Tools</h2><br />A list of general and well-known tools is presented below. There are  also a lot of other utilities, as well as framework-based fingerprinting  tools. <br /><br /> <br /><br /><h3>WhatWeb</h3><br />Website:  <a href="http://www.morningstarsecurity.com/research/whatweb">http://www.morningstarsecurity.com/research/whatweb</a> <br /> Currently one of the best fingerprinting tools on the market. Included in a default <a href="https://www.owasp.org/index.php?title=Kali_Linux&action=edit&redlink=1">Kali Linux</a> build. Language: Ruby Matches for fingerprinting are made with: <br />•  Text strings (case sensitive)<br />•  Regular expressions<br />•  Google Hack Database queries (limited set of keywords)<br />•  MD5 hashes<br />•  URL recognition<br />•  HTML tag patterns<br />•  Custom ruby code for passive and aggressive operations<br /><br /> Sample output is presented on a screenshot below: <br /><img src="images/183-4.png" alt="images/183-4.png" /> <br /><br /> <br /><br /><h3>BlindElephant</h3><br />Website: <a href="https://community.qualys.com/community/blindelephant">https://community.qualys.com/community/blindelephant</a> <br /> This great tool works on the principle of static file checksum based  version difference thus providing a very high quality of fingerprinting. Language: Python <br />Sample output of a successful fingerprint: <br />pentester$ python BlindElephant.py http://my_target drupal<br />Loaded /Library/Python/2.7/site-packages/blindelephant/dbs/drupal.pkl with 145 versions, 478 differentiating paths, and 434 version groups.<br />Starting BlindElephant fingerprint for version of drupal at http://my_target <br /><br />Hit http://my_target/CHANGELOG.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 527b085a3717bd691d47713dff74acf4 <br /><br />Hit http://my_target/INSTALL.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 14dfc133e4101be6f0ef5c64566da4a4 <br /><br />Hit http://my_target/misc/drupal.js<br />Possible versions based on result: 7.12, 7.13, 7.14<br /><br />Hit http://my_target/MAINTAINERS.txt<br />File produced no match. Error: Retrieved file doesn't match known fingerprint. 36b740941a19912f3fdbfcca7caa08ca <br /><br />Hit http://my_target/themes/garland/style.css<br />Possible versions based on result: 7.2, 7.3, 7.4, 7.5, 7.6, 7.7, 7.8, 7.9, 7.10, 7.11, 7.12, 7.13, 7.14<br /><br />...<br /><br />Fingerprinting resulted in:<br />7.14<br /><br /><br />Best Guess: 7.14<br /><br /> <br /><br /><h3>Wappalyzer</h3><br />Website: <a href="http://wappalyzer.com">http://wappalyzer.com</a> <br /> Wapplyzer is a Firefox Chrome plug-in. It works only on regular  expression matching and doesn't need anything other than the page to be  loaded on browser. It works completely at the browser level and gives  results in the form of icons. Although sometimes it has false positives,  this is very handy to have notion of what technologies were used to  construct a target website immediately after browsing a page. <br /><br /> Sample output of a plug-in is presented on a screenshot below. <br /><img src="images/183-5.png" alt="images/183-5.png" /> <br /><br /> <br /><br /><h2>References</h2><br /><strong>Whitepapers</strong><br /> <br />•  Saumil Shah: "An Introduction to HTTP fingerprinting" - <a href="http://www.net-square.com/httprint_paper.html">http://www.net-square.com/httprint_paper.html</a><br />•  Anant Shrivastava : "Web Application Finger Printing" - <a href="http://anantshri.info/articles/web_app_finger_printing.html">http://anantshri.info/articles/web_app_finger_printing.html</a><br /><br /> <br /><br /><h2>Remediation</h2><br />The general advice is to use several of the tools described above and  check logs to better understand what exactly helps an attacker to  disclose the web framework. By performing multiple scans after changes  have been made to hide framework tracks, it's possible to achieve a  better level of security and to make sure of the framework can not be  detected by automatic scans. Below are some specific recommendations by  framework marker location and some additional interesting approaches. <br /><br /> <br /><br /><h3>HTTP headers</h3><br />Check the configuration and disable or obfuscate all HTTP-headers  that disclose information the technologies used. Here is an interesting  article about HTTP-headers obfuscation using Netscaler: <a href="http://grahamhosking.blogspot.ru/2013/07/obfuscating-http-header-using-netscaler.html">http://grahamhosking.blogspot.ru/2013/07/obfuscating-http-header-using-netscaler.html</a> <br /><br /> <br /><br /><h3>Cookies</h3><br />It is recommended to change cookie names by making changes in the corresponding configuration files. <br /><br /> <br /><br /><h3>HTML source code</h3><br />Manually check the contents of the HTML code and remove everything that explicitly points to the framework. <br />General guidelines: <br />• Make sure there are no visual markers disclosing the framework<br />• Remove any unnecessary comments (copyrights, bug information, specific framework comments)<br />• Remove META and generator tags<br />• Use the companies own css or js files and do not store those in a framework-specific folders<br />• Do not use default scripts on the page or obfuscate them if they must be used. <br /><br /> <br /><br /><h3>Specific files and folders</h3><br />General guidelines: <br />• Remove any unnecessary or unused files on the server. This implies text files disclosing information about versions and installation too.<br />• Restrict access to other files in order to achieve 404-response when accessing them from outside. This can be done, for example, by modifying htaccess file and adding RewriteCond or RewriteRule there. An example of such restriction for two common WordPress folders is presented below.<br />RewriteCond %{REQUEST_URI} /wp-login\.php$ [OR]<br />RewriteCond %{REQUEST_URI} /wp-admin/$<br />RewriteRule $ /http://your_website [R=404,L]<br /><br /> However, these are not the only ways to restrict access. In order to  automate this process, certain framework-specific plugins exist. One  example for WordPress is StealthLogin (<a href="http://wordpress.org/plugins/stealth-login-page">http://wordpress.org/plugins/stealth-login-page</a>). <br /><br /> <br /><br /><h3>Additional approaches</h3><br />General guidelines: <br />• Checksum management The purpose of this approach is to beat checksum-based scanners and not let them disclose files by their hashes. Generally, there are two approaches in checksum management:• Change the location of where those files are placed (i.e. move them to another folder, or rename the existing folder)<br />• Modify the contents - even slight modification results in a completely different hash sum, so adding a single byte in the end of the file should not be a big problem.<br /><br />• Controlled chaosA funny and effective method that involves adding bogus files and folders from other frameworks in order to fool scanners and confuse an attacker. But be careful not to overwrite existing files and folders and to break the current framework!<br /></div></body></html>