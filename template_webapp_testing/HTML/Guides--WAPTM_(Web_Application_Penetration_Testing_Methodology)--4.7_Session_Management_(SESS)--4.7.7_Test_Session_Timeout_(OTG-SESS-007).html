<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.7.7 Test Session Timeout (OTG-SESS-007) </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.7.7 Test Session Timeout (OTG-SESS-007) </h1><br/><br /><h2>Summary</h2><br />In this phase testers check that the application automatically logs  out a user when that user has been idle for a certain amount of time,  ensuring that it is not possible to “reuse” the same session and that no  sensitive data remains stored in the browser cache. <br /><br /> All applications should implement an idle or inactivity timeout for  sessions. This timeout defines the amount of time a session will remain  active in case there is no activity by the user, closing and  invalidating the session upon the defined idle period since the last  HTTP request received by the web application for a given session ID. The  most appropriate timeout should be a balance between security (shorter  timeout) and usability (longer timeout) and heavily depends on the  sensitivity level of the data handled by the application. For example, a  60 minute log out time for a public forum can be acceptable, but such a  long time would be too much in a home banking application (where a  maximum timeout of 15 minutes is recommended). In any case, any  application that does not enforce a timeout-based log out should be  considered not secure, unless such behavior is required by a specific  functional requirement. <br /><br /> The idle timeout limits the chances that an attacker has to guess and  use a valid session ID from another user, and under certain  circumstances could protect public computers from session reuse.  However, if the attacker is able to hijack a given session, the idle  timeout does not limit the attacker’s actions, as he can generate  activity on the session periodically to keep the session active for  longer periods of time.  <br /><br /> Session timeout management and expiration must be enforced server-side.  If some data under the control of the client is used to enforce the  session timeout, for example using cookie values or other client  parameters to track time references (e.g. number of minutes since log in  time), an attacker could manipulate these to extend the session  duration. So the application has to track the inactivity time on the  server side and, after the timeout is expired, automatically invalidate  the current user's session and delete every data stored on the client.  <br /><br /> Both actions must be implemented carefully, in order to avoid  introducing weaknesses that could be exploited by an attacker to gain  unauthorized access if the user forgot to log out from the application.  More specifically, as for the log out function, it is important to  ensure that all session tokens (e.g. cookies) are properly destroyed or  made unusable, and that proper controls are enforced at the server side  to prevent the reuse of session tokens. If such actions are not properly  carried out, an attacker could replay these session tokens in order to  “resurrect” the session of a legitimate user and impersonate him/her  (this attack is usually known as 'cookie replay'). Of course, a  mitigating factor is that the attacker needs to be able to access those  tokens (which are stored on the victim's PC), but, in a variety of  cases, this may not be impossible or particularly difficult.  <br /><br /> The most common scenario for this kind of attack is a public computer  that is used to access some private information (e.g., web mail, online  bank account). If the user moves away from the computer without  explicitly logging out and the session timeout is not implemented on the  application, then an attacker could access to the same account by  simply pressing the “back” button of the browser.    <br /><br /><h2>How to Test</h2><br /><br /><h3>Black Box testing</h3><br />The same approach seen in the <a href="https://www.owasp.org/index.php/Testing_for_logout_functionality_(OTG-SESS-006)">Testing for logout functionality (OTG-SESS-006)</a> section can be applied when measuring the timeout log out.   <br /> <br />The testing methodology is very similar. First, testers have to  check whether a timeout exists, for instance, by logging in and waiting  for the timeout log out to be triggered. As in the log out function,  after the timeout has passed, all session tokens should be destroyed or  be unusable. <br /><br /> Then, if the timeout is configured, testers need to understand whether  the timeout is enforced by the client or by the server (or both). If the  session cookie is non-persistent (or, more in general, the session  cookie does not store any data about the time), testers can assume that  the timeout is enforced by the server. If the session cookie contains  some time related data (e.g., log in time, or last access time, or  expiration date for a persistent cookie), then it's possible that the  client is involved in the timeout enforcing. In this case, testers could  try to modify the cookie (if it's not cryptographically protected) and  see what happens to the session. For instance, testers can set the  cookie expiration date far in the future and see whether the session can  be prolonged.  <br /><br /> As a general rule, everything should be checked server-side and it  should not be possible, by re-setting the session cookies to previous  values, to access the application again.  <br /> <br /><br /><h3>Gray Box Testing</h3><br /><br /> The tester needs to check that: <br />•  The log out function effectively destroys all session token, or at least renders them unusable,<br />•  The server performs proper checks on the session state, disallowing an attacker to replay previously destroyed session identifiers<br />•  A timeout is enforced and it is properly enforced by the server. If the server uses an expiration time that is read from a session token that is sent by the client (but this is not advisable), then the token must be cryptographically protected from tampering.<br /><br /> Note that the most important thing is for the application to invalidate  the session on the server side. Generally this means that the code must  invoke the appropriate methods, e.g. HttpSession.invalidate() in Java  and Session.abandon() in .NET. Clearing the cookies from the browser is  advisable, but is not strictly necessary, since if the session is  properly invalidated on the server, having the cookie in the browser  will not help an attacker. <br /><br /> <br /><br /><h2>References</h2><br /><strong>OWASP Resources</strong> <br />•  <a href="https://www.owasp.org/index.php/Session_Management_Cheat_Sheet">Session Management Cheat Sheet</a><br /></div></body></html>