<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.8.13 Testing for Command Injection   (OTG-INPVAL-013)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.8.13 Testing for Command Injection   (OTG-INPVAL-013)  </h1><br/><br /><h2>Summary</h2><br />This article describes how to test an application for OS command  injection. The tester will try to inject an OS command through an HTTP  request to the application. <br /><br /> OS command injection is a technique used via a web interface in order to  execute OS commands on a web server. The user supplies operating system  commands through a web interface in order to execute OS commands.  Any  web interface that is not properly sanitized is subject to this exploit.   With the ability to execute OS commands, the user can upload malicious  programs or even obtain passwords.  OS command injection is preventable  when security is emphasized during the design and development of  applications. <br /><br /> <br /><br /><h2>How to Test</h2><br />When viewing a file in a web application, the file name is often  shown in the URL.  Perl allows piping data from a process into an open  statement.  The user can simply append the Pipe symbol “|” onto the end  of the file name. <br /><br /> Example URL before alteration:<br /> <br />http://sensitive/cgi-bin/userData.pl?doc=user1.txt<br /><br /><br /> Example URL modified:<br /> <br />http://sensitive/cgi-bin/userData.pl?doc=/bin/ls|<br /><br /><br /> This will execute the command “/bin/ls”.<br /> <br /><br /> Appending a semicolon to the end of a URL for a .PHP page followed by an  operating system command, will execute the command. %3B is url encoded  and decodes to semicolon <br /> <br />Example:<br /> <br />http://sensitive/something.php?dir=%3Bcat%20/etc/passwd<br /><br /><br /> <strong>Example</strong><br /> Consider the case of an application that contains a set of documents  that you can browse from the Internet. If you fire up WebScarab, you can  obtain a POST HTTP like the following: <br />POST http://www.example.com/public/doc HTTP/1.1<br />Host: www.example.com<br />User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1) Gecko/20061010 FireFox/2.0<br />Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<br />Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3<br />Accept-Encoding: gzip,deflate<br />Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br />Keep-Alive: 300<br />Proxy-Connection: keep-alive<br />Referer: http://127.0.0.1/WebGoat/attack?Screen=20<br />Cookie: JSESSIONID=295500AD2AAEEBEDC9DB86E34F24A0A5<br />Authorization: Basic T2Vbc1Q9Z3V2Tc3e=<br />Content-Type: application/x-www-form-urlencoded<br />Content-length: 33<br /><br />Doc=Doc1.pdf<br /><br /> In this post request, we notice how the application retrieves the public  documentation. Now we can test if it is possible to add an operating  system command to inject in the POST HTTP. Try the following: <br />POST http://www.example.com/public/doc HTTP/1.1<br />Host: www.example.com<br />User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; it; rv:1.8.1) Gecko/20061010 FireFox/2.0<br />Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<br />Accept-Language: it-it,it;q=0.8,en-us;q=0.5,en;q=0.3<br />Accept-Encoding: gzip,deflate<br />Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br />Keep-Alive: 300<br />Proxy-Connection: keep-alive<br />Referer: http://127.0.0.1/WebGoat/attack?Screen=20<br />Cookie: JSESSIONID=295500AD2AAEEBEDC9DB86E34F24A0A5<br />Authorization: Basic T2Vbc1Q9Z3V2Tc3e=<br />Content-Type: application/x-www-form-urlencoded<br />Content-length: 33<br /><br />Doc=Doc1.pdf+|+Dir c:\<br /><br /> If the application doesn't validate the request, we can obtain the following result: <br />Exec Results for 'cmd.exe /c type "C:\httpd\public\doc\"Doc=Doc1.pdf+|+Dir c:\'<br />Output...<br />Il volume nell'unità C non ha etichetta.<br />Numero di serie Del volume: 8E3F-4B61<br />Directory of c:\<br /> 18/10/2006 00:27 2,675 Dir_Prog.txt<br /> 18/10/2006 00:28 3,887 Dir_ProgFile.txt<br /> 16/11/2006 10:43<br />    Doc<br />    11/11/2006 17:25<br />       Documents and Settings<br />       25/10/2006 03:11<br />          I386<br />          14/11/2006 18:51<br />	     h4ck3r<br />	     30/09/2005 21:40 25,934 <br />		OWASP1.JPG<br />		03/11/2006 18:29<br />			Prog<br />			18/11/2006 11:20<br />				Program Files<br />				16/11/2006 21:12<br />					Software<br />					24/10/2006 18:25<br />						Setup<br />						24/10/2006 23:37<br />							Technologies<br />							18/11/2006 11:14	<br />							3 File 32,496 byte<br />							13 Directory 6,921,269,248 byte disponibili<br />							Return code: 0<br /><br /> In this case, we have successfully performed an OS injection attack. <br /><br /><h2>Special Characters for Comand Injection</h2><br />The following special character can be used for command injection such as |   ;   &amp;  $  &gt;  &lt; `  \ ! <br />•  cmd1|cmd2   : Uses of | will make command 2 to be executed weather command 1 execution is successful or not.<br />•  cmd1;cmd2   : Uses of ; will make command 2 to be executed weather command 1 execution is successful or not.<br />•  cmd1||cmd2  : Command 2 will only be executed if command 1 execution fails.<br />•  cmd1&amp;&amp;cmd2 : Command 2 will only be executed if command 1 execution succeeds.<br />•  $(cmd) : For example, echo $(whoami) or $(touch test.sh; echo 'ls' &gt; test.sh)<br />•  'cmd' : It's used to execute specific command. For example, 'whoami'<br />•  &gt;(cmd): &lt;(ls)<br />•  &lt;(cmd): &gt;(ls)<br /><br /><h2>Code Review Dangerous API</h2><br />Be aware of the uses of the following API as it may introduce the command injection risks. <br />Java <br />•  Runtime.exec()<br />•  getParameter<br />•  getRuntime.exec()<br />•  ProcessBuilder.start()<br />•  setAttribute  putValue   getValue  <br />•  java.net.Socket  java.io.fileInputStream   java.io.FileReader<br />C/C++  <br />•  system<br />•  exec<br />•  ShellExecute<br />•  execlp<br />Python <br />•  exec<br />•  eval<br />•  os.system<br />•  os.popen<br />•  subprocess.popen<br />•  subprocess.call<br />PHP <br />•  system<br />•  shell_exec<br />•  exec<br />•  proc_open<br />•  eval<br /><br />•  passthru<br />•  proc_open<br />•  expect_open<br />•  ssh2_exec<br />•  popen<br />Perl <br />•  CGI.pm<br />•  referer<br />•  cookie<br />•  ReadParse<br />ASP.NET <br />•  HttpRequest.Params<br />•  HttpRequest.Url<br />•  HttpRequest.Item<br /><br /><h2>Remediation</h2><br /><br /><h3>Sanitization</h3><br />The URL and form data needs to be sanitized for invalid characters.  A  “blacklist” of characters is an option but it may be difficult to think  of all of the characters to validate against. Also there may be some  that were not discovered as of yet.  A “white list” containing only  allowable characters or command list should be created to validate the  user input.  Characters that were missed, as well as undiscovered  threats, should be eliminated by this list. <br />Genereal blacklist to be included for commannd injection can be  |      ;     &amp;    $    &gt;    &lt;   '    \   !   &gt;&gt;   # <br />Escape or filter special characters for windows,          ( ) &lt; &gt; &amp; * ‘ | = ? ; [ ] ^ ~ ! . ” % @ / \ : + , ` <br />Escape or filter special characters for Linux,          { }  ( ) &lt; &gt; &amp; * ‘ | = ? ; [ ]  $ – # ~ ! . ” %  / \ : + , ` <br /><br /><h3>Permissions</h3><br />The web application and its components should be running under strict  permissions that do not allow operating system command execution. Try  to verify all these informations to test from a Gray Box point of view <br /><br /><h2>Tools</h2><br />•  OWASP <a href="https://www.owasp.org/index.php/OWASP_WebScarab_Project">WebScarab</a> <br />•  OWASP <a href="https://www.owasp.org/index.php/OWASP_WebGoat_Project">WebGoat</a> <br />•  <a href="https://github.com/commixproject/commix">Commix</a><br /><br /><h2>References</h2><br />•  <a href="http://www.securityfocus.com/infocus/1709">http://www.securityfocus.com/infocus/1709</a><br />•  <a href="http://projects.webappsec.org/w/page/13246950/OS%20Commanding">http://projects.webappsec.org/w/page/13246950/OS%20Commanding</a><br />•  <a href="https://cwe.mitre.org/data/definitions/78.html">https://cwe.mitre.org/data/definitions/78.html</a><br />•  <a href="https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=2130132">https://www.securecoding.cert.org/confluence/pages/viewpage.action?pageId=2130132</a><br /></div></body></html>