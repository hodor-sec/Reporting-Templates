<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.8.4 Testing for HTTP Parameter pollution (OTG-INPVAL-004)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.8.4 Testing for HTTP Parameter pollution (OTG-INPVAL-004)  </h1><br/><br /><h2>Summary</h2><br /><br /> Supplying multiple HTTP parameters with the same name may cause an  application to interpret values in unanticipated ways. By exploiting  these effects, an attacker may be able to bypass input validation,  trigger application errors or modify internal variables values. As HTTP  Parameter Pollution (in short <em>HPP</em>) affects a building block of all web technologies, server and client side attacks exist.  <br /> <br /><br /> Current HTTP standards do not include guidance on how to interpret multiple input parameters with the same name. For instance, <a href="http://www.ietf.org/rfc/rfc3986.txt">RFC 3986</a> simply defines the term <em>Query String</em> as a series of field-value pairs and <a href="http://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a>  defines classes of reversed and unreserved query string characters.  Without a standard in place, web application components handle this edge  case in a variety of ways (see the table below for details).  <br /><br /> By itself, this is not necessarily an indication of vulnerability.  However, if the developer is not aware of the problem, the presence of  duplicated parameters may produce an anomalous behavior in the  application that can be potentially exploited by an attacker. As often  in security, unexpected behaviors are a usual source of weaknesses that  could lead to HTTP Parameter Pollution attacks in this case. To better  introduce this class of vulnerabilities and the outcome of HPP attacks,  it is interesting to analyze some real-life examples that have been  discovered in the past. <br /><br /> <br /><br /><h3>Input Validation and filters bypass</h3><br />In 2009, immediately after the publication of the first research on  HTTP Parameter Pollution, the technique received attention from the  security community as a possible way to bypass web application  firewalls. <br /><br /> One of these flaws, affecting <em>ModSecurity SQL Injection Core Rules</em>,  represents a perfect example of the impedance mismatch between  applications and filters.  The ModSecurity filter would correctly  blacklist the following string: <code>select 1,2,3 from table</code>, thus blocking this example URL from being processed by the web server: <code>/index.aspx?page=select 1,2,3 from table</code>.  However, by exploiting the concatenation of multiple HTTP parameters,  an attacker could cause the application server to concatenate the string  after the ModSecurity filter already accepted the input. As an example,  the URL <code>/index.aspx?page=select 1&amp;page=2,3</code> from table  would not trigger the ModSecurity filter, yet the application layer  would concatenate the input back into the full malicious string. <br /><br /> Another HPP vulnerability turned out to affect <em>Apple Cups</em>, the  well-known printing system used by many UNIX systems. Exploiting HPP, an  attacker could easily trigger a Cross-Site Scripting vulnerability  using the following URL: <a href="http://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&kerberos">http://127.0.0.1:631/admin/?kerberos=onmouseover=alert(1)&amp;kerberos</a>. The application validation checkpoint could be bypassed by adding an extra <code>kerberos</code>  argument having a valid string (e.g. empty string). As the validation  checkpoint would only consider the second occurrence, the first <code>kerberos</code>  parameter was not properly sanitized before being used to generate  dynamic HTML content. Successful exploitation would result in Javascript  code execution under the context of the hosting web site. <br /> <br /><br /><h3>Authentication bypass</h3><br />An even more critical HPP vulnerability was discovered in <em>Blogger</em>,  the popular blogging platform. The bug allowed malicious users to take  ownership of the victimâ€™s blog by using the following HTTP request: <br /><code> POST /add-authors.do HTTP/1.1 </code><br /><code>security_token=attackertoken&amp;blogID=attackerblogidvalue&amp;blogID=victimblogidvalue&amp;authorsList=goldshlager19test%40gmail.com(attacker  email)&amp;ok=Invite </code> <br /><br /> The flaw resided in the authentication mechanism used by the web application, as the security check was performed on the first <code>blogID</code> parameter, whereas the actual operation used the second occurrence. <br /> <br /><br /><h3>Expected Behavior by Application Server</h3><br /><br /> The following table illustrates how different web technologies behave in  presence of multiple occurrences of the same HTTP parameter. <br /><br /> Given the URL and querystring: <a href="http://example.com/?color=red&color=blue">http://example.com/?color=red&amp;color=blue</a> <br /><table class="table"><col/><col/><col/><tr><th> Web Application Server Backend </th><th> Parsing Result </th><th> Example</th></tr><tr><td> ASP.NET / IIS </td><td> All occurrences concatenated with a comma </td><td> color=red,blue</td></tr><tr><td> ASP / IIS </td><td> All occurrences concatenated with a comma</td><td> color=red,blue</td></tr><tr><td> PHP / Apache </td><td> Last occurrence only </td><td> color=blue</td></tr><tr><td> PHP / Zeus </td><td> Last occurrence only </td><td> color=blue</td></tr><tr><td> JSP, Servlet / Apache Tomcat </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> JSP, Servlet / Oracle Application Server 10g </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> JSP, Servlet / Jetty </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> IBM Lotus Domino </td><td> Last occurrence only </td><td> color=blue</td></tr><tr><td> IBM HTTP Server </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> mod_perl, libapreq2 / Apache </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> Perl CGI / Apache </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> mod_wsgi (Python) / Apache </td><td> First occurrence only </td><td> color=red</td></tr><tr><td> Python / Zope </td><td> All occurrences in List data type </td><td> color=['red','blue']</td></tr></table><br />(source: <a href="https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf">Media:AppsecEU09_CarettoniDiPaola_v0.8.pdf</a> ) <br /><br /> <br /><br /><h2>How to Test</h2><br />Luckily, because the assignment of HTTP parameters is typically  handled via the web application server, and not the application code  itself, testing the response to parameter pollution should be standard  across all pages and actions. However, as in-depth business logic  knowledge is necessary, testing HPP requires manual testing. Automatic  tools can only partially assist auditors as they tend to generate too  many false positives. In addition, HPP can manifest itself in  client-side and server-side components. <br /><br /> <br /><br /><h3>Server-side HPP</h3><br /><br /> To test for HPP vulnerabilities, identify any form or action that allows  user-supplied input. Query string parameters in HTTP GET requests are  easy to tweak in the navigation bar of the browser. If the form action  submits data via POST, the tester will need to use an intercepting proxy  to tamper with the POST data as it is sent to the server.  Having identified a particular input parameter to test, one can edit the  GET or POST data by intercepting the request, or change the query  string after the response page loads. To test for HPP vulnerabilities  simply append the same parameter to the GET or POST data but with a  different value assigned.  <br /><br /> For example: if testing the <code>search_string</code> parameter in the query string, the request URL would include that parameter name and value. <br /><a href="http://example.com/?search_string=kittens">http://example.com/?search_string=kittens</a>  <br /> <br />The particular parameter might be hidden among several other  parameters, but the approach is the same; leave the other parameters in  place and append the duplicate. <br /> <a href="http://example.com/?mode=guest&search_string=kittens&num_results=100">http://example.com/?mode=guest&amp;search_string=kittens&amp;num_results=100</a> <br /> Append the same parameter with a different value <br /> <a href="http://example.com/?mode=guest&search_string=kittens&num_results=100&search_string=puppies">http://example.com/?mode=guest&amp;search_string=kittens&amp;num_results=100&amp;search_string=puppies</a> <br /> and submit the new request.  <br /><br /> Analyze the response page to determine which value(s) were parsed. In the above example, the search results may show <code>kittens</code>, <code>puppies</code>, some combination of both (<code>kittens,puppies</code> or <code>kittens~puppies</code> or <code>['kittens','puppies']</code>), may give an empty result, or error page. <br /> <br />This behavior, whether using the first, last, or combination of  input parameters with the same name, is very likely to be consistent  across the entire application. Whether or not this default behavior  reveals a potential vulnerability depends on the specific input  validation and filtering specific to a particular application. As a  general rule: if existing input validation and other security mechanisms  are sufficient on single inputs, and if the server assigns only the  first or last polluted parameters, then parameter pollution does not  reveal a vulnerability. If the duplicate parameters are concatenated,  different web application components use different occurrences or  testing generates an error, there is an increased likelihood of being  able to use parameter pollution to trigger security vulnerabilities. <br /><br /> A more in-depth analysis would require three HTTP requests for each HTTP parameter: <br />1.  Submit an HTTP request containing the standard parameter name and value, and record the HTTP response. E.g. <code>page?par1=val1</code><br />2.  Replace the parameter value with a tampered value, submit and record the HTTP response. E.g. <code>page?par1=HPP_TEST1</code><br />3.  Send a new request combining step (1) and (2). Again, save the HTTP response. E.g. <code>page?par1=val1&amp;par1=HPP_TEST1</code><br />4.  Compare the responses obtained during all previous steps. If the response from (3) is different from (1) and the response from (3) is also different from (2), there is an impedance mismatch that may be eventually abused to trigger HPP vulnerabilities.<br /><br /> Crafting a full exploit from a parameter pollution weakness is beyond  the scope of this text. See the references for examples and details. <br /><br /> <br /><br /><h3>Client-side HPP</h3><br /><br /> Similarly to server-side HPP, manual testing is the only reliable  technique to audit web applications in order to detect parameter  pollution vulnerabilities affecting client-side components. While in the  server-side variant the attacker leverages a vulnerable web application  to access protected data or to perform actions that either not  permitted or not supposed to be executed, client-side attacks aim at  subverting client-side components and technologies.  <br /><br /> To test for HPP client-side vulnerabilities, identify any form or action  that allows user input and shows a result of that input back to the  user. A search page is ideal, but a login box might not work (as it  might not show an invalid username back to the user).  <br /><br /> Similarly to server-side HPP, pollute each HTTP parameter with <code>%26HPP_TEST</code> and look for <em>url-decoded</em> occurrences of the user-supplied payload: <br />â€¢  <code>&amp;HPP_TEST</code><br />â€¢  <code>&amp;amp;HPP_TEST</code><br />â€¢  â€¦ and others<br /><br /> In particular, pay attention to responses having HPP vectors within <code>data</code>, <code>src</code>, <code>href</code>  attributes or forms actions. Again, whether or not this default  behavior reveals a potential vulnerability depends on the specific input  validation, filtering and application business logic. In addition, it  is important to notice that this vulnerability can also affect query  string parameters used in XMLHttpRequest (XHR), runtime attribute  creation and other plugin technologies (e.g. Adobe Flashâ€™s flashvars  variables). <br /><br /><h2>Tools</h2><br />OWASP ZAP HPP Passive/Active Scanners <a href="https://code.google.com/p/zap-extensions/wiki/V1Extensions">[1]</a> <br />HPP Finder (Chrome Plugin) <a href="http://+https://chrome.google.com/webstore/detail/hpp-finder/nogojgcobcolombicplhimbbakkcmhio">[2]</a> <br /><br /><h2>References</h2><br /><strong>Whitepapers</strong><br /> HTTP Parameter Pollution - Luca Carettoni, Stefano di Paola <a href="https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf">[3]</a> <br />Split and Join (Bypassing Web Application Firewalls with HTTP Parameter Pollution) - Lavakumar Kuppan <a href="http://www.andlabs.org/whitepapers/Split_and_Join.pdf">[4]</a> <br />Client-side Http Parameter Pollution Example (Yahoo! Classic Mail flaw) - Stefano di Paola <a href="http://blog.mindedsecurity.com/2009/05/client-side-http-parameter-pollution.html">[5]</a> <br />How to Detect HTTP Parameter Pollution Attacks - Chrysostomos Daniel <a href="http://www.acunetix.com/blog/whitepaper-http-parameter-pollution/">[6]</a> <br />CAPEC-460: HTTP Parameter Pollution (HPP) - Evgeny Lebanidze <a href="http://capec.mitre.org/data/definitions/460.html">[7]</a> <br />Automated Discovery of Parameter Pollution Vulnerabilities in Web  Applications - Marco Balduzzi, Carmen Torrano Gimenez, Davide  Balzarotti, Engin Kirda <a href="http://www.iseclab.org/people/embyte/papers/hpp.pdf">[8]</a> <br /></div></body></html>