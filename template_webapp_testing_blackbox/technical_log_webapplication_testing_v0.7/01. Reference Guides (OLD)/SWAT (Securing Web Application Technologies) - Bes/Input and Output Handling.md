
| Best Practice | Description | CWE ID |
| --- | --- | --- |
| Conduct Contextual Output Encoding | All output functions must contextually encode data before sendingit to the user. Depending on where the output will end up in the HTML page, the output must be encoded differently. For example, data placed in the URL context must be encoded differently than data placed in JavaScript context within the HTML page.<br>Example: Resource: https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet | cwe-79 |
| Prefer Whitelists over Blacklists | For each user input field, there should be validation on the input content. Whitelisting input is the preferred approach. Only accept data that meets a certain criteria. For input that needs more flexibility, blacklisting can also be applied where known bad input patterns or characters are blocked. | cwe-159<br>cwe-144 |
| Use Parameterized SQL Queries | SQL queries should be crafted with user content passed into a bind variable. Queries written this way are safe against SQL injectionattacks. SQL queries should not be created dynamically using string concatenation. Similarly, the SQL query string used in a bound or parameterized query should never be dynamically built from user input.<br>Example: Sony SQL injection Hack (http://www.infosecurity-magazine.com/view/27930/lulzsec-sony-pictures-hackers-were-school-chums) | cwe-89<br>cwe-564 |
| Use Tokens to Prevent Forged Requests | In order to prevent Cross-Site Request Forgery attacks, you must embed a random value that is not known to third parties into the HTML form. This CSRF protection token must be unique to each request. This prevents a forged CSRF request from being submitted because the attacker does not know the value of the token. | cwe-352 |
| Set the Encoding for Your Application | For every page in your application set the encoding using HTTPheaders or meta tags within HTML. This ensures that the encoding ofthe page is always defined and that browser will not have to determine the encoding on its own. Setting a consistent encoding, like UTF-8, for your application reduces the overall risk of issues like Cross-Site Scripting. | cwe-172 |
| Validate Uploaded Files | When accepting file uploads from the user make sure to validate the size of the file, the file type, and the file contents as well as ensuring that it is not possible to override the destination path for the file. | cwe-434<br>cwe-616<br>cwe-22 |
| Use the Nosniff Header for Uploaded Content | When hosting user uploaded content which can be viewed by other users, use the X-Content-Type-Options: nosniff header so that browsers do not try to guess the data type. Sometimes the browser can be tricked into displaying the data type incorrectly (e.g. showing a GIF file as HTML). Always let the server or application determine the data type. | cwe-430 |
| Validate the Source of Input | The source of the input must be validated. For example, if input is expected from a POST request do not accept the input variable from a GET request. | cwe-20<br>cwe-346 |
| Use the X-Frame-Options Header | Use the X-Frame-Options header to prevent content from being loaded by a foreign site in a frame. This mitigates Clickjackingattacks. For older browsers that do not support this header add framebusting Javascript code to mitigate Clickjacking (although thismethod is not foolproof and can be circumvented).<br>Example: Flash camera and mic hack (http://jeremiahgrossman.blogspot.com/2008/10/clickjacking-web-pages-can-see-and-hear.html) | caPec-103<br>cwe-693 |
| Use Secure HTTP Response Headers | The Content Security Policy (CSP), X-XSS-Protection, and Public-Key-Pins headers help defend against Cross-Site Scripting (XSS) and Man-in-the-Middle (MITM) attacks.<br>Example: OWASP Secure Headers Project | cwe-79<br>cwe-692 |

