<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>OWASP</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">OWASP</h1><br/><strong>Source</strong><br /><a href="https://owasp.org/www-community/attacks/csrf">https://owasp.org/www-community/attacks/csrf</a><br /><br /><br /><h2>Overview</h2><br />Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted actions on a web application in which they’re currently authenticated. With a little help of social engineering (such as sending a link via email or chat), an attacker may trick the users of a web application into executing actions of the attacker’s choosing. If the victim is a normal user, a successful CSRF attack can force the user to perform state changing requests like transferring funds, changing their email address, and so forth. If the victim is an administrative account, CSRF can compromise the entire web application.<br /><br /><h2>Related Security Activities</h2><br /><br /><h3>How to Review Code for CSRF Vulnerabilities</h3><br />See the <a href="https://owasp.org/www-project-code-review-guide">OWASP Code Review Guide</a> article on how to <a href="https://owasp.org/www-project-code-review-guide/reviewing-code-for-csrf-issues">review code for CSRF vulnerabilities</a>.<br /><br /><h3>How to Test for CSRF Vulnerabilities</h3><br />See the <a href="https://owasp.org/www-project-web-security-testing-guide/">OWASP Testing Guide</a> article on how to <a href="https://owasp.org/www-community/attacks/Testing_for_CSRF_/(OTG-SESS-005/)">test for CSRF vulnerabilities</a>.<br /><br /><h3>How to Prevent CSRF Vulnerabilities</h3><br />See the <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">CSRF Prevention Cheat Sheet</a> for prevention measures.<br />Listen to the <a href="https://www.owasp.org/download/jmanico/owasp_podcast_69.mp3">OWASP Top Ten CSRF Podcast</a>.<br />Most frameworks have built-in CSRF support such as <a href="https://docs.joomla.org/How_to_add_CSRF_anti-spoofing_to_forms">Joomla</a>, <a href="http://blog.eyallupu.com/2012/04/csrf-defense-in-spring-mvc-31.html">Spring</a>, <a href="http://web.securityinnovation.com/appsec-weekly/blog/bid/84318/Cross-Site-Request-Forgery-CSRF-Prevention-Using-Struts-2">Struts</a>, <a href="http://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf">Ruby on Rails</a>, <a href="https://www.troyhunt.com/2010/11/owasp-top-10-for-net-developers-part-5.html">.NET</a> and others.<br />Use <a href="https://owasp.org/www-community/attacks/:Category:OWASP_CSRFGuard_Project">OWASP CSRF Guard</a> to add CSRF protection to your Java applications. You can use <a href="https://owasp.org/www-community/attacks/CSRFProtector_Project">CSRFProtector Project</a> to protect your php applications or any project deployed using Apache Server. There is a <a href="https://owasp.org/www-community/attacks/.Net_CSRF_Guard">.Net CSRF Guard</a> at OWASP as well, but it’s old and doesn’t look complete.<br />John Melton also has an <a href="http://www.jtmelton.com/2010/05/16/the-owasp-top-ten-and-esapi-part-6-cross-site-request-forgery-csrf/">excellent blog post</a> describing how to use the native anti-CSRF functionality of the <a href="https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API">OWASP ESAPI</a>.<br /><br /><h2>Description</h2><br />CSRF is an attack that tricks the victim into submitting a malicious request. It inherits the identity and privileges of the victim to perform an undesired function on the victim’s behalf. For most sites, browser requests automatically include any credentials associated with the site, such as the user’s session cookie, IP address, Windows domain credentials, and so forth. Therefore, if the user is currently authenticated to the site, the site will have no way to distinguish between the forged request sent by the victim and a legitimate request sent by the victim.<br />CSRF attacks target functionality that causes a state change on the server, such as changing the victim’s email address or password, or purchasing something. Forcing the victim to retrieve data doesn’t benefit an attacker because the attacker doesn’t receive the response, the victim does. As such, CSRF attacks target state-changing requests.<br />It’s sometimes possible to store the CSRF attack on the vulnerable site itself. Such vulnerabilities are called “stored CSRF flaws”. This can be accomplished by simply storing an IMG or IFRAME tag in a field that accepts HTML, or by a more complex cross-site scripting attack. If the attack can store a CSRF attack in the site, the severity of the attack is amplified. In particular, the likelihood is increased because the victim is more likely to view the page containing the attack than some random page on the Internet. The likelihood is also increased because the victim is sure to be authenticated to the site already.<br /><br /><h3>Synonyms</h3><br />CSRF attacks are also known by a number of other names, including XSRF, “Sea Surf”, Session Riding, Cross-Site Reference Forgery, and Hostile Linking. Microsoft refers to this type of attack as a One-Click attack in their threat modeling process and many places in their online documentation.<br /><br /><h3>Prevention measures that do NOT work</h3><br /><br /><h2>Using a secret cookie</h2><br />Remember that all cookies, even the secret ones, will be submitted with every request. All authentication tokens will be submitted regardless of whether or not the end-user was tricked into submitting the request. Furthermore, session identifiers are simply used by the application container to associate the request with a specific session object. The session identifier does not verify that the end-user intended to submit the request.<br /><br /><h2>Only accepting POST requests</h2><br />Applications can be developed to only accept POST requests for the execution of business logic. The misconception is that since the attacker cannot construct a malicious link, a CSRF attack cannot be executed. Unfortunately, this logic is incorrect. There are numerous methods in which an attacker can trick a victim into submitting a forged POST request, such as a simple form hosted in an attacker’s Website with hidden values. This form can be triggered automatically by JavaScript or can be triggered by the victim who thinks the form will do something else.<br />A number of flawed ideas for defending against CSRF attacks have been developed over time. Here are a few that we recommend you avoid.<br /><br /><h2>Multi-Step Transactions</h2><br />Multi-Step transactions are not an adequate prevention of CSRF. As long as an attacker can predict or deduce each step of the completed transaction, then CSRF is possible.<br /><br /><h2>URL Rewriting</h2><br />This might be seen as a useful CSRF prevention technique as the attacker cannot guess the victim’s session ID. However, the user’s session ID is exposed in the URL. We don’t recommend fixing one security flaw by introducing another.<br /><br /><h2>HTTPS</h2><br />HTTPS by itself does nothing to defend against CSRF.<br />However, HTTPS should be considered a prerequisite for any preventative measures to be trustworthy.<br /><br /><h2>Examples</h2><br /><br /><h3>How does the attack work?</h3><br />There are numerous ways in which an end user can be tricked into loading information from or submitting information to a web application. In order to execute an attack, we must first understand how to generate a valid malicious request for our victim to execute. Let us consider the following example: Alice wishes to transfer $100 to Bob using the bank.com web application that is vulnerable to CSRF. Maria, an attacker, wants to trick Alice into sending the money to her instead. The attack will comprise the following steps:<br />1. building an exploit URL or script<br />2. tricking Alice into executing the action with <a href="https://owasp.org/www-community/attacks/Social_Engineering">socialengineering</a><br /><br /><h3>GET scenario</h3><br />If the application was designed to primarily use GET requests to transfer parameters and execute actions, the money transfer operation might be reduced to a request like:<br /><code>GET http://bank.com/transfer.do?acct=BOB&amp;amount=100 HTTP/1.1</code><br />Maria now decides to exploit this web application vulnerability using Alice as her victim. Maria first constructs the following exploit URL which will transfer $100,000 from Alice’s account to her account. She takes the original command URL and replaces the beneficiary name with herself, raising the transfer amount significantly at the same time:<br /><code>http://bank.com/transfer.do?acct=MARIA&amp;amount=100000</code><br />The <a href="https://owasp.org/www-community/attacks/Social_Engineering">social engineering</a> aspect of the attack tricks Alice into loading this URL when she’s logged into the bank application. This is usually done with one of the following techniques:<br />• sending an unsolicited email with HTML content<br />• planting an exploit URL or script on pages that are likely to bevisited by the victim while they are also doing online banking<br />The exploit URL can be disguised as an ordinary link, encouraging the victim to click it:<br /><code>&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures!&lt;/a&gt;</code><br />Or as a 0x0 fake image:<br /><code>&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="0" height="0" border="0"&gt;</code><br />If this image tag were included in the email, Alice wouldn’t see anything. However, the browser will still submit the request to bank.com without any visual indication that the transfer has taken place.<br />A real life example of CSRF attack on an application using GET was a <a href="https://www.ghacks.net/2008/01/17/dos-vulnerability-in-utorrent-and-bittorrent/">uTorrent exploit</a> from 2008 that was used on a mass scale to download malware.<br /><br /><h3>POST scenario</h3><br />The only difference between GET and POST attacks is how the attack is being executed by the victim. Let’s assume the bank now uses POST and the vulnerable request looks like this:<br /><code>POST http://bank.com/transfer.do HTTP/1.1</code><br /><code>acct=BOB&amp;amount=100</code><br />Such a request cannot be delivered using standard A or IMG tags, but can be delivered using a FORM tags:<br /><code>&lt;form action="http://bank.com/transfer.do" method="POST"&gt;<br /><br />&lt;input type="hidden" name="acct" value="MARIA"/&gt;<br />&lt;input type="hidden" name="amount" value="100000"/&gt;<br />&lt;input type="submit" value="View my pictures"/&gt;<br /><br />&lt;/form&gt;<br /></code>This form will require the user to click on the submit button, but this can be also executed automatically using JavaScript:<br /><code>&lt;body onload="document.forms[0].submit()"&gt;<br /><br />`&lt;form...`<br /></code><br /><h3>Other HTTP methods</h3><br />Modern web application APIs frequently use other HTTP methods, such as PUT or DELETE. Let’s assume the vulnerable bank uses PUT that takes a JSON block as an argument:<br /><code>`PUT http://bank.com/transfer.do HTTP/1.1`<br /><br />`{ "acct":"BOB", "amount":100 }`<br /></code>Such requests can be executed with JavaScript embedded into an exploit page:<br /><code>&lt;script&gt;<br />function put() {<br />    var x = new XMLHttpRequest();<br />    x.open("PUT","http://bank.com/transfer.do",true);<br />    x.setRequestHeader("Content-Type", "application/json");<br />    x.send(JSON.stringify({"acct":"BOB", "amount":100})); <br />}<br />&lt;/script&gt;<br /><br />&lt;body onload="put()"&gt;<br /></code>Fortunately, this request will not be executed by modern web browsers thanks to <a href="https://owasp.org/www-community/attacks/Same-Origin_Policy">same-origin policy</a> restrictions. This restriction is enabled by default unless the target web site explicitly opens up cross-origin requests from the attacker’s (or everyone’s) origin by using <a href="https://owasp.org/www-community/attacks/HTML5_Security_Cheat_Sheet#Cross_Origin_Resource_Sharing">CORS</a> with the following header:<br /><code>Access-Control-Allow-Origin: *</code><br /><br /><h2>Related </h2><a href="https://owasp.org/www-community/attacks/">Attacks</a><br />• <a href="https://owasp.org/www-community/attacks/xss/">Cross-site Scripting(XSS)</a><br />• <a href="https://owasp.org/www-community/attacks/Cross_Site_History_Manipulation_(XSHM)">Cross Site History Manipulation(XSHM)</a><br /><br /><h2>Related </h2><a href="https://owasp.org/www-community/controls/">Controls</a><br />• Add a per-request nonce to the URL and all forms in addition to thestandard session. This is also referred to as “form keys”. Manyframeworks (e.g., Drupal.org 4.7.4+) either have or are starting toinclude this type of protection “built-in” to every form so theprogrammer does not need to code this protection manually.<br />• Add a hash (session id, function name, server-side secret) to allforms.<br />• For .NET, add a session identifier to ViewState with MAC (describedin detail in <a href="https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html#asp-net-web-forms-guidance">the DotNet Security CheatSheet</a>).<br />• Checking the referrer header in the client’s HTTP request canprevent CSRF attacks. Ensuring that the HTTP request has come fromthe original site means that attacks from other sites will notfunction. It is very common to see referrer header checks used onembedded network hardware due to memory limitations.• XSS can be used to bypass both referrer and token based checkssimultaneously. For instance, the <a href="https://en.wikipedia.org/wiki/Samy_%28computer_worm%29">Samyworm</a>used an <a href="https://owasp.org/www-community/attacks/XHR">XHR</a> to obtain the CSRF token to forgerequests.<br /><br />• “Although CSRF is fundamentally a problem with the web application,not the user, users can help protect their accounts at poorlydesigned sites by logging off the site before visiting another, orclearing their browser’s cookies at the end of each browsersession.”–http://en.wikipedia.org/wiki/Cross-site_request_forgery#_note-1<br />• <a href="https://owasp.org/www-community/attacks/Tokenizing">Tokenizing</a><br /><br /><h2>References</h2><br />• OWASP <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">Cross-Site Request Forgery (CSRF) Prevention CheatSheet</a><br />• <a href="http://www.cgisecurity.com/articles/csrf-faq.shtml">The Cross-Site Request Forgery (CSRF/XSRF)FAQ</a><br />- quote: “This paper serves as a living document for Cross-Site Request Forgery issues. This document will serve as a repository of information from existing papers, talks, and mailing list postings and will be updated as new information is discovered.”<br />• <a href="https://owasp.org/www-community/attacks/Testing_for_CSRF_/(OWASP-SM-005/)">Testing for CSRF</a><br />- CSRF (aka Session riding) paper from the OWASP Testing Guide project.<br />• <a href="http://www.darkreading.com/document.asp?doc_id=107651&WT.svl=news1_2">CSRF Vulnerability: A ‘SleepingGiant’</a><br />- Overview Paper<br />• <a href="https://www.owasp.org/index.php/Image:RequestRodeo-MartinJohns.pdf">Client Side Protection against SessionRiding</a><br />- Martin Johns and Justus Winter’s interesting paper and presentation for the 4th OWASP AppSec Conference which described potential techniques that browsers could adopt to automatically provide CSRF protection - <a href="https://www.owasp.org/index.php/Image:RequestRodeo-MartinJohns.pdf">PDF paper</a><br />• <a href="https://owasp.org/www-community/attacks/:Category:OWASP_CSRFGuard_Project">OWASP CSRF Guard</a><br />- J2EE, .NET, and PHP Filters which append a unique request token to each form and link in the HTML response in order to provide universal coverage against CSRF throughout your entire application.<br />• <a href="https://owasp.org/www-community/attacks/CSRFProtector_Project">OWASP CSRF Protector</a><br />- Anti CSRF method to mitigate CSRF in web applications. Currently implemented as a PHP library &amp; Apache 2.x.x module<br />• <a href="http://yehg.net/lab/pr0js/view.php/A_Most-Neglected_Fact_About_CSRF.pdf">A Most-Neglected Fact About Cross Site Request Forgery(CSRF)</a><br />- Aung Khant, <a href="http://yehg.net">http://yehg.net</a>, explained the danger and impact of CSRF with imperiling scenarios.<br />• <a href="https://owasp.org/www-community/attacks/:Category:OWASP_CSRFTester_Project">OWASP CSRF Tester</a><br />- The OWASP CSRFTester gives developers the ability to test their applications for CSRF flaws.<br />• <a href="https://code.google.com/p/pinata-csrf-tool/">Pinata-CSRF-Tool: CSRF POCtool</a><br />- Pinata makes it easy to create Proof of Concept CSRF pages. Assists in Application Vulnerability Assessment.<br /></div></body></html>