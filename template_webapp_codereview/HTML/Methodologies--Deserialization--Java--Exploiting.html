<!doctype html><html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>Exploiting</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles3.css" type="text/css" />
  
    <script type="text/javascript">
        function in_frame () { try { return window.self !== window.top; } catch (e) { return true; } }
        if (!in_frame()) {
            var page = location.pathname.substring(location.pathname.lastIndexOf("/") + 1);
            window.location = 'index.html#' + page;
        }
    </script>
</head>
<body><div class="page"><h1 class="title">Exploiting</h1><br/><strong><h2>Exploiting Deserialization</h2></strong><br /><br />To exploit a deserialization vulnerability we need two key things:<br />1. An entry point that allows us to send our own serialized objects to the target for deserialization.<br />2. One or more code snippets that we can manipulate through deserialization.<br /><br /><strong><h3>Entry Points</h3></strong><br /><br />We can identify entry points for deserialization vulnerabilities by reviewing application source code for the use of the class ‘java.io.ObjectInputStream’ (and specifically the ‘readObject’ method), or for serializable classes that implement the ‘readObject’  method. If an attacker can manipulate the data that is provided to the  ObjectInputStream then that data presents an entry point for  deserialization attacks. Alternatively, or if the Java source code is  unavailable, we can look for serialized data being stored on disk or  transmitted over the network, provided we know what to look for!<br /><br /><img src="images/1128-1.png" alt="images/1128-1.png" /><br /><br />The Java serialization format begins with a two-byte magic number  which is always hex 0xAC ED. This is followed by a two-byte version  number. I’ve only ever seen version 5 (0x00 05) but earlier versions may  exist and in future later versions may also exist. Following the  four-byte header are one or more content elements, the first byte of  each should be in the range 0x70 to 0x7E and describes the type of the  content element which is used to infer the structure of the following  data in the stream. For more details see Oracle’s documentation on the <a href="https://docs.oracle.com/javase/7/docs/platform/serialization/spec/protocol.html">Object Serialization Stream Protocol</a>.<br /><br />People often say to look for the four-byte sequence 0xAC ED 00 05 in  order to identify Java serialization, and in fact some IDS signatures  look for this sequence to detect attacks. During my recent client  engagement I didn’t immediately see those four bytes because the target  client application kept a network connection to the server open the  entire time it was running and the four-byte header only exists once at  the very beginning of a serialization stream. The client’s IDS missed my  attacks for this reason – my payloads were sent later in the stream and  separately from the serialization header.<br /><br />We can use an ASCII dump to help identify Java serialization data without relying on the four-byte 0xAC ED 00 05 header.<br /><img src="images/1128-2.png" alt="images/1128-2.png" /><br />The most obvious indicator of Java serialization data is the presence of Java class names in the dump, such as ‘java.rmi.dgc.Lease’. In some cases Java class names might appear in an alternative format that begins with an ‘L’, ends with a ‘;’, and uses forward slashes to separate namespace parts and the class name (e.g. ‘Ljava/rmi/dgc/VMID;’).  Along with Java class names, there are some other common strings that  appear due to the serialization format specification, such as ‘sr’ which may represent an object (TC_OBJECT) followed by its class description (TC_CLASSDESC), or ‘xp’ which may indicate the end of the class annotations (TC_ENDBLOCKDATA) for a class which has no super class (TC_NULL).<br /><br />Having identified the use of serialized data, we need to identify the  offset into that data where we can actually inject a payload. The  target needs to call ‘ObjectInputStream.readObject’ in order to  deserialize and instantiate an object (payload) and support  property-oriented programming, however it could call other  ObjectInputStream methods first, such as ‘readInt’ which will  simply read a 4-byte integer from the stream. The readObject method will  read the following content types from a serialization stream:<br /><br />• 0x70 – TC_NULL<br />• 0x71 – TC_REFERENCE<br />• 0x72 – TC_CLASSDESC<br />• 0x73 – TC_OBJECT<br />• 0x74 – TC_STRING<br />• 0x75 – TC_ARRAY<br />• 0x76 – TC_CLASS<br />• 0x7B – TC_EXCEPTION<br />• 0x7C – TC_LONGSTRING<br />• 0x7D – TC_PROXYCLASSDESC<br />• 0x7E – TC_ENUM<br />• <br />In the simplest cases an object will be the first thing read from the  serialization stream and we can insert our payload directly after the  4-byte serialization header. We can identify those cases by looking at  the first five bytes of the serialization stream. If those five bytes  are a four-byte serialization header (0xAC ED 00 05) followed by one of  the values listed above then we can attack the target by sending our own  four-byte serialization header followed by a payload object.<br /><br />In other cases, the four-byte serialization header will most likely  be followed by a TC_BLOCKDATA element (0x77) or a TC_BLOCKDATALONG  element (0x7A). The former consists of a single byte length field  followed by that many bytes making up the actual block data and the  latter consists of a four-byte length field followed by that many bytes  making up the block of data. If the block data is followed by one of the  element types supported by readObject then we can inject a payload  after the block data.<br /><br />I wrote a tool to support some of my research in this area, <a href="https://github.com/NickstaDB/SerializationDumper">SerializationDumper</a>,  which we can use to identify entry points for deserialization exploits.  The tool parses Java serialization streams and dumps them out in a  human-readable form. If the stream contains one of the element types  supported by readObject then we can replace that element with a payload  object. Below is an example of its use:<br /><br />$ java -jar SerializationDumper-v1.11.jar ACED00057708af743f8c1d120cb974000441424344<br />Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true<br /><br />STREAM_MAGIC - 0xac ed<br />STREAM_VERSION - 0x00 05<br />Contents<br />  TC_BLOCKDATA - 0x77<br />    Length - 8 - 0x08<br />    Contents - 0xaf743f8c1d120cb9<br />  TC_STRING - 0x74<br />    newHandle 0x00 7e 00 00<br />    Length - 4 - 0x00 04<br />    Value - ABCD - 0x41424344<br />       <br />     In this example the stream contains a TC_BLOCKDATA followed by a TC_STRING which can be replaced with a payload.<br />Objects in a serialization stream are instantiated as they are  loaded, rather than after the entire stream has been parsed. This fact  allows us to inject payloads into a serialization stream without  worrying about correcting the remainder of the stream. The payload will  be deserialized and executed before any kind of validation happens and  before the application attempts to read further data from the  serialization stream.<br /></div></body></html>